[
  {
    "input": "A simple drawing program in only 14 lines",
    "output": "Dim drawing As Integer\nDo\n    If _MouseButton(1) Then\n        If Not drawing Then\n            PSet (_MouseX, _MouseY)\n            drawing = -1\n        Else\n            Line -(_MouseX, _MouseY)\n        End If\n    Else \n        drawing = 0\n    End If\n    _Limit 30\nLoop"
  },
  {
    "input": "Fractal Fern",
    "output": "Screen 12\nRandomize Timer\nColor _RGB(Rnd * 255, Rnd * 255, Rnd * 255)\nDim As Single X, Y, xx, yy\nDim as Integer n, i\nFor i = 1 TO 100000\n    n = RND * 100\n    If n < 1 Then\n        Xp = 0\n        Yp = .16 * Y\n    ElseIf n >= 1 And n <= 8 Then\n        Xp = .2 * X - .26 * Y\n        Yp = .23 * X + .22 * Y + 1.6\n    ElseIf n >= 8 And n <= 15 Then\n        Xp = -.15 * X + .28 * Y\n        Yp = .26 * X + .24 * Y + .44\n    Else\n        Xp = .85 * X + .04 * Y\n        Yp = -.04 * X + .85 * Y + 1.6\n    End If\n    X = Xp\n    Y = Yp\n    xx = X * 45\n    yy = Y * 45 - 225\n    PSet (xx + 320, -yy + 240)\nNext i"
  },
  {
    "input": "Rotating Lorenz Attractor",
    "output": "Screen _NewImage(640, 480, 32)\nDim As Double p, s, b, h, x, y, z, i, rot\np = 28\ns = 10\nb = 8 / 3\nh = 0.01\n\nDo\n    Cls\n    rot = rot + 0.01\n    x = 0.3\n    y = 0.3\n    z = 0.456\n    xx = x * Cos(rot) - y * Sin(rot)\n    yy = x * Sin(rot) + y * Cos(rot)\n            \n    PreSet (_Width / 2 + 35 * xx * 700 / (yy + 2500), _Height - 35 * z * 700 / (yy + 2500)), _RGB(255, 255, 0)\n    For i = 0 To 14000\n        x = x + h * s * (y - x)\n        y = y + h * (x * (p - z) - y)\n        z = z + h * (x * y - b * z)\n        xx = x * Cos(rot) - y * Sin(rot)\n        yy = x * Sin(rot) + y * Cos(rot)\n        Line -(_Width / 2 + 35 * xx * 700 / (yy + 2500), _Height - 35 * z * 700 / (yy + 2500)), _RGB(255, 255, 0)\n    Next\n\n    _Limit 60\nLoop"
  },
  {
    "input": "Tetris",
    "output": "'Option _Explicit\n'Randomize Timer\n'DefLng A-Z\n\nType RotResult\n    xx As Double\n    yy As Double\nEnd Type\n\nDim Shared As Double piece(6, 3, 1)\nDim Shared piece_color(6)\nDim Shared As Double size, sw, sh\n\nsize = 25\nsw = 10\nsh = 20\n\nReDim Shared As Double board(sw - 1, sh - 1)\n\npiece(0, 0, 0) = 0: piece(0, 1, 0) = 1: piece(0, 2, 0) = 1: piece(0, 3, 0) = 0\npiece(0, 0, 1) = 0: piece(0, 1, 1) = 1: piece(0, 2, 1) = 1: piece(0, 3, 1) = 0\npiece(1, 0, 0) = 1: piece(1, 1, 0) = 1: piece(1, 2, 0) = 1: piece(1, 3, 0) = 1\npiece(1, 0, 1) = 0: piece(1, 1, 1) = 0: piece(1, 2, 1) = 0: piece(1, 3, 1) = 0\npiece(2, 0, 0) = 0: piece(2, 1, 0) = 0: piece(2, 2, 0) = 1: piece(2, 3, 0) = 1\npiece(2, 0, 1) = 0: piece(2, 1, 1) = 1: piece(2, 2, 1) = 1: piece(2, 3, 1) = 0\npiece(3, 0, 0) = 0: piece(3, 1, 0) = 1: piece(3, 2, 0) = 1: piece(3, 3, 0) = 0\npiece(3, 0, 1) = 0: piece(3, 1, 1) = 0: piece(3, 2, 1) = 1: piece(3, 3, 1) = 1\npiece(4, 0, 0) = 0: piece(4, 1, 0) = 1: piece(4, 2, 0) = 1: piece(4, 3, 0) = 1\npiece(4, 0, 1) = 0: piece(4, 1, 1) = 0: piece(4, 2, 1) = 1: piece(4, 3, 1) = 0\npiece(5, 0, 0) = 0: piece(5, 1, 0) = 1: piece(5, 2, 0) = 1: piece(5, 3, 0) = 1\npiece(5, 0, 1) = 0: piece(5, 1, 1) = 1: piece(5, 2, 1) = 0: piece(5, 3, 1) = 0\npiece(6, 0, 0) = 0: piece(6, 1, 0) = 1: piece(6, 2, 0) = 1: piece(6, 3, 0) = 1\npiece(6, 0, 1) = 0: piece(6, 1, 1) = 0: piece(6, 2, 1) = 0: piece(6, 3, 1) = 1\n\nScreen _NewImage(sw * size, sh * size, 32)\n\npiece_color(0) = _RGB(0, 200, 0)\npiece_color(1) = _RGB(200, 0, 0)\npiece_color(2) = _RGB(156, 85, 211)\npiece_color(3) = _RGB(219, 112, 147)\npiece_color(4) = _RGB(0, 100, 250)\npiece_color(5) = _RGB(230, 197, 92)\npiece_color(6) = _RGB(0, 128, 128)\n\nDim t As Double\n\nDim As Double redraw, speed, lines, pause, putpiece, startx, pn, px, py, rot, n, y, x, k, shift, xx, yy\nDim As RotResult res\nredraw = -1\n\nspeed = 3\nlines = 0\npause = 0\nputpiece = 0\nstartx = (sw - 4) / 2\n\npn = Int(Rnd * 7)\npx = startx\npy = 1\nrot = 0\n\nDim title$\ntitle$ = \"lines=\" + LTrim$(Str$(lines)) + \",speed=\" + LTrim$(Str$(speed))\n_Title title$\n\nt = Timer\n\nDo\n    If (Timer - t) > (1 / speed) And Not pause Then\n        If valid(pn, px, py + 1, rot) Then\n            py = py + 1\n        Else\n            putpiece = -1\n        End If\n\n        t = Timer\n        redraw = -1\n    End If\n\n    If putpiece Then\n        If valid(pn, px, py, rot) Then\n            n = place(pn, px, py, rot)\n            If n Then\n                lines = lines + n\n                title$ = \"lines=\" + LTrim$(Str$(lines)) + \",speed=\" + LTrim$(Str$(speed))\n                _Title title$\n            End If\n        End If\n\n        pn = Int(Rnd * 7)\n        px = startx\n        py = 0\n        rot = 0\n\n        putpiece = 0\n        redraw = -1\n\n        If Not valid(pn, px, py, rot) Then\n            For y = 0 To sh - 1\n                For x = 0 To sw - 1\n                    board(x, y) = 0\n                Next\n            Next\n            lines = 0\n            title$ = \"lines=\" + LTrim$(Str$(lines)) + \",speed=\" + LTrim$(Str$(speed))\n            _Title title$\n        End If\n    End If\n\n    If redraw Then\n        Line (0, 0)-(sw * size, sh * size), _RGB(0, 0, 0), BF\n        For y = 0 To sh - 1\n            For x = 0 To sw - 1\n                If board(x, y) <> 0 Then\n                    Line (x * size, y * size)-Step(size - 2, size - 2), piece_color(board(x, y) - 1), BF\n                Else\n                    Line (x * size, y * size)-Step(size - 2, size - 2), _RGB(50, 50, 50), B\n                End If\n            Next\n        Next\n\n        For y = 0 To 1\n            For x = 0 To 3\n                'rotate xx, yy, x, y, pn, rot\n                rotate res, x, y, pn, rot\n                If piece(pn, x, y) Then Line ((px + res.xx) * size, (py + res.yy) * size)-Step(size - 2, size - 2), piece_color(pn), BF\n            Next\n        Next\n\n        _Display\n        redraw = 0\n    End If\n\n    k = _KeyHit\n    If k Then\n        shift = _KeyDown(100304) Or _KeyDown(100303)\n        Select Case k\n            Case 18432 'up\n                If valid(pn, px, py, (rot + 1) Mod 4) Then rot = (rot + 1) Mod 4\n                pause = 0\n            Case 19200 'left\n                If shift Then\n                    For xx = 0 To sw - 1\n                        If Not valid(pn, px - xx, py, rot) Then Exit For\n                    Next\n                    px = px - xx + 1\n                Else\n                    If valid(pn, px - 1, py, rot) Then px = px - 1\n                End If\n                pause = 0\n            Case 19712 'right\n                If shift Then\n                    For xx = px To sw - 1\n                        If Not valid(pn, xx, py, rot) Then Exit For\n                    Next\n                    px = xx - 1\n                Else\n                    If valid(pn, px + 1, py, rot) Then px = px + 1\n                End If\n                pause = 0\n            Case 20480, 32 'down\n                If shift Or k = 32 Then\n                    For yy = py To sh - 1\n                        If Not valid(pn, px, yy, rot) Then Exit For\n                    Next\n                    py = yy - 1\n                    putpiece = -1\n                Else\n                    If valid(pn, px, py + 1, rot) Then py = py + 1\n                End If\n                pause = 0\n            Case 112 'p\n                pause = Not pause\n            Case 13 'enter\n                For y = 0 To sh - 1\n                    For x = 0 To sw - 1\n                        board(x, y) = 0\n                    Next\n                Next\n                pn = Int(Rnd * 7)\n                px = startx\n                py = 0\n                rot = 0\n                putpiece = 0\n                lines = 0\n                title$ = \"lines=\" + LTrim$(Str$(lines)) + \",speed=\" + LTrim$(Str$(speed))\n                _Title title$\n            Case 43, 61 'plus\n                If speed < 100 Then\n                    speed = speed + 1\n                    title$ = \"lines=\" + LTrim$(Str$(lines)) + \",speed=\" + LTrim$(Str$(speed))\n                    _Title title$\n                End If\n            Case 95, 45\n                If speed > 1 Then\n                    speed = speed - 1\n                    title$ = \"lines=\" + LTrim$(Str$(lines)) + \",speed=\" + LTrim$(Str$(speed))\n                    _Title title$\n                End If\n            Case 27\n                Exit Do\n        End Select\n\n        redraw = -1\n    End If\n    _Limit 60\nLoop\nSystem\n\nSub rotate (res As RotResult, x, y, pn, rot)\n    Dim rot_new As Double\n    If pn = 0 Then\n        rot_new = 0\n    ElseIf pn >= 4 Then\n        rot_new = rot\n    Else\n        rot_new = rot Mod 2\n    End If\n\n    Select Case rot_new\n        Case 0\n            res.xx = x\n            res.yy = y\n        Case 1\n            res.xx = y + 2\n            res.yy = 2 - x\n        Case 2\n            res.xx = 4 - x\n            res.yy = 1 - y\n        Case 3\n            res.xx = 2 - y\n            res.yy = x - 1\n    End Select\nEnd Sub\n\n'Sub rotate (xx, yy, x, y, pn, rot)\n'    Select Case pn\n'        Case 0\n'            rot_new = 0\n'        Case 1 TO 3\n'            rot_new = rot Mod 2\n'        Case 4 TO 6\n'            rot_new = rot\n'    End Select\n\n'    Select Case rot_new\n'        Case 0\n'            xx = x\n'            yy = y\n'        Case 1\n'            xx = y + 2\n'            yy = 2 - x\n'        Case 2\n'            xx = 4 - x\n'            yy = 1 - y\n'        Case 3\n'            xx = 2 - y\n'            yy = x - 1\n'    End Select\n'End Sub\n\nFunction valid (pn, px, py, rot)\n    Dim As Double x, y\n    Dim res As RotResult\n    For y = 0 To 1\n        For x = 0 To 3\n            rotate res, x, y, pn, rot\n            If py + res.yy >= 0 Then\n                If piece(pn, x, y) Then\n                    If (px + res.xx >= sw) Or (px + res.xx < 0) Then\n                        valid = 0\n                        Exit Function\n                    End If\n                    If (py + res.yy >= sh) Then\n                        valid = 0\n                        Exit Function\n                    End If\n                    If (py >= 0) Then\n                        If board(px + res.xx, py + res.yy) Then\n                            valid = 0\n                            Exit Function\n                        End If\n                    End If\n                End If\n            End If\n        Next\n    Next\n\n    valid = -1\nEnd Function\n\nFunction place (pn, px, py, rot)\n    Dim As Double lines, x, y\n    Dim As RotResult res\n    lines = 0\n\n    For y = 0 To 1\n        For x = 0 To 3\n            rotate res, x, y, pn, rot\n            If py + res.yy >= 0 Then\n                If piece(pn, x, y) Then board(px + res.xx, py + res.yy) = pn + 1\n            End If\n        Next\n    Next\n\n    'clear lines\n    Dim clr As Double\n    For y = py - 1 To py + 2\n        If y >= 0 And y < sh Then\n            clr = -1\n            For x = 0 To sw - 1\n                If board(x, y) = 0 Then\n                    clr = 0\n                    Exit For\n                End If\n            Next\n\n            If clr Then\n                lines = lines + 1\n                For res.yy = y To 1 Step -1\n                    For x = 0 To sw - 1\n                        board(x, res.yy) = board(x, res.yy - 1)\n                    Next\n                Next\n            End If\n        End If\n    Next\n\n    place = lines\nEnd Function\n"
  },
  {
    "input": "For when you think Tetris is too easy",
    "output": "randomize timer\n\ndim shared piece(17, 2, 4)\ndim shared piece_color(17)\ndim shared size, sw, sh\n\n'big x and y\ndim shared xx, yy\n\nsize = 25\nsw = 12\nsh = 25\n\nredim shared board(sw - 1, sh - 1)\n\npiece(0,0,0)=0: piece(0,1,0)=1: piece(0,2,0)=0\npiece(0,0,1)=0: piece(0,1,1)=1: piece(0,2,1)=0\npiece(0,0,2)=0: piece(0,1,2)=1: piece(0,2,2)=0\npiece(0,0,3)=0: piece(0,1,3)=1: piece(0,2,3)=0\npiece(0,0,4)=0: piece(0,1,4)=1: piece(0,2,4)=0\n\npiece(1,0,0)=0: piece(1,1,0)=0: piece(1,2,0)=0\npiece(1,0,1)=0: piece(1,1,1)=0: piece(1,2,1)=0\npiece(1,0,2)=0: piece(1,1,2)=1: piece(1,2,2)=1\npiece(1,0,3)=1: piece(1,1,3)=1: piece(1,2,3)=0\npiece(1,0,4)=0: piece(1,1,4)=1: piece(1,2,4)=0\n\npiece(2,0,0)=0: piece(2,1,0)=0: piece(2,2,0)=0\npiece(2,0,1)=0: piece(2,1,1)=0: piece(2,2,1)=0\npiece(2,0,2)=1: piece(2,1,2)=1: piece(2,2,2)=0\npiece(2,0,3)=0: piece(2,1,3)=1: piece(2,2,3)=1\npiece(2,0,4)=0: piece(2,1,4)=1: piece(2,2,4)=0\n\npiece(3,0,0)=0: piece(3,1,0)=0: piece(3,2,0)=0\npiece(3,0,1)=0: piece(3,1,1)=1: piece(3,2,1)=0\npiece(3,0,2)=0: piece(3,1,2)=1: piece(3,2,2)=0\npiece(3,0,3)=0: piece(3,1,3)=1: piece(3,2,3)=0\npiece(3,0,4)=1: piece(3,1,4)=1: piece(3,2,4)=0\n\npiece(4,0,0)=0: piece(4,1,0)=0: piece(4,2,0)=0\npiece(4,0,1)=0: piece(4,1,1)=1: piece(4,2,1)=0\npiece(4,0,2)=0: piece(4,1,2)=1: piece(4,2,2)=0\npiece(4,0,3)=0: piece(4,1,3)=1: piece(4,2,3)=0\npiece(4,0,4)=0: piece(4,1,4)=1: piece(4,2,4)=1\n\npiece(5,0,0)=0: piece(5,1,0)=0: piece(5,2,0)=0\npiece(5,0,1)=0: piece(5,1,1)=0: piece(5,2,1)=0\npiece(5,0,2)=1: piece(5,1,2)=1: piece(5,2,2)=0\npiece(5,0,3)=1: piece(5,1,3)=1: piece(5,2,3)=0\npiece(5,0,4)=0: piece(5,1,4)=1: piece(5,2,4)=0\n\npiece(6,0,0)=0: piece(6,1,0)=0: piece(6,2,0)=0\npiece(6,0,1)=0: piece(6,1,1)=0: piece(6,2,1)=0\npiece(6,0,2)=0: piece(6,1,2)=1: piece(6,2,2)=1\npiece(6,0,3)=0: piece(6,1,3)=1: piece(6,2,3)=1\npiece(6,0,4)=0: piece(6,1,4)=1: piece(6,2,4)=0\n\npiece(7,0,0)=0: piece(7,1,0)=0: piece(7,2,0)=0\npiece(7,0,1)=0: piece(7,1,1)=1: piece(7,2,1)=0\npiece(7,0,2)=0: piece(7,1,2)=1: piece(7,2,2)=0\npiece(7,0,3)=1: piece(7,1,3)=1: piece(7,2,3)=0\npiece(7,0,4)=1: piece(7,1,4)=0: piece(7,2,4)=0\n\npiece(8,0,0)=0: piece(8,1,0)=0: piece(8,2,0)=0\npiece(8,0,1)=0: piece(8,1,1)=1: piece(8,2,1)=0\npiece(8,0,2)=0: piece(8,1,2)=1: piece(8,2,2)=0\npiece(8,0,3)=0: piece(8,1,3)=1: piece(8,2,3)=1\npiece(8,0,4)=0: piece(8,1,4)=0: piece(8,2,4)=1\n\npiece(9,0,0)=0: piece(9,1,0)=0: piece(9,2,0)=0\npiece(9,0,1)=0: piece(9,1,1)=0: piece(9,2,1)=0\npiece(9,0,2)=1: piece(9,1,2)=1: piece(9,2,2)=1\npiece(9,0,3)=0: piece(9,1,3)=1: piece(9,2,3)=0\npiece(9,0,4)=0: piece(9,1,4)=1: piece(9,2,4)=0\n\npiece(10,0,0)=0: piece(10,1,0)=0: piece(10,2,0)=0\npiece(10,0,1)=0: piece(10,1,1)=0: piece(10,2,1)=0\npiece(10,0,2)=0: piece(10,1,2)=0: piece(10,2,2)=0\npiece(10,0,3)=1: piece(10,1,3)=0: piece(10,2,3)=1\npiece(10,0,4)=1: piece(10,1,4)=1: piece(10,2,4)=1\n\npiece(11,0,0)=0: piece(11,1,0)=0: piece(11,2,0)=0\npiece(11,0,1)=0: piece(11,1,1)=0: piece(11,2,1)=0\npiece(11,0,2)=0: piece(11,1,2)=0: piece(11,2,2)=1\npiece(11,0,3)=0: piece(11,1,3)=0: piece(11,2,3)=1\npiece(11,0,4)=1: piece(11,1,4)=1: piece(11,2,4)=1\n\npiece(12,0,0)=0: piece(12,1,0)=0: piece(12,2,0)=0\npiece(12,0,1)=0: piece(12,1,1)=0: piece(12,2,1)=0\npiece(12,0,2)=0: piece(12,1,2)=0: piece(12,2,2)=1\npiece(12,0,3)=0: piece(12,1,3)=1: piece(12,2,3)=1\npiece(12,0,4)=1: piece(12,1,4)=1: piece(12,2,4)=0\n\npiece(13,0,0)=0: piece(13,1,0)=0: piece(13,2,0)=0\npiece(13,0,1)=0: piece(13,1,1)=0: piece(13,2,1)=0\npiece(13,0,2)=0: piece(13,1,2)=1: piece(13,2,2)=0\npiece(13,0,3)=1: piece(13,1,3)=1: piece(13,2,3)=1\npiece(13,0,4)=0: piece(13,1,4)=1: piece(13,2,4)=0\n\npiece(14,0,0)=0: piece(14,1,0)=0: piece(14,2,0)=0\npiece(14,0,1)=0: piece(14,1,1)=1: piece(14,2,1)=0\npiece(14,0,2)=1: piece(14,1,2)=1: piece(14,2,2)=0\npiece(14,0,3)=0: piece(14,1,3)=1: piece(14,2,3)=0\npiece(14,0,4)=0: piece(14,1,4)=1: piece(14,2,4)=0\n\npiece(15,0,0)=0: piece(15,1,0)=0: piece(15,2,0)=0\npiece(15,0,1)=0: piece(15,1,1)=1: piece(15,2,1)=0\npiece(15,0,2)=0: piece(15,1,2)=1: piece(15,2,2)=1\npiece(15,0,3)=0: piece(15,1,3)=1: piece(15,2,3)=0\npiece(15,0,4)=0: piece(15,1,4)=1: piece(15,2,4)=0\n\npiece(16,0,0)=0: piece(16,1,0)=0: piece(16,2,0)=0\npiece(16,0,1)=0: piece(16,1,1)=0: piece(16,2,1)=0\npiece(16,0,2)=0: piece(16,1,2)=1: piece(16,2,2)=1\npiece(16,0,3)=0: piece(16,1,3)=1: piece(16,2,3)=0\npiece(16,0,4)=1: piece(16,1,4)=1: piece(16,2,4)=0\n\npiece(17,0,0)=0: piece(17,1,0)=0: piece(17,2,0)=0\npiece(17,0,1)=0: piece(17,1,1)=0: piece(17,2,1)=0\npiece(17,0,2)=1: piece(17,1,2)=1: piece(17,2,2)=0\npiece(17,0,3)=0: piece(17,1,3)=1: piece(17,2,3)=0\npiece(17,0,4)=0: piece(17,1,4)=1: piece(17,2,4)=1\n\nscreen _newimage(sw*size, sh*size, 32)\n\npiece_color(0) = _rgb(255,0,0)\npiece_color(1) = _rgb(255,145,0)\npiece_color(2) = _rgb(255,200,211)\npiece_color(3) = _rgb(0,255,220)\npiece_color(4) = _rgb(0,230,255)\npiece_color(5) = _rgb(0,170,10)\npiece_color(6) = _rgb(0,250,20)\npiece_color(7) = _rgb(128,230,0)\npiece_color(8) = _rgb(80,150,0)\npiece_color(9) = _rgb(0,200,0)\npiece_color(10) = _rgb(50,160,170)\npiece_color(11) = _rgb(50,110,175)\npiece_color(12) = _rgb(50,50,175)\npiece_color(13) = _rgb(110,50,175)\npiece_color(14) = _rgb(210,0,255)\npiece_color(15) = _rgb(110,0,130)\npiece_color(16) = _rgb(255,0,140)\npiece_color(17) = _rgb(170,0,100)\n\ndim t as double\n \n\nredraw = -1\n\nspeed = 3\nlines = 0\npause = 0\nputpiece = 0\nstartx = (sw - 4)/2\n\npn = int(rnd*18)\npx = startx\npy = -2\nrot = 0\n\ndim title$\ntitle$ = \"lines=\"+ltrim$(str$(lines))+\",speed=\"++ltrim$(str$(speed))\n_title title$\n\nt = timer\n\n\ndim mb_state, ox, oy\nmb_state = 0\nox = 0\noy = 0\n\n\ndo\n    if _resize then\n        size = (_resizeheight - 20)/sh\n        screen _newimage(sw*size, sh*size, 32)\n        redraw = -1\n    end if\n\n\n    if (timer - t) > (1/speed) and not pause then\n        if valid(pn, px, py + 1, rot) then py = py + 1 else putpiece = 1\n\n        t = timer\n        redraw = -1\n    end if\n\n    if putpiece then\n        if valid(pn, px, py, rot) then\n            n = place(pn, px, py, rot)\n            if n then\n                lines = lines + n\n                title$ = \"lines=\"+ltrim$(str$(lines))+\",speed=\"++ltrim$(str$(speed))\n                _title title$\n            end if\n        end if\n\n        pn = int(rnd*18)\n        px = startx\n        py = -2\n        rot = 0\n\n        putpiece = 0\n        redraw = -1\n\n        if not valid(pn, px, py, rot) then\n            for y=0 to sh-1\n                for x=0 to sw-1\n                    board(x, y) = 0\n                next\n            next\n            lines = 0\n            title$ = \"lines=\"+ltrim$(str$(lines))+\",speed=\"++ltrim$(str$(speed))\n            _title title$\n        end if\n    end if\n\n    if redraw then\n        line (0,0)-(sw*size, sh*size),_rgb(0,0,0),bf\n        for y=0 to sh - 1\n            for x=0 to sw - 1\n                if board(x, y) <> 0 then\n                    line (x*size, y*size)-step(size-2, size-2), piece_color(board(x, y)-1), bf\n                else\n                    line (x*size, y*size)-step(size-2, size-2), _rgb(50,50,50), b\n                end if\n            next\n        next\n\n        for y=0 to 4\n            for x=0 to 2\n                rotate x, y, pn, rot\n                if piece(pn, x, y) then line ((px + xx)*size, (py + yy)*size)-step(size-2, size-2), piece_color(pn), bf\n            next\n        next\n\n\n        locate 1,1\n        color _rgb(88,88,88)\n        print title$\n\n        _display\n        redraw = 0\n    end if\n\n    'mouse state\n    k = _keyhit 'override keyboard\n    shift = _keydown(100304) or _keydown(100303)\n\n    mx = _mousex\n    my = _mousey\n    mb = _mousebutton(1)\n    if mb and mb_state = 0 then\n        mb_state = -1\n        ox = mx\n        oy = my\n    end if\n    if mb and mb_state then\n        a = atan2(my - oy, mx - ox) \n        r = sw*size/4\n        dist = sqr((my - oy)^2 + (mx - ox)^2)\n\n        circle (sw*size/2, sh*size/2), r, rgb(255,255,0)\n        'if dist > 2.5*r then\n        '    line -step(r*cos(a), r*sin(a)), rgb(255,0,0)\n        if dist > r/2 then\n\n            aa = a\n            if a >= -pi/4 and a < pi/4 then aa = 0\n            if a >= -pi and a < -3*pi/4 then aa = pi\n            if a <= pi and a > 3*pi/4 then aa = pi\n            if a >= -3*pi/4 and a < -pi/4 then aa = -pi/2\n            if a <= 3*pi/4 and a >= pi/4 then aa = pi/2\n\n            if dist > r*2 then c = rgb(255,0,0) else c = rgb(255,255,0)\n\n            line -step(r*cos(aa), r*sin(aa)), c\n        end if\n    end if\n    if mb = 0 and mb_state then\n        if a >= -pi/4 and a < pi/4 then k = 19712 'right\n        if a >= -pi and a < -3*pi/4 then k = 19200 'left\n        if a <= pi and a > 3*pi/4 then k = 19200 'left\n        if a >= -3*pi/4 and a < -pi/4 then k = 18432 'up\n        if a <= 3*pi/4 and a >= pi/4 then k = 20480 'down\n\n        if dist > r*2 then shift = -1 else shift = 0\n\n        mb_state = 0\n        redraw = -1\n    end if\n    '''\n\n    'keyboard\n    'k = _keyhit\n    if k then \n        'shift = _keydown(100304) or _keydown(100303)\n        select case k\n        case 18432 'up\n            if valid(pn, px, py, (rot + 1) mod 4) then rot = (rot + 1) mod 4\n            pause = 0\n        case 19200 'left\n            if shift then\n                for x2=0 to sw-1\n                    if not valid(pn, px - x2, py, rot) then exit for\n                next\n                px = px - x2 + 1\n            else\n                if valid(pn, px - 1, py, rot) then px = px - 1\n            end if\n            pause = 0\n        case 19712 'right\n            if shift then\n                for x2=px to sw-1\n                    if not valid(pn, x2, py, rot) then exit for\n                next\n                px = x2 - 1\n            else \n                if valid(pn, px + 1, py, rot) then px = px + 1\n            end if\n            pause = 0\n        case 20480, 32 'down\n            if shift or k = 32 then\n                for y2=py to sh-1\n                    if not valid(pn, px, y2, rot) then exit for\n                next\n                py = y2 - 1\n                putpiece = -1\n            else\n                if valid(pn, px, py + 1, rot) then py = py + 1\n            end if\n            pause = 0\n        case 112 'p\n            pause = not pause\n        case 13 'enter\n            for y=0 to sh-1\n                for x=0 to sw-1\n                    board(x, y) = 0\n                next\n            next\n            pn = int(rnd*18)\n            px = startx\n            py = -2\n            rot = 0\n            putpiece = 0\n            lines = 0\n            title$ = \"lines=\"+ltrim$(str$(lines))+\",speed=\"++ltrim$(str$(speed))\n            _title title$\n        case 43, 61 'plus\n            if speed < 100 then\n                speed = speed + 1\n                title$ = \"lines=\"+ltrim$(str$(lines))+\",speed=\"++ltrim$(str$(speed))\n                _title title$\n            end if\n        case 95, 45\n            if speed > 1 then\n                speed = speed - 1\n                title$ = \"lines=\"+ltrim$(str$(lines))+\",speed=\"++ltrim$(str$(speed))\n                _title title$\n            end if\n        case 27\n            exit do\n        end select\n\n        redraw = -1\n    end if\n    \n    _limit 60\nloop\nsystem\n\nsub rotate(x, y, pn, rot)\n    select case pn\n    case 0\n        rot_new = rot mod 2\n    case else \n        rot_new = rot\n    end select\n\n    select case rot_new\n    case 0\n        xx = x\n        yy = y\n    case 1\n        if pn = 0 then\n            xx = y - 1\n            yy = 3 - x\n        elseif pn = 14 or pn = 15 then\n            xx = y - 1\n            yy = 3 - x\n        else\n            xx = y - 2\n            yy = 4 - x\n        end if\n    case 2\n        if pn = 14 or pn = 15 then\n            xx = 2 - x\n            yy = 4 - y\n        else\n            xx = 2 - x\n            yy = 6 - y\n        end if\n    case 3\n        if pn = 14 or pn = 15 then\n            xx = 3 - y\n            yy = x + 1\n        else\n            xx = 4 - y\n            yy = x + 2\n        end if\n    end select\nend sub\n\nfunction valid(pn, px, py, rot)\n    for y=0 to 4\n        for x=0 to 2\n            rotate x, y, pn, rot\n            if py + yy >= 0 then\n                if piece(pn, x, y) then\n                    if (px + xx >= sw) or (px + xx < 0) then\n                        valid = 0\n                        exit function\n                    end if\n                    if (py + yy >= sh) then\n                        valid = 0\n                        exit function\n                    end if\n                    'if (py >= 0) then\n                    if board(px + xx, py + yy) then\n                        valid = 0\n                        exit function\n                    end if\n                    'end if\n                end if\n            end if\n        next\n    next\n    valid = -1\nend function\n\nfunction place(pn, px, py, rot)\n    lines2 = 0\n\n    for y=0 to 4\n        for x=0 to 2\n            rotate x, y, pn, rot\n            if py + yy >= 0 then\n                if piece(pn, x, y) then board(px + xx, py + yy) = pn + 1\n            end if\n        next\n    next\n\n    'clear lines\n    for y=py-5 to py+5\n        if y>=0 and y<sh then\n            clr = -1\n            for x=0 to sw - 1\n                if board(x, y) = 0 then\n                    clr = 0\n                    exit for\n                end if\n            next\n\n            if clr then\n                lines2 = lines2 + 1\n                for y2=y to 1 step -1\n                    for x=0 to sw-1\n                        board(x, y2) = board(x, y2-1)\n                    next\n                next\n            end if\n        end if\n    next\n\n    place = lines2\nend function\n"
  },
  {
    "input": "Basic calculator using native web controls",
    "output": "Import Dom From \"lib/web/dom.bas\"\n\nConst False = 0\nConst True = Not False\n\nDim Shared currentOp As String\nDim Shared lastNum As Double\nDim Shared opLabel As Object\nDim Shared btnPanel As Object\nDim Shared output As Object\nDim Shared newNum As Integer\n\n_Title \"Simple Web Calculator\"\n\nInitUI\n\n\nSub DoMath (n1, op, n2)\n    Dim result As Double\n    \n    If op = \"+\" Then\n        result = n1 + n2\n        \n    ElseIf op = \"-\" Then\n        result = n1 - n2\n        \n    ElseIf op = \"*\" Then\n        result = n1 * n2\n    \n    ElseIf op = \"/\" Then\n        result = n1 / n2\n    End If\n    \n    SetOutput result\nEnd Sub\n\n' Event handling methods\n\nSub OnOperation (event)\n    If currentOp <> \"\" Then\n        DoMath lastNum, currentOp, GetOutput * 1\n    End If\n\n    Dim op As String\n    op = event.target.val\n    \n    If op = \"=\" Then\n        lastNum = \"\"\n        SetOp \"\"\n    Else\n        lastNum = GetOutput * 1\n        SetOp op\n    End If\n    newNum = True\nEnd Sub\n\nSub OnNumber (event)\n    Dim num As String\n    num = event.target.val\n    If GetOutput = \"0\" Or newNum Then\n        SetOutput num\n        newNum = False\n    Else\n        SetOutput GetOutput + num\n    End If\nEnd Sub\n\nSub OnPeriod\n    Dim ostr As String\n    ostr = GetOutput\n    \n    If newNum Then\n        SetOutput \"0.\"\n        newNum = False\n        Exit Sub\n    End If\n    \n    If InStr(ostr, \".\") Then Exit Sub\n    \n    SetOutput ostr + \".\"\nEnd Sub\n\nSub OnNegate\n    Dim ostr As String\n    ostr = GetOutput\n    If ostr = \"0\" Then Exit Sub\n    \n    If InStr(ostr, \"-\") Then\n        SetOutput Right(ostr, Len(ostr)-2)\n    Else\n        SetOutput \"-\" + ostr\n    End If\nEnd Sub\n\nSub OnClear\n    SetOutput \"0\"\n    SetOp \"\"\n    newNum = True\nEnd Sub\n\nSub OnBackspace\n    If GetOutput = \"0\" Or newNum Then Exit Sub\n    \n    Dim numstr As String\n    Dim l As Integer\n    numstr = GetOutput\n    l = Len(numstr)\n    If l < 2 Then\n        SetOutput \"0\"\n    Else\n        SetOutput Left$(numstr, l-1)\n    End If\nEnd Sub\n\nSub OnBlank\n    If Dom.Confirm(\"I had room for an extra button!\" + Chr$(10) + \"Want to change the background color?\") Then\n        Dim As Integer r, g, b\n        r = Fix(Rnd * 255)\n        g = Fix(Rnd * 255)\n        b = Fix(Rnd * 255)\n        Dom.Container().style.backgroundColor = \"#\" + Hex$(r) + Hex$(g) + Hex$(b)\n    End If\nEnd Sub\n\n' UI Helper methods\n\nFunction GetOutput\n    GetOutput = output.innerText\nEnd Function\n\nSub SetOutput (value As String)\n    output.innerHTML = value\nEnd Sub\n\nSub SetOp (op As String)\n    If op = \"\" Then\n        opLabel.innerHTML = \"&nbsp;\"\n        currentOp = \"\"\n    Else\n        opLabel.innerHTML = lastNum + \" \" + op\n        currentOp = op\n    End If\nEnd Sub\n\n\nSub InitUI\n    'Hide the screen output\n    Dim mainScreen As Object\n    mainScreen = Dom.GetImage(0)\n    mainScreen.style.display = \"none\"\n\n    ' Style the page container\n    Dim container As Object\n    container = Dom.Container\n    container.style.backgroundColor = \"#ccc\"\n\n    Dim panel As Object\n    panel = Dom.Create(\"div\")\n    panel.style.margin = \"auto\"\n    panel.style.width = \"500px\"\n    panel.style.border = \"1px solid #999\"\n    panel.style.backgroundColor = \"#ddd\"\n\n    ' create the current operation label\n    opLabel = Dom.Create(\"div\", panel)\n    opLabel.style.textAlign = \"right\"\n    opLabel.style.padding = \"10px 20px 0px 0px\"\n    opLabel.innerHTML = \"&nbsp;\"\n\n    ' create the output display\n    output = Dom.Create(\"div\", panel)\n    output.style.padding = \"0px 20px 20px 20px\"\n    output.style.textAlign = \"right\"\n    output.style.fontSize = \"50px\"\n    output.style.color = \"#000\"\n    output.style.overflow = \"auto\"\n    output.innerHTML = \"0\"\n\n    ' create the button grid\n    btnPanel = Dom.Create(\"div\", panel)\n    btnPanel.style.display = \"grid\"\n    btnPanel.style.gridTemplateColumns = \"auto auto auto auto\"\n\n    Dim btn As Object\n    btn = CreateButton(\"C\", @OnClear)\n    btn = CreateButton(\"<\", @OnBackspace)\n    btn = CreateButton(\"\",  @OnBlank)\n    btn = CreateButton(\"/\", @OnOperation)\n    btn = CreateButton(\"9\", @OnNumber)\n    btn = CreateButton(\"8\", @OnNumber)\n    btn = CreateButton(\"7\", @OnNumber)\n    btn = CreateButton(\"*\", @OnOperation)\n    btn = CreateButton(\"6\", @OnNumber)\n    btn = CreateButton(\"5\", @OnNumber)\n    btn = CreateButton(\"4\", @OnNumber)\n    btn = CreateButton(\"-\", @OnOperation)\n    btn = CreateButton(\"3\", @OnNumber)\n    btn = CreateButton(\"2\", @OnNumber)\n    btn = CreateButton(\"1\", @OnNumber)\n    btn = CreateButton(\"+\", @OnOperation)\n    btn = CreateButton(\"+/-\", @OnNegate)\n    btn = CreateButton(\"0\", @OnNumber)\n    btn = CreateButton(\".\", @OnPeriod)\n    btn = CreateButton(\"=\", @OnOperation)\n    \n    OnClear\nEnd Sub\n\nFunction CreateButton (label, callback As Sub)\n    Dim btn As Object\n    btn = Dom.Create(\"button\" , btnPanel)\n    btn.innerText = label\n    btn.style.padding = \"20px\"\n    btn.style.textAlign = \"center\"\n    btn.style.fontSize = \"20px\"\n    btn.style.margin = \"1px\"\n    btn.val = label\n    Dom.Event btn, \"click\", callback\n    CreateButton = btn\nEnd Function"
  },
  {
    "input": "Falling Circles Game",
    "output": "    Dim buzz, music, lose\n    music = _SndOpen(\"https://opengameart.org/sites/default/files/newbattle.wav\")\n    buzz = _SndOpen(\"https://opengameart.org/sites/default/files/buzz_0.ogg\")\n    lose = _SndOpen(\"https://opengameart.org/sites/default/files/lose%20music%201%20-%201_0.wav\")\n    _SndLoop music\n    Dim As Long HX, HY, i, hits, score, Stars, nEnemies, Height\n    HX = 320: HY = 400: nStars = 1000: nEnemies = 50: Height = 480\n    Dim EX(nEnemies), EY(nEnemies), EC(nEnemies) As _Unsigned Long ' enemy stuff\n    Screen _NewImage(640, Height, 32)\n    Stars = _NewImage(640, Height, 32)\n    For i = 1 To nStars\n        PSet (Int(Rnd * 640), Int(Rnd * 480)), _RGB32(55 + Rnd * 200, 55 + Rnd * 200, 55 + Rnd * 200)\n    Next\n    _PutImage , 0, Stars\n    For i = 1 To nEnemies\n        EX(i) = Int(Rnd * 600 + 20): EY(i) = -2 * Height * Rnd + Height: EC(i) = _RGB32(55 + Rnd * 200, 55 + Rnd * 200, 55 + Rnd * 200)\n    Next\n    Do\n        Cls\n        _PutImage , Stars, 0\n        Print \"Hits:\"; hits, \"Score:\"; score\n        Line (HX - 10, HY - 10)-Step(20, 20), _RGB32(255, 255, 0), BF\n        For i = 1 To nEnemies ' the enemies\n            Circle (EX(i), EY(i)), 10, EC(i)\n            If Sqr((EX(i) - HX) ^ 2 + (EY(i) - HY) ^ 2) < 20 Then 'collision\n                _SndPause music\n                _SndPlay buzz\n                _Delay .5\n                hits = hits + 1\n                EX(i) = Int(Rnd * 600 + 20): EY(i) = -Height * Rnd ' move that bad boy!\n                If hits = 10 Then\n                    Print \"Too many hits, goodbye!\"\n                    _SndPlay lose\n                    FadeOut\n                    End\n                End If\n                _SndLoop music\n            End If\n            EY(i) = EY(i) + Int(Rnd * 5)\n            If EY(i) > 470 Then EX(i) = Int(Rnd * 600 + 20): EY(i) = -Height * Rnd: score = score + 1\n        Next\n        If _KeyDown(20480) Then HY = HY + 3\n        If _KeyDown(18432) Then HY = HY - 3\n        If _KeyDown(19200) Then HX = HX - 3\n        If _KeyDown(19712) Then HX = HX + 3\n        If HX < 10 Then HX = 10\n        If HX > 630 Then HX = 630\n        If HY < 10 Then HY = 10\n        If HY > 470 Then HY = 470\n        _Display\n        _Limit 100\n    Loop Until _KeyDown(27): Sleep\n    _SndStop music\n                               \n    Sub FadeOut\n        _Delay 2\n        Dim i\n        For i = 1 to 100\n            Line (0, 0)-(_Width, _Height), _RGBA(1, 1, 1, 5), BF\n            _Limit 30\n        Next i\n        Locate 16, 35\n        Print \"Game Over\"\n    End Sub\n     "
  },
  {
    "input": "Mobile-friendly, simple drawing application.",
    "output": "Import Dom From \"lib/web/dom.bas\"\nImport Gfx From \"lib/graphics/2d.bas\"\nImport Stx From \"lib/lang/string.bas\"\nImport FS From \"lib/io/fs.bas\"\nOption Explicit\n\nDim Shared As Object selTool, cp, btnUndo, btnSave, chkFilled, chkRounded\nDim Shared As Object grpFilled, grpRounded, grpRadius, grpLineWidth, grpLineStyle, grpColor\nDim Shared As Object txtRadius, txtLineWidth, selLineStyle\nCreateToolbar\n\nDim Shared fimage, cimage\nfimage = _NewImage(_Width, _Height, 32)\ncimage = _NewImage(_Width, _Height, 32)\n\nDim drawing, lastX, lastY, startX, startY, radius\nDo\n    If _Resize Then\n        Dim tmp \n        tmp = fimage\n        Screen _NewImage(_ResizeWidth - 2, _ResizeHeight - 42)\n        fimage = _NewImage(_ResizeWidth - 2, _ResizeHeight - 42)\n        _PutImage (0, 0), tmp, fimage\n    End If\n\n    If _MouseButton(1) Then\n        If Not drawing Then\n            _PutImage (0, 0), cimage, fimage\n            _FreeImage cimage\n            cimage = _NewImage(_Width, _Height)\n            lastX = _MouseX\n            lastY = _MouseY\n            startX = lastX\n            startY = lastY\n            drawing = -1\n            btnUndo.disabled = false\n            btnSave.disabled = false\n        Else\n            Gfx.LineWidth txtLineWidth.value\n            If selTool.value = \"Freehand\" Then\n                _Dest cimage\n                Gfx.LineCap Gfx.ROUND\n                Gfx.LineDashOff\n                Line (lastX, lastY)-(_MouseX, _MouseY), SelectedColor\n                lastX = _MouseX\n                lastY = _MouseY\n                _Dest 0\n                \n            ElseIf selTool.value = \"Line\" Then\n                PrepDrawDest\n                Line (startX, startY)-(_MouseX, _MouseY), SelectedColor\n                _Dest 0\n\n            ElseIf selTool.value = \"Rectangle\" Then\n                PrepDrawDest\n                If chkRounded.checked Then\n                    If chkFilled.checked Then\n                        Gfx.FillRoundRect startX, startY, _MouseX-startX, _MouseY-startY, txtRadius.value, SelectedColor\n                    Else\n                        Gfx.RoundRect startX, startY, _MouseX-startX, _MouseY-startY, txtRadius.value, SelectedColor\n                    End If\n                Else\n                    If chkFilled.checked Then\n                        Line (startX, startY)-(_MouseX, _MouseY), SelectedColor, BF\n                    Else\n                        Line (startX, startY)-(_MouseX, _MouseY), SelectedColor, B\n                    End If\n                End If\n                _Dest 0\n\n            ElseIf selTool.value = \"Invert Rectangle\" Then\n                PrepDrawDest\n                _PutImage , fimage, cimage\n                Gfx.InvertRect startX, startY, _MouseX-startX, _MouseY-startY, chkFilled.checked\n                _Dest 0\n            \n            ElseIf selTool.value = \"Circle\" Then\n                PrepDrawDest\n                If Abs(_MouseX - startX) > Abs(_MouseY - startY) Then\n                    radius = Abs(_MouseX - startX)\n                Else\n                    radius = Abs(_MouseY - startY)\n                End If\n                If chkFilled.checked Then\n                    Gfx.FillCircle startX, startY, radius, SelectedColor\n                Else\n                    Circle (startX, startY), radius, SelectedColor\n                End If\n                _Dest 0\n\n            ElseIf selTool.value = \"Ellipse\" Then\n                Dim xradius, yradius\n                PrepDrawDest\n                xradius = Abs(_MouseX - startX)\n                yradius = Abs(_MouseY - startY)\n                If chkFilled.checked Then\n                    Gfx.FillEllipse startX, startY, xradius, yradius, 1, SelectedColor\n                Else\n                    Gfx.Ellipse startX, startY, xradius, yradius, 1, SelectedColor\n                End If\n                _Dest 0\n            End If\n        End If\n    Else \n        drawing = 0\n    End If\n    Cls\n    _PutImage (0, 0), fimage\n    _PutImage (0, 0), cimage\n    _Limit 30\nLoop  \n\nSub PrepDrawDest\n    _FreeImage cimage\n    cimage = _NewImage(_Width, _Height, 32)\n    _Dest cimage\n    Gfx.LineCap Gfx.DEFAULT\n    SetLineStyle\nEnd Sub\n\nSub SetLineStyle\n    Dim w As Integer\n    If selLineStyle.value = \"Solid\" Then\n        Gfx.LineDashOff\n    ElseIf selLineStyle.value = \"Dotted\" Then\n        w = txtLineWidth.value\n        Gfx.LineDash w, w\n    ElseIf selLineStyle.value = \"Dashed\" Then\n        w = txtLineWidth.value * 4\n        Gfx.LineDash w, w\n    End If\nEnd Sub\n\nSub OnUndo\n    _FreeImage cimage\n    cimage = _NewImage(640, 400, 32)\n    btnUndo.disabled = true\nEnd Sub\n\nSub OnToolChange\n    If selTool.value = \"Circle\" Or selTool.value = \"Ellipse\" Or _\n       selTool.value = \"Rectangle\" Or selTool.value = \"Invert Rectangle\" Then\n        grpFilled.style.display = \"inline-block\"\n        If chkFilled.checked Then\n            grpLineWidth.style.display = \"none\"\n            grpLineStyle.style.display = \"none\"\n        Else\n            grpLineWidth.style.display = \"inline-block\"\n            grpLineStyle.style.display = \"inline-block\"\n        End If\n    Else\n        grpFilled.style.display = \"none\"\n        chkFilled.checked = false\n    End If\n    If selTool.value = \"Rectangle\" Then\n        grpRounded.style.display = \"inline-block\"\n        If chkRounded.checked Then\n            grpRadius.style.display = \"inline-block\"\n        Else\n            grpRadius.style.display = \"none\"\n        End If\n    Else\n        grpRounded.style.display = \"none\"\n        chkRounded.checked = false\n    End If\n    If selTool.value = \"Freehand\" Then\n        grpLineWidth.style.display = \"inline-block\"\n        grpLineStyle.style.display = \"none\"\n    ElseIf selTool.value = \"Line\" Then\n        grpLineStyle.style.display = \"inline-block\"\n    End If\n \n    If selTool.value = \"Invert Rectangle\" Then\n        grpColor.style.display = \"none\"\n    Else\n        grpColor.style.display = \"inline-block\"\n    End If\nEnd Sub\n\nSub OnSave\n    Gfx.SaveImage 0, \"masterpiece.png\"\n    FS.DownloadFile \"masterpiece.png\"\nEnd Sub\n\nSub CreateToolbar\n    Dim As Object parent, panel, canvas\n    parent = Dom.Create(\"div\")\n    parent.style.display = \"grid\"\n    parent.style.gridTemplateColumns = \"1fr\"\n    parent.style.gridTemplateRows = \"auto 42px\"\n    \n    canvas = Dom.GetImage(0)\n    Dom.Add canvas, parent\n    canvas.style.cursor = \"crosshair\"\n    canvas.style.border = \"0\"\n    canvas.style.margin = \"0\"\n    \n    Dim grpTool As Object\n    panel = Dom.Create(\"div\", parent)\n    grpTool = CreateControlGroup(\"Tool\", panel)\n    grpTool.style.display = \"inline-block\"\n    selTool = Dom.Create(\"select\", grpTool)\n    selTool.style.verticalAlign = \"middle\"\n    InitList selTool, \"Freehand,Line,Rectangle,Invert Rectangle,Circle\"\n    Dom.Create \"option\", selTool, \"Ellipse\"\n    Dom.Event selTool, \"change\", @OnToolChange\n\n    ' Fill settings\n    grpFilled = CreateControlGroup(\"Filled\", panel)\n    chkFilled = Dom.Create(\"input\", grpFilled)\n    chkFilled.type = \"checkbox\"\n    Dom.Event chkFilled, \"change\", @OnToolChange\n\n    ' Rounded settings\n    grpRounded = CreateControlGroup(\"Rounded\", panel)\n    chkRounded = Dom.Create(\"input\", grpRounded)\n    chkRounded.type = \"checkbox\"\n    Dom.Event chkRounded, \"change\", @OnToolChange\n    grpRadius = CreateControlGroup(\"Radius\", grpRounded)\n    txtRadius = Dom.Create(\"input\", grpRadius, \"10\")\n    txtRadius.type = \"number\"\n    txtRadius.min = 1\n    txtRadius.max = 100\n    txtRadius.style.width = \"40px\"\n    txtRadius.style.height = \"20px\"\n\n    ' Line Width\n    grpLineWidth = CreateControlGroup(\"Line Width\", panel)\n    txtLineWidth = Dom.Create(\"input\", grpLineWidth, \"2\")\n    txtLineWidth.type = \"number\"\n    txtLineWidth.min = 1\n    txtLineWidth.max = 100\n    txtLineWidth.style.width = \"40px\"\n    txtLineWidth.style.height = \"20px\"\n    \n    'Line Style\n    grpLineStyle = CreateControlGroup(\"Style\", panel)\n    selLineStyle = Dom.Create(\"select\", grpLineStyle)\n    InitList selLineStyle, \"Solid,Dotted,Dashed\" \n\n    ' Color Picker\n    grpColor = CreateControlGroup(\"Color\", panel)\n    cp = Dom.Create(\"input\", grpColor)\n    cp.type = \"color\"\n    cp.value = \"#ffffff\"\n\n    ' Save Button\n    btnSave = Dom.Create(\"button\", panel, \"Save\")\n    btnSave.style.float = \"right\"\n    btnSave.style.padding = \"5px 10px\"\n    btnSave.style.marginLeft = \"5px\"\n    btnSave.disabled = true\n    Dom.Event btnSave, \"click\", @OnSave\n\n    ' Undo Button\n    btnUndo = Dom.Create(\"button\", panel, \"Undo\")\n    btnUndo.style.float = \"right\"\n    btnUndo.style.padding = \"5px 10px\"\n    btnUndo.disabled = true\n    Dom.Event btnUndo, \"click\", @OnUndo\n\n    panel.style.textAlign = \"left\"\n    panel.style.padding = \"5px\"\n    panel.style.borderTop = \"1px solid #666\"\n    panel.style.margin = \"0\"\n    panel.style.backgroundColor = \"#333\"\n    panel.style.verticalAlign = \"middle\"\n\n    'InitToolList\n    OnToolChange\nEnd Sub\n\nFunction CreateControlGroup(labelText As String, parent As Object)\n    Dim grp As Object\n    grp = Dom.Create(\"div\", parent)\n    grp.style.display = \"none\"\n    grp.style.marginRight = \"10px\"\n    grp.style.verticalAlign = \"middle\"\n    Dom.Create \"span\", grp, labelText + \": \"\n    CreateControlGroup = grp\nEnd Function\n\nSub InitList (sel As Object, options As String)\n    sel.style.padding = \"4px\"\n    ReDim opts(0) As String\n    Stx.Split options, \",\", opts\n    Dim i As Integer\n    For i = 1 To UBound(opts)\n        Dom.Create \"option\", sel, opts(i)\n    Next i\nEnd Sub\n\nFunction SelectedColor    \n    Dim r, g, b, c\n    c = cp.value\n\n    $If Javascript\n        r = parseInt(c.substr(1,2), 16)\n        g = parseInt(c.substr(3,2), 16)\n        b = parseInt(c.substr(5,2), 16)\n    $End If\n        \n    SelectedColor = _RGB(r, g, b)\nEnd Function"
  },
  {
    "input": "Tesseract",
    "output": "dim shared pi, p, q, d, z0, t, f, sw, sh\n\nsw = 800\nsh = 600\nd = 700\nz0 = 1500\npi = 4*atn(1)\n\n\ndim x(16), y(16), z(16), w(16)\nx(0)=0-1: y(0) =0-1: z(0) =0-1: w(0) = 0-1\nx(1)=  1: y(1) =0-1: z(1) =0-1: w(1) = 0-1\nx(2)=  1: y(2) =  1: z(2) =0-1: w(2) = 0-1\nx(3)=0-1: y(3) =  1: z(3) =0-1: w(3) = 0-1\n\nx(4)=0-1: y(4) =0-1: z(4) =1: w(4) = 0-1\nx(5)=  1: y(5) =0-1: z(5) =1: w(5) = 0-1\nx(6)=  1: y(6) =  1: z(6) =1: w(6) = 0-1\nx(7)=0-1: y(7) =  1: z(7) =1: w(7) = 0-1\n\nx( 8)=0-1: y( 8) =0-1: z( 8) =0-1: w( 8) = 1\nx( 9)=  1: y( 9) =0-1: z( 9) =0-1: w( 9) = 1\nx(10)=  1: y(10) =  1: z(10) =0-1: w(10) = 1\nx(11)=0-1: y(11) =  1: z(11) =0-1: w(11) = 1\n\nx(12)=0-1: y(12) =0-1: z(12) =1: w(12) = 1\nx(13)=  1: y(13) =0-1: z(13) =1: w(13) = 1\nx(14)=  1: y(14) =  1: z(14) =1: w(14) = 1\nx(15)=0-1: y(15) =  1: z(15) =1: w(15) = 1\n\n\nscreen _newimage(sw, sh)\n\ndo\nfor t = 0 to 8*pi step 0.01\n    cls \n\n    f=0\n    i = 0\n    proj x(i), y(i), z(i), w(i)\n    preset (p, q)\n    for i=1 to 3\n        proj x(i), y(i), z(i), w(i)\n        line -(p, q)\n    next\n    i = 0\n    proj x(i), y(i), z(i), w(i)\n    line -(p, q)\n\n    i = 4\n    proj x(i), y(i), z(i), w(i)\n    preset (p, q)\n    for i=4 to 7\n        proj x(i), y(i), z(i), w(i)\n        line -(p, q)\n    next\n    i = 4\n    proj x(i), y(i), z(i), w(i)\n    line -(p, q)\n\n    for i=0 to 3\n        proj x(i), y(i), z(i), w(i)\n        preset (p, q)\n        proj x(i+4), y(i+4), z(i+4), w(i+4)\n        line -(p, q)\n    next\n\n    f = 1\n    k = 8\n    i = 0+k\n    proj x(i), y(i), z(i), w(i)\n    preset (p, q), _rgb(255,0,0)\n    for i=1+k to 3+k\n        proj x(i), y(i), z(i), w(i)\n        line -(p, q), _rgb(255,0,0)\n    next\n    i = 0+k\n    proj x(i), y(i), z(i), w(i)\n    line -(p, q), _rgb(255,0,0)\n\n    i = 4+k\n    proj x(i), y(i), z(i), w(i)\n    preset (p, q), _rgb(255,0,0)\n    for i=4+k to 7+k\n        proj x(i), y(i), z(i), w(i)\n        line -(p, q), _rgb(255,0,0)\n    next\n    i = 4+k\n    proj x(i), y(i), z(i), w(i)\n    line -(p, q), _rgb(255,0,0)\n\n    for i=0+k to 3+k\n        proj x(i), y(i), z(i), w(i)\n        preset (p, q), _rgb(255,0,0)\n        proj x(i+4), y(i+4), z(i+4), w(i+4)\n        line -(p, q), _rgb(255,0,0)\n    next\n\n    for i=0 to 7\n        f = 0\n        proj x(i), y(i), z(i), w(i)\n        preset (p, q)\n        f = 1\n        proj x(i+k), y(i+k), z(i+k), w(i+k)\n        line -(p, q)\n    next\n     \n    _limit 50\nnext\nloop\n\nsub proj(x, y, z, w)\n    xx = x\n    yy = y*cos(t) - w*sin(t)\n    zz = z\n    ww = y*sin(t) + w*cos(t)\n\n    d2 = 3\n    w0 = 3\n    xx = xx*d2/(w0 + ww)\n    yy = yy*d2/(w0 + ww)\n    zz = zz*d2/(w0 + ww)\n    \n    xxx = xx*cos(t) - zz*sin(t)\n    zzz = xx*sin(t) + zz*cos(t)\n    xx = xxx\n    zz = zzz\n    \n    a = pi/3\n    b = pi/12\n    xxx = xx*cos(a) - yy*sin(a)\n    yyy = xx*sin(a) + yy*cos(a)\n    xx = xxx\n    yy = yyy\n\n    yyy = yy*cos(b) - zz*sin(b)\n    zzz = yy*sin(b) + zz*cos(b)\n    yy = yyy\n    zz = zzz\n    \n    xx = 100*xx\n    yy = 100*yy\n    zz = 100*zz\n\n    p = sw/2 + 2*xx*d/(yy + z0)\n    q = sh/2 - 2*zz*d/(yy + z0)\nend sub\n"
  },
  {
    "input": "4D Clifford Torus",
    "output": "\ndim shared pi, p, q, d, z0, t, f, sw, sh\n\nsw = 800\nsh = 600\nd = 700\nz0 = 1500\npi = 4*atn(1)\n\nscreen _newimage(sw, sh)\n\nsv = 2*pi/30\nsu = 2*pi/10\n\n'do\nfor t = 0 to 2*pi step 0.01\n    cls \n    u = 0\n    for v=0 to 2*pi+sv step sv\n        x = cos(u)\n        y = sin(u)\n        z = cos(v)\n        w = sin(v)\n        \n        proj x, y, z, w\n        preset (p, q)\n        \n        for u=0 to 2*pi+su step su\n            x = cos(u)\n            y = sin(u)\n            z = cos(v)\n            w = sin(v)\n        \n            proj x, y, z, w\n            line -(p, q)\n        next\n    next\n    \n    for u=0 to 2*pi+su step su\n        x = cos(u)\n        y = sin(u)\n        z = cos(v)\n        w = sin(v)\n        \n        proj x, y, z, w\n        preset (p, q), _rgb(255,0,0)\n        \n        for v=0 to 2*pi+sv step sv\n            x = cos(u)\n            y = sin(u)\n            z = cos(v)\n            w = sin(v)\n        \n            proj x, y, z, w\n            line -(p, q), _rgb(255,0,0)\n        next\n    next\n    \n\n    _limit 50\nnext\n'loop\n\nsub proj(x, y, z, w)\n    xx = x\n    yy = y*cos(t) - w*sin(t)\n    zz = z\n    ww = y*sin(t) + w*cos(t)\n\n    d2 = 3\n    w0 = 3\n    xx = xx*d2/(w0 + ww)\n    yy = yy*d2/(w0 + ww)\n    zz = zz*d2/(w0 + ww)\n    \n    xxx = xx*cos(t) - zz*sin(t)\n    zzz = xx*sin(t) + zz*cos(t)\n    xx = xxx\n    zz = zzz\n    \n    a = pi/12\n    b = pi/3\n    xxx = xx*cos(a) - yy*sin(a)\n    yyy = xx*sin(a) + yy*cos(a)\n    xx = xxx\n    yy = yyy\n\n    yyy = yy*cos(b) - zz*sin(b)\n    zzz = yy*sin(b) + zz*cos(b)\n    yy = yyy\n    zz = zzz\n    \n    xx = 200*xx\n    yy = 200*yy\n    zz = 200*zz\n\n    p = sw/2 + 2*xx*d/(yy + z0)\n    q = sh/2 - 2*zz*d/(yy + z0)\nend sub\n"
  },
  {
    "input": "This allows you to draw n-th order Bezier curves using QBJS's touchscreen support and will resize itself to fit any screen",
    "output": "Dim Shared As Single sw, sh\nsw = 800\nsh = 600\nDim Shared pi As Double\npi = 4 * Atn(1)\n\nScreen _NewImage(sw, sh, 32)\n   \nDim As Long n, r, mx, my, mb, omx, omy\nn = 0\nReDim x(n) As Long\nredim y(n) As Long\n\nDim As Double bx, by, t, bin\n\nr = 5\nDo\n    If _Resize Then\n        Dim tmp \n        tmp = _CopyImage(0)\n        Screen _NewImage(_ResizeWidth - 5, _ResizeHeight - 5)\n        _PutImage (0, 0), tmp\n        \n    End If\n\n\n    mx = _MouseX\n    my = _MouseY\n    mb = -_MouseButton(1)\n\n\n    If mb = 1 Then\n        n = 1\n        ReDim _Preserve As Long x(n)\n        ReDim _Preserve As Long y(n)\n\n        mx = _MouseX\n        my = _MouseY\n    \n        x(0) = mx - _Width / 2\n        y(0) = _Height / 2 - my\n\n        PSet (mx, my)\n        Do While mb = 1\n\n            mx = _MouseX\n            my = _MouseY\n            mb = -_MouseButton(1)\n\n\n            Line -(mx, my), _RGB(30, 30, 30)\n\n            If (mx - omx) ^ 2 + (my - omy) ^ 2 > r ^ 2 Then\n                circlef mx, my, 3, _RGB(30, 30, 30)\n                omx = mx\n                omy = my\n\n                x(n) = mx - _Width / 2\n                y(n) = _Height / 2 - my\n                n = n + 1\n                ReDim _Preserve As Long x(n)\n                ReDim _Preserve As Long y(n)\n            End If\n\n           \n            _Limit 50\n        Loop\n\n        'close the contour\n        'x(n) = x(0)\n        'y(n) = y(0)\n        'n = n + 1\n        'ReDim _Preserve x(n)\n        'ReDim _Preserve y(n)\n\n        'redraw spline\n        'pset (sw/2 + x(0), sh/2 - y(0))\n        'for i=0 to n\n        'line -(sw/2 + x(i), sh/2 - y(i)), _rgb(255,0,0)\n        'circlef sw/2 + x(i), sh/2 - y(i), 3, _rgb(255,0,0)\n        'next\n\n        PSet (_Width / 2 + x(0), _Height / 2 - y(0))\n        For t = 0 To 1 Step 0.001\n            bx = 0\n            by = 0\n\n            For i = 0 To n\n                bin = 1\n                For j = 1 To i\n                    bin = bin * (n - j) / j\n                Next\n\n                bx = bx + bin * ((1 - t) ^ (n - 1 - i)) * (t ^ i) * x(i)\n                by = by + bin * ((1 - t) ^ (n - 1 - i)) * (t ^ i) * y(i)\n            Next\n\n            Line -(_Width / 2 + bx, _Height / 2 - by), _RGB(255, 0, 0)\n        Next\n    End If\n\n    _Limit 50\nLoop 'until _keyhit = 27\n\n\nSub circlef (x As Long, y As Long, r As Long, c As Long)\n    Dim As Long x0, y0, e\n    x0 = r\n    y0 = 0\n    e = -r\n \n    Do While y0 < x0\n        If e <= 0 Then\n            y0 = y0 + 1\n            Line (x - x0, y + y0)-(x + x0, y + y0), c, BF\n            Line (x - x0, y - y0)-(x + x0, y - y0), c, BF\n            e = e + 2 * y0\n        Else\n            Line (x - y0, y - x0)-(x + y0, y - x0), c, BF\n            Line (x - y0, y + x0)-(x + y0, y + x0), c, BF\n            x0 = x0 - 1\n            e = e - 2 * x0\n        End If\n    Loop\n    Line (x - r, y)-(x + r, y), c, BF\nEnd Sub\n"
  },
  {
    "input": "Bubble Universe",
    "output": "Const xmax = 512, ymax = 512\n_Title \"Bubble Universe - ESC to exit\" ' from johnno at RCBasic forum 2022-11-14\nScreen _NewImage(xmax, ymax, 32)\n' ---------------\n' Paul Dunn posted this code but for SpecBAS in a facebook group.\n' It looked so cool that I had to  rewrite it in Naalaa 7. Marcus\n'\n' bplus QB64 Mod of RCB version by Johnno56\nTAU = 6.283185307179586\nn = 200\nr = TAU / 235\nx = 0\ny = 0\nv = 0\nt = 0\nhw = xmax / 2\nhh = ymax / 2\nDo\n    Color _RGB32(0, 0, 0)\n    Cls\n    For i = 0 To n\n        For j = 0 To n\n            u = Sin(i + v) + Sin(r * i + x)\n            v = Cos(i + v) + Cos(r * i + x)\n            x = u + t\n            Color _RGB(i, j, 99)\n            PSet (hw + u * hw * 0.4, hh + v * hh * 0.4)\n        Next\n    Next\n    t = t + 0.001 ' slowed way way down from .025\n    _Display\n    _Limit 30\nLoop Until _KeyDown(27)\n"
  },
  {
    "input": "Magestically waving American flag",
    "output": "'Option _Explicit\n'DefLng A-Z\n\nDim sw, sh\nDim h, w, a\nDim img\nDim x0, y0, x, y, dz\nDim tl, tr, bl, br\nDim r, g, b\nDim i, j, t\n\nsw = 640\nsh = 480\n\nDim Shared pi As Double\npi = 4 * Atn(1)\n\nScreen _NewImage(sw, sh, 32)\n\nh = 300\nw = 1.9 * h\na = h / 7\n\nimg = _NewImage(w, h, 32)\n_Dest img\nx0 = 0\ny0 = 0\n\nLine (0, 0)-Step(w, h), _RGB(255, 255, 255), BF\nFor i = 0 To 6\n    Line (0, i * h * 2 / 13)-Step(w, h / 13), _RGB(255 * 0.698, 255 * 0.132, 255 * 0.203), BF\nNext\nLine (0, 0)-Step(w * 2 / 5, h * 7 / 13), _RGB(255 * 0.234, 255 * 0.233, 255 * 0.430), BF\n\nFor i = 0 To 4\n    For j = 0 To 5\n        starf (j * 2 + 1) * w * 2 / (5 * 12), (i * 2 + 1) * h * 7 / 130, h * 4 / (13 * 5 * 2), _RGB(255, 255, 255)\n    Next\nNext\n\nFor i = 1 To 4\n    For j = 1 To 5\n        starf (j * 2) * w * 2 / (5 * 12), (i * 2) * h * 7 / 130, h * 4 / (13 * 5 * 2), _RGB(255, 255, 255)\n    Next\nNext\n\n_Dest 0\n'_putimage (sw/2 - w/2, sh/2 - h/2), img\n_Source img\n\nx0 = sw / 2 - w / 2 '+ sw\ny0 = sh / 2 - h / 2 '+ sh\n\nDim t As Double\nDim z As Double\n\nDim xx As Double, yy As Double\nDim dx As Double, dy As Double\nDo\n    t = t + 0.2\n\n    Line (0, 0)-Step(sw, sh), _RGB(0, 0, 0), BF\n\n    For y = 0 To h + a * 0.707 Step 1\n        For x = 0 To w + a * 0.707 Step 1\n            z = (0.1 + 0.4 * (x / w)) * a * Sin(x / 35 - y / 70 - t) + 0.5 * a\n            dz = 50 * a * Cos(x / 35 - y / 70 - t) / 35\n\n            xx = x + z * 0.707 - a * 0.707\n            yy = y - z * 0.707\n\n            If (Int(xx) >= 0 And Int(xx) < w - 1 And Int(yy) >= 0 And Int(yy) < h - 1) Then\n                tl = Point(Int(xx), Int(yy))\n                tr = Point(Int(xx) + 1, Int(yy))\n                bl = Point(Int(xx), Int(yy) + 1)\n                br = Point(Int(xx) + 1, Int(yy) + 1)\n\n                dx = xx - Int(xx)\n                dy = yy - Int(yy)\n\n                r = _Round((1 - dy) * ((1 - dx) * _Red(tl) + dx * _Red(tr)) + dy * ((1 - dx) * _Red(bl) + dx * _Red(br)))\n                g = _Round((1 - dy) * ((1 - dx) * _Green(tl) + dx * _Green(tr)) + dy * ((1 - dx) * _Green(bl) + dx * _Green(br)))\n                b = _Round((1 - dy) * ((1 - dx) * _Blue(tl) + dx * _Blue(tr)) + dy * ((1 - dx) * _Blue(bl) + dx * _Blue(br)))\n\n                r = r + dz\n                g = g + dz\n                b = b + dz\n\n                If r < 0 Then r = 0\n                If r > 255 Then r = 255\n                If g < 0 Then g = 0\n                If g > 255 Then g = 255\n                If b < 0 Then b = 0\n                If b > 255 Then b = 255\n\n                PSet (x0 + x, y0 - a * 0.707 + y), _RGB(r, g, b)\n            End If\n        Next\n    Next\n\n    _Display\n    _Limit 50\nLoop Until _KeyHit = 27\n\nSleep\nSystem\n\nSub starf (x, y, r, c)\n    Dim i, xx, yy\n    PSet (x + r * Cos(pi / 2), y - r * Sin(pi / 2)), c\n    For i = 0 To 5\n        xx = r * Cos(i * 4 * pi / 5 + pi / 2)\n        yy = r * Sin(i * 4 * pi / 5 + pi / 2)\n        Line -(x + xx, y - yy), c\n    Next\n    Paint (x, y), c\n    For i = 0 To 5\n        xx = r * Cos(i * 4 * pi / 5 + pi / 2) / 2\n        yy = r * Sin(i * 4 * pi / 5 + pi / 2) / 2\n        Paint (x + xx, y - yy), c\n    Next\nEnd Sub\n\n\n"
  },
  {
    "input": "Deep Field",
    "output": "' Converted to QBJS from specbas sample by ZXDunny\n' PROG demos:graphics/deep field\n' REM Deep Field by P Malin\nRANDOMIZE TIMER\nDIM G, t1, q1, u1, v1, A, R, Q, a1, M, C, i1, S, T, D, Z, x1, U, clr\nDIM pal()\n'SCREEN _NEWIMAGE(1280, 768)\nSCREEN _NEWIMAGE(_RESIZEWIDTH-5, _RESIZEHEIGHT-5)\nDIM points(_WIDTH, _HEIGHT)\nCLS\npal(1) = &HFFFF0000: pal(2) = &HFFFF8000: pal(3) = &HFFFFFF00: pal(4) = &HFFFFFF80: pal(5) = &HFFFFFFFF\nFOR G = -64 TO 800\n    t1=RND*99: q1=RND*99\n    u1=RND*_WIDTH: v1=RND*_HEIGHT\n    A=RND*3: R=90/(1+RND*200): Q=1+R*(.5+RND/2)\n    a1=1+3*RND^2: M=1: C=(1+3*RND^2)*R*R\n    IF RND*9<4 THEN\n        Q=R: t1=0: q1=0: A=0: M=_PI/3: a1=1\n     END IF\n     FOR i1 = 0 TO C\n         S=-LOG(RND): T=i1*M: U=S*R*SIN(T): V=S*Q*COS(T)\n         T=S*A: X=U*COS(T)+V*SIN(T): Y=V*COS(T)-U*SIN(T)\n         D=(X*X+Y*Y)/(R*R+Q*Q): Z=99*((2.7^-D)+.1)\n         Z=Z*(RND-.5)^3: y1=Y*COS(t1)+Z*SIN(t1): Z=Z*COS(t1)-Y*SIN(t1)\n         x1=u1+X*COS(q1)+y1*SIN(q1): y1=v1-X*SIN(q1)+y1*COS(q1)\n         x1p = _ROUND(x1): y1p = _ROUND(y1)\n         clr = _ROUND(min(5, max(0, points(x1p,y1p)) + a1))\n         PSET (x1p, y1p), pal(clr) \n         points(x1p, y1p) = clr\n    NEXT i1\nNEXT G\n\nFUNCTION MIN(var1, var2)\n    IF var1 < var2 THEN MIN = var1 ELSE MIN = var2\nEND FUNCTION\n\nFUNCTION MAX(var1, var2)\n    IF var1 > var2 THEN MAX = var1 ELSE MAX = var2\nEND FUNCTION"
  },
  {
    "input": "Gold Wave",
    "output": "_Title \"Gold Wave bplus 2018-03-13\"\n'translated from SmallBASIC: Goldwave by johnno copied and mod by bplus 2018-01-28\nImport Gfx From \"lib/graphics/2d.bas\"\n'QB64 version 2017 1106/82 (the day before they switched to version 1.2)\nConst xmax = 600\nConst ymax = 480\nScreen _NewImage(xmax, ymax, 32)\nDim ccc As _Unsigned Long\n\nWhile 1\n    For t = 1 To 60 Step .1 '< changed\n        Cls 'changed\n        For y1 = 0 To 24\n            For x1 = 0 To 24\n                x = (12 * (24 - x1)) + (12 * y1)\n                y = (-6 * (24 - x1)) + (6 * y1) + 300\n                d = ((10 - x1) ^ 2 + (10 - y1) ^ 2) ^ .5\n                h = 60 * Sin(x1 / 4 + t) + 65\n                If t > 10 And t < 20 Then h = 60 * Sin(y1 / 4 + t) + 65\n                If t > 20 And t < 30 Then h = 60 * Sin((x1 - y1) / 4 + t) + 65\n                If t > 30 And t < 40 Then h = 30 * Sin(x1 / 2 + t) + 30 * Sin(y1 / 2 + t) + 65\n                If t > 40 And t < 50 Then h = 60 * Sin((x1 + y1) / 4 + t) + 65\n                If t > 50 And t < 60 Then h = 60 * Sin(d * .3 + t) + 65\n\n                'TOP\n                ccc = _RGB32(242 + .1 * h, 242 + .1 * h, h)\n                Gfx.FillTriangle x, y - h, x + 10, y + 5 - h, x + 20, y - h, ccc\n                Gfx.FillTriangle x, y - h, x + 10, y - 5 - h, x + 20, y - h, ccc\n                'FRONT-LEFT\n                ccc = _RGB(255, 80, 0)\n                Gfx.FillTriangle x, y - h, x + 10, y + 5 - h, x + 10, y, ccc\n                Gfx.FillTriangle x, y - h, x, y - 5, x + 10, y, ccc\n                'FRONT-RIGHT\n                ccc = _RGB32(255, 150, 0)\n                Gfx.FillTriangle x + 10, y + 5 - h, x + 10, y, x + 20, y - 5, ccc\n                Gfx.FillTriangle x + 10, y + 5 - h, x + 20, y - h, x + 20, y - 5, ccc\n\n                If InKey$ = Chr$(27) Then End\n            Next\n        Next\n        _Display\n        _Limit 60\n    Next\nWend\n\n"
  },
  {
    "input": "Diamond Spaceship",
    "output": "Import Gfx From \"lib/graphics/2d.bas\"\n_Title \"Diamond Spaceship\" 'b+ 2022-07-23\n' 2022-7-24 fixed panel problems and added PolyFill routine for rise and fall glowing\n\n'spinning diamond mini-micro script in micro(A)\n' from Aurel Micro A trans:  http://basic4all.epizy.com/index.php?topic=199.new#new\n\nScreen _NewImage(800, 600, 32)\nDim pi, p6, t, m, dir, glow, i, x, a, y, b, lx, ly, la, lb\nDim ao\npi = _Pi\np6 = pi / 6\nt = 0\nm = 400\ndir = 1\nglow = 50\nColor _RGB32(200, 200, 240), _RGB32(0, 0, 0)\nDim As _Unsigned Long colr, edge\nDim poly(25)\nedge = &H99AAAAFF\nDo Until _KeyDown(27)\n    Cls\n    t = (t + 0.01)\n    i = 0\n    While i <= 12\n        r = Cos(p6 * i + t + ao)\n        x = m - 300 * r\n        a = m - 250 * r\n        y = 400 - 40 * Cos(p6 * (i - 3) + t + ao) - 140 + glow ' y\n        b = y + 50\n        Color _RGB32(200, 200, 240)\n        Line (m, 100 - 140 + glow)-(x, y), edge\n        Line (x, y)-(a, b), edge\n        If i Mod 2 Then colr = &H220000FF Else colr = &H2200FFFF\n        If i > 0 Then\n            Line (a, b)-(la, lb), edge ' bottom disk\n            Line (x, y)-(lx, ly), edge ' top disk\n            Gfx.FillTriangle lx, ly, x, y, a, b, colr\n            Gfx.FillTriangle a, b, la, lb, lx, ly, colr\n            Gfx.FillTriangle m, 100 - 140 + glow, lx, ly, x, y, colr\n        End If\n        poly(2 * i) = a\n        poly(2 * i + 1) = b\n        lx = x: ly = y\n        la = a: lb = b\n        i = i + 1\n    Wend\n    glow = glow + dir\n    If glow >= 256 Then dir = -dir: glow = 255\n    If glow <= 49 Then dir = -dir: glow = 50\n    PolyFill m, 450 - 140 + glow, poly(), _RGB32(200, 200, 255, glow)\n    _Display\n    _Limit 30\nLoop\n\n\nSub PolyFill (xc, yc, poly(), K As _Unsigned Long) ' closed poly the last point repeats the first to close loop\n    Dim i\n    For i = LBound(poly) + 2 To UBound(poly) Step 2\n        Gfx.FillTriangle xc, yc, poly(i - 2), poly(i - 1), poly(i), poly(i + 1), K\n    Next\nEnd Sub"
  },
  {
    "input": "Loads a standard web font for display.",
    "output": "Import Gfx From \"lib/graphics/2d.bas\"\n\nDim f As Long\nf = _LoadFont(\"Arial, Helvetica, sans-serif\", 60)\n_Font f\n\nDim img As Long\nimg = _NewImage(_PrintWidth(\"Hello World!\"), _FontHeight)\n_Dest img\nColor 15\n_PrintMode _KeepBackground\n_PrintString (0, 0), \"Hello World!\"\n_Dest 0\n\nDim As Integer a, x, y\nx = _Width / 2\ny = _Height / 2\nDo\n    Line (1, 1)-(_Width, _Height), _RGBA(0, 0, 0, 70), BF\n    Gfx.RotoZoom x, y, img, 1, 1, a\n    a = a + 3\n    If a > 359 Then a = 0\n    _Limit 60\nLoop"
  },
  {
    "input": "Loads a web font from a URL.",
    "output": "Import Dom From \"lib/web/dom.bas\"\n\nDim f\nf = _LoadFont(\"https://fonts.gstatic.com/s/indieflower/v17/m8JVjfNVeKWVnh3QMuKkFcZVaUuH.woff2\", 24)\n_Font f\n\nCls , 15\nColor 8\n_PrintMode _KeepBackground\n\nPrint \nPrint \"  Day 27:\"\nPrint \"  I am still trapped on the island with no hope of escape.\"\nPrint \"  I struggle against despair, but the realization that I will\"\nPrint \"  never leave this place haunts my every waking thought...\"\nPrint\nPrint \"  I saw the parrot again today.\""
  },
  {
    "input": "Demonstration of the QBJS Console Library",
    "output": "Import Console From \"lib/web/console.bas\"\n\n' You can change the log level to affect which messages\n' will be displayed. The available log levels are:\n' NONE, FATAL, ERROR, WARN, INFO, DEBUG, TRACE, ALL\nConsole.LogLevel Console.DEBUG\n\nConsole.Log \"This is an info message.\"\nConsole.Log \"This is a trace message, it will be ignored.\", Console.TRACE\nDoStuff\n\nConsole.Echo \"And thus concludes the exhilarating demonstration of the QBJS Console library.\"\n\n\nSub DoStuff\n    Console.Log \"Before Doing Stuff\", Console.DEBUG\n    Print \"foo\"\n    uh oh here is an error line\n    Exit Sub\n    Console.Log \"wonder why we never get here?\", Console.Debug\nEnd Sub"
  },
  {
    "input": "Demonstration of the QBJS 2D Graphics Library",
    "output": "Import G2D From \"lib/graphics/2d.bas\"\n\nCls , 15\nG2D.RoundRect 10, 10, 200, 200, 5, 9\nG2D.Ellipse 110, 110, 50, 30, 0, 2\n\nG2D.Shadow 0, 7, 7, 10\nG2D.FillRoundRect 300, 10, 200, 75, 15, 3\nG2D.FillCircle 50, 50, 30, 4\nG2D.ShadowOff\n\nG2D.FillEllipse 320, 320, 60, 40, 15, 5\n\nG2D.Shadow 5, 0, 0, 15\nLine (350, 150)-(450, 250), 0, BF\nG2D.FillTriangle 500, 300, 580, 300, 530, 380, 1\nG2D.ShadowOff\n\nG2D.LineWidth 6\nG2D.LineDash 12, 4\nLine (20, 300)-(200, 380), 0, B\nG2D.LineDashOff\n\nG2D.LineWidth 15\nLine (20, 240)-(200, 240), 4\nG2D.LineCap G2D.ROUND\nLine (20, 260)-(200, 260), 4\nG2D.LineCap G2D.SQUARE\nLine (20, 280)-(200, 280), 4\n\nG2D.LineWidth 25\nG2D.LineCap G2D.ROUND\nG2D.Curve 470, 120, 650, 100, 520, 250, 2\n\nG2D.Shadow 0, 7, 7, 10\nG2D.LineWidth 3\nG2D.Bezier 260, 20, 200, 100, 310, 150, 260, 250, 1\nG2D.ShadowOff"
  },
  {
    "input": "Easy Spiral",
    "output": "Import Gfx From \"lib/graphics/2d.bas\"\n\n_Title \"Easy Spiral\" 'b+ 2022-04? from Easy Lang site very Interesting!  https://easylang.online\n' this one inspired Johnno to post at RCBasic,  https://rcbasic.freeforums.net  , also an interesting site!\nScreen _NewImage(700, 700, 32)\n\nDim tick, pi, s, c, h, x, y\npi = _Pi: s = 7\nDo\n    Cls\n    For c = 1 To 3000 '1320\n        h = c + tick\n        x = Sin(6 * h / pi) + Sin(3 * h)\n        h = c + tick * 2\n        y = Cos(6 * h / pi) + Cos(3 * h)\n        Gfx.FillCircle s * (20 * x + 50), s * (20 * y + 50), 2, &HFFFFFFFF\n    Next\n    _Display\n    _Limit 60\n    tick = tick + .001\nLoop Until _KeyDown(27)\n"
  },
  {
    "input": "Filled polygon routine using G2D.FillTriangle",
    "output": "'polyFT in QBjs\n'v 0.5\n'haven't quite figure out how to make the this look good with thicker lines but it works fine at one pixel wide\nImport G2D From \"lib/graphics/2d.bas\"\n\nG2D.LineWidth 4\nG2D.LineCap G2D.ROUND\n\nRandomize Timer\nFor i = 0 to 100\npolyFT Rnd * 640, Rnd * 400,rnd*30+30,int(3+rnd*12),int(rnd*360),_rgb32(int(rnd*256),int(rnd*256),int(rnd*256)),_rgb32(int(rnd*256),int(rnd*256),int(rnd*256))\n_Limit 200\nNext i\n\n\nSub polyFT (cx As Long, cy As Long, rad As Long, sides As Integer, rang As Long, klr As _Unsigned Long, lineyes As _Unsigned Long)\n    'draw an equilateral polygon using filled triangle for each segment\n    'centered at cx,cy to radius rad of sides # of face rotated to angle rang scaled to ww and vv of color klr and lineyes if there is an outline, a value 0 would create no outline\n    Dim px(sides)\n    Dim py(sides)\n    pang = 360 / sides\n    ang = 0\n    For p = 1 To sides\n        px(p) = cx + (rad * Cos(0.01745329 * (ang + rang)))\n        py(p) = cy + (rad * Sin(0.01745329 * (ang + rang)))\n        ang = ang + pang\n    Next p\n    For p = 1 To sides - 1\n    line (cx,cy)-(px(p),py(p)),klr\n    G2D.FillTriangle cx,cy,px(p),py(p),px(p+1),py(p+1),klr\n    Next p\n    line (cx,cy)-(px(sides),py(sides)),klr\n    G2D.FillTriangle cx,cy,px(sides),py(sides),px(1),py(1),klr\n  if lineyes>0 then\n  for p =1 to sides-1\n    Line (px(p), py(p))-(px(p + 1), py(p + 1)), lineyes\n  next\n  Line (px(sides), py(sides))-(px(1), py(1)), lineyes\n  end if\nEnd Sub"
  },
  {
    "input": "Spinning Spiral Wheel",
    "output": "'Dav, SEP/2023\n\nScreen _NewImage(800, 600, 32)\n\nDim points, i, a, b, clr&, w 'for qbjs to use\n\n'generate starting values\npoints = 9 + Int(Rnd * 10) 'num of points to use\nReDim px(points), py(points) 'x/y pos of points\nclr& = _RGB(Rnd * 255, Rnd * 255, Rnd * 255) 'make random color\n\nDo\n    Cls\n    'compute x/y pos\n    For i = 0 To points\n        px(i) = (_Width / 2) + (Sin((Timer * .5) * (i / points)) * _Height / 2)\n        py(i) = (_Height / 2) + (Cos((Timer * .5) * (i / points)) * _Height / 2)\n    Next\n\n    'do the points\n    For a = 0 To points\n        For b = 0 To points\n            Line (px(a), py(a))-(px(b), py(b)), clr&\n            For w = 1 To (points / 2) Step .36\n                Circle (px(a), py(a)), w, clr&\n            Next\n        Next\n    Next\n\n    Locate 1, 1: Print \"ENTER for new wheel\";\n    Locate 2, 1: Print points; \" points\";\n\n    _Limit 60\n    _Display\n\n    If InKey$ <> \"\" Then\n        points = 9 + Int(Rnd * 10) 'num of points to use\n        ReDim px(points), py(points) 'x/y pos of points\n        clr& = _RGB(Rnd * 255, Rnd * 255, Rnd * 255) 'random color\n    End If\n    \nLoop Until _KeyHit = 27\n\n\n"
  },
  {
    "input": "Plasma Laser Cannon Pointer",
    "output": "'Option _Explicit\n'_Title \"Plasma Laser Cannon Pointer\" ' for QBJS b+ 2023-09-21\n' start mod from Plasma Laser Canon demo prep for GUI 2020-11-11\n\nScreen _NewImage(1200, 600, 32)\nRandomize Timer\nDim Shared As Long ShipLights\nDim Shared As _Unsigned Long ShipColor\nDim As Long cx, cy, mx, my, mb, sx, sy\nDim As Single ma, md, dx, dy\ncy = _Height / 2: cx = _Width / 2\nShipColor = &HFF3366AA\n'  _MouseHide '??? not supported and bad idea anyway\nDo\n    Cls\n    While _MouseInput: Wend\n    mx = _MouseX: my = _MouseY: mb = _MouseButton(1)\n    dx = mx - cx ' ship avoids collision with mouse\n    dy = my - cy\n    ma = _Atan2(dy, dx)\n    md = Sqr(dy * dy + dx * dx)\n    If md < 80 Then md = 80\n    sx = cx + md * Cos(ma + 3.1415)\n    sy = cy + md * Sin(ma + 3.1415)\n    drawShip sx, sy, ShipColor\n    If mb Then\n        PLC sx, sy, mx, my, 10 ' Fire!\n        ShipColor = _RGB32(Int(Rnd * 256), Int(Rnd * 136) + 120, Int(Rnd * 156) + 100)\n    End If\n    _Display\n    _Limit 60\nLoop Until _KeyDown(27)\n\nSub PLC (baseX, baseY, targetX, targetY, targetR) ' PLC for PlasmaLaserCannon\n    Dim r, g, b, hp, ta, dist, dr, x, y, c, rr\n    r = Rnd ^ 2 * Rnd: g = Rnd ^ 2 * Rnd: b = Rnd ^ 2 * Rnd: hp = _Pi(.5) ' red, green, blue, half pi\n    ta = _Atan2(targetY - baseY, targetX - baseX) ' angle of target to cannon base\n    dist = _Hypot(targetY - baseY, targetX - baseX) ' distance cannon to target\n    dr = targetR / dist\n    For r = 0 To dist Step .25\n        x = baseX + r * Cos(ta)\n        y = baseY + r * Sin(ta)\n        c = c + .3\n        Color _RGB32(128 + 127 * Sin(r * c), 128 + 127 * Sin(g * c), 128 + 127 * Sin(b * c))\n        fcirc x, y, dr * r\n    Next\n    For rr = dr * r To 0 Step -.5\n        c = c + 1\n        Color _RGB32(128 + 127 * Sin(r * c), 128 + 127 * Sin(g * c), 128 + 127 * Sin(b * c))\n        fcirc x, y, rr\n    Next\nEnd Sub\n\nSub drawShip (x, y, colr As _Unsigned Long) 'shipType     collisions same as circle x, y radius = 30\n    ' shared here ShipLights\n\n    Dim light As Long, r As Long, g As Long, b As Long\n    r = _Red32(colr): g = _Green32(colr): b = _Blue32(colr)\n    Color _RGB32(r, g - 120, b - 100)\n    fEllipse x, y, 6, 15\n    Color _RGB32(r, g - 60, b - 50)\n    fEllipse x, y, 18, 11\n    Color _RGB32(r, g, b)\n    fEllipse x, y, 30, 7\n    For light = 0 To 5\n        Color _RGB32(ShipLights * 50, ShipLights * 50, ShipLights * 50)\n        fcirc x - 30 + 11 * light + ShipLights, y, 1\n    Next\n    ShipLights = ShipLights + 1\n    If ShipLights > 5 Then ShipLights = 0\nEnd Sub\n\n' these do work in QBJS without mod see le bombe\nSub fcirc (CX As Long, CY As Long, R As Long)\n    Dim subRadius As Long, RadiusError As Long\n    Dim X As Long, Y As Long\n\n    subRadius = Abs(R)\n    RadiusError = -subRadius\n    X = subRadius\n    Y = 0\n\n    If subRadius = 0 Then PSet (CX, CY): Exit Sub\n\n    ' Draw the middle span here so we don't draw it twice in the main loop,\n    ' which would be a problem with blending turned on.\n    Line (CX - X, CY)-(CX + X, CY), , BF\n\n    While X > Y\n        RadiusError = RadiusError + Y * 2 + 1\n        If RadiusError >= 0 Then\n            If X <> Y + 1 Then\n                Line (CX - Y, CY - X)-(CX + Y, CY - X), , BF\n                Line (CX - Y, CY + X)-(CX + Y, CY + X), , BF\n            End If\n            X = X - 1\n            RadiusError = RadiusError - X * 2\n        End If\n        Y = Y + 1\n        Line (CX - X, CY - Y)-(CX + X, CY - Y), , BF\n        Line (CX - X, CY + Y)-(CX + X, CY + Y), , BF\n    Wend\nEnd Sub\n\nSub fEllipse (CX As Long, CY As Long, xRadius As Long, yRadius As Long)\n    Dim scale As Single, x As Long, y As Long\n    scale = yRadius / xRadius\n    Line (CX, CY - yRadius)-(CX, CY + yRadius), , BF\n    For x = 1 To xRadius\n        y = scale * Sqr(xRadius * xRadius - x * x)\n        Line (CX + x, CY - y)-(CX + x, CY + y), , BF\n        Line (CX - x, CY - y)-(CX - x, CY + y), , BF\n    Next\nEnd Sub\n"
  },
  {
    "input": "QBJS Starscape",
    "output": "const stars = 2000\nconst galaxies = 50\n\nrandomize timer\ndim shared pi, d, zz, sw, sh\npi = 4*atn(1)\nd = 700\nzz = 2100\nsw = _RESIZEWIDTH-5\nsh = _RESIZEHEIGHT-5\n\ntype stype\n    x as double\n    y as double\n    z as double\nend type\ndim shared star(stars) as stype\n\ntype gtype\n    x as double\n    y as double\n    z as double\n\n    r as double\n    r1 as double\n    r2 as double\n\n    a1 as double\n    a2 as double\n    a3 as double\nend type\ndim shared galaxy(galaxies) as gtype\n\nscreen _newimage(sw, sh, 32)\n\ndim as double i,x1,y1,z1,z0,r,r1,r2,a1,a2,a3\n\nfor i=0 to stars\n    star(i).x = 5000*rnd-2500\n    star(i).y = 5000*rnd-2500\n    star(i).z = 5000*rnd-2500\nnext\nfor i=0 to galaxies\n    galaxy(i).x = 4000*rnd-2000\n    galaxy(i).y = 4000*rnd-2000\n    galaxy(i).z = 4000*rnd-2000\n    galaxy(i).r = 150*rnd\n    galaxy(i).r1 = rnd\n    galaxy(i).r2 = rnd\n    galaxy(i).a1 = 2*pi*rnd\n    galaxy(i).a2 = 2*pi*rnd\n    galaxy(i).a3 = 4*pi*rnd - 2.5*pi*rnd\nnext\n\n\ndim p, q\ndo\n    cls\n\n    for i=0 to stars\n        star(i).z = star(i).z - 100\n        if star(i).z < 0 then\n            star(i).x = 4000*rnd-2000\n            star(i).y = 4000*rnd-2000\n            star(i).z = 4000*rnd-2000\n        end if\n        x1 = star(i).x\n        y1 = star(i).y\n        z1 = star(i).z\n        for z0 = 0 to 3\n    \n            p = sw/2 + x1*d/(z1 + zz + z0*10)\n            q = sh/2 - y1*d/(z1 + zz + z0*10)\n            if p>0 and p<sw and q>0 and q<sh then\n            pset (p, q),_rgb(255 - 50*z0, 255 - 50*z0, 0)\n            end if\n        next\n    next\n\n    for i=0 to galaxies\n        galaxy(i).z = galaxy(i).z - 100\n        if galaxy(i).z < 0 then\n            galaxy(i).x = 4000*rnd-2000\n            galaxy(i).y = 4000*rnd-2000\n            galaxy(i).z = 4000*rnd+8000\n            galaxy(i).r = 20*rnd + 30\n            galaxy(i).r1 = rnd\n            galaxy(i).r2 = rnd\n            galaxy(i).a1 = 2*pi*rnd\n            galaxy(i).a2 = 2*pi*rnd\n            galaxy(i).a3 = 4*pi*rnd - 2.5*pi*rnd\n        end if\n        x1 = galaxy(i).x\n        y1 = galaxy(i).y\n        z1 = galaxy(i).z\n        r = galaxy(i).r\n        r1 = galaxy(i).r1\n        r2 = galaxy(i).r2\n        a1 = galaxy(i).a1\n        a2 = galaxy(i).a2\n        a3 = galaxy(i).a3\n   \n        drawgalaxy x1, y1, z1, r, r1, r2, a1, a2, a3\n    next\n\n    _display\n    _limit 60\nloop until _keyhit = 27\nsleep\nsystem\n\nsub drawgalaxy(x1, y1, z1, r, r1, r2, a1, a2, u)\n    dim c as _unsigned long\n    dim p, q\n    dim x,y,z,xx,yy,zz,x0,y0,z0,i,k,a,rr,gg,bb\n    for a=0 to u step 0.1\n        for i=0 to 0.001*r*(u - a)^3.5\n            x0 = (rnd - 0.5)*0.2*r*(u - a)\n            y0 = (rnd - 0.5)*0.2*r*(u - a)\n            z0 = (rnd - 0.5)*0.2*r*(u - a)\n\n            if x0*x0 + y0*y0 + z0*z0 < 2000 then\n            for k=0 to 1\n                x = x0 + r1*r*a*cos(a + k*pi)\n                y = y0 + r2*r*a*sin(a + k*pi)\n                z = z0 + 1\n\n                'rot x, y, a1\n                'rot y, z, a2\n\n                xx = x\n                yy = y\n                x = xx*cos(a1) - yy*sin(a1)\n                y = xx*sin(a1) + yy*cos(a1)\n\n                yy = y\n                zz = z\n                y = yy*cos(a2) - zz*sin(a2)\n                z = yy*sin(a2) + zz*cos(a2)\n\n                c = 255*(u - a)/2\n                rr = c + rnd*50\n                gg = 0.2*c + rnd*50\n                bb = 0\n                if rr < 0 then rr = 0\n                if gg < 0 then gg = 0\n                if bb < 0 then bb = 0\n                if rr > 255 then rr = 255\n                if gg > 255 then gg = 255\n                if bb > 255 then bb = 255\n                rr = rr - z1/100\n                gg = gg - z1/100\n                bb = bb - z1/100\n                \n                p = sw/2 + (x + x1)*d/(z + z1 + zz)\n                q = sh/2 - (y + y1)*d/(z + z1 + zz)\n                if p>0 and p<sw and q>0 and q<sh then\n                pset (p, q), _rgb(rr, gg, bb)\n                end if\n\n            next\n            end if\n        next\n    next\nend sub\n"
  },
  {
    "input": "Le Bombe",
    "output": "'Option _Explicit  'edit for QBJS 2023-09-08\n_Title \"le bombe\"\n'QB64 X 64 version 1.2 20180228/86  from git b301f92\n\n'2018-07-28 translated from\n'bomb.bas for SmallBASIC 0.12.2 [B+=MGA] 2016-05-09\n'from explosion study\n\nConst xmax = 800\nConst ymax = 600\nScreen _NewImage(xmax, ymax, 32)\n'_ScreenMove 360, 60\nConst max_particles = 1000\nConst gravity = .25\nConst air_resistance = .95\nType particle\n    x As Single\n    y As Single\n    dx As Single\n    dy As Single\n    size As Single\n    kolor As Long\n    tf As Integer\nEnd Type\nDim Shared dots(max_particles) As particle\nDim As Long i, rounds, loop_count\n'main\nWhile Not _KeyDown(27)\n    For i = 1 To 100\n        NewDot i\n    Next\n    rounds = 100\n    For i = 12 To 0 Step -1\n        If _KeyDown(27) Then End\n        Cls\n        DrawSky\n        DrawGround\n        DrawBomb\n        DrawFuse i\n        _Display\n        If i = 0 Then _Delay Rnd * 3 Else _Delay .100\n    Next\n    Line (0, 0)-(xmax, ymax), _RGB32(255, 255, 255), BF\n    _Display\n    _Delay .02\n    For loop_count = 0 To 150\n        If _KeyDown(27) Then End\n        DrawSky\n        DrawGround\n        If loop_count < 4 Then\n            Color _RGB(64 - 8 * loop_count, 40 - 4 * loop_count, 32 - 4 * loop_count)\n            If loop_count < 8 Then fcirc xmax / 2, ymax / 2, 30 * (1 - loop_count * .25)\n        End If\n        For i = 1 To rounds\n            dots(i).x = dots(i).x + dots(i).dx\n            dots(i).y = dots(i).y + dots(i).dy\n            If Rnd < .2 And rounds > 10 And dots(i).y > ymax / 2 Then dots(i).dx = 0: dots(i).dy = 0\n            dots(i).dx = dots(i).dx * air_resistance\n            If dots(i).dy <> 0 Then dots(i).dy = air_resistance * dots(i).dy + .4 'air resistance and gravity\n            If dots(i).tf Then\n                Line (dots(i).x, dots(i).y)-Step(dots(i).size, dots(i).size), dots(i).kolor, BF\n            Else\n                Color dots(i).kolor\n                fcirc dots(i).x, dots(i).y, dots(i).size / 2\n            End If\n        Next\n        If rounds < max_particles Then\n            For i = 1 To 100\n                NewDot (rounds + i)\n            Next\n            rounds = rounds + 100\n        End If\n        Color _RGB32(255, 255, 255), _RGB32(0, 0, 255)\n        Locate 1, 1: Print loop_count\n        _Display\n        _Limit 60\n    Next\nWend\n\nSub NewDot (i)\n    Dim angle, r\n    angle = _Pi(Rnd * 2)\n    dots(i).x = xmax / 2 + Rnd * 30 * Cos(angle)\n    dots(i).y = ymax / 2 + Rnd * 30 * Sin(angle)\n    r = Rnd 'STxAxTIC recommended for rounder spreads\n    dots(i).dx = r * 45 * Cos(angle)\n    dots(i).dy = r * 45 * Sin(angle)\n    dots(i).size = Rnd * 7\n    dots(i).kolor = _RGB32(10 + Rnd * 100, 5 + Rnd * 50, 3 + Rnd * 25)\n    dots(i).tf = (Rnd * 2) \\ 1\nEnd Sub\n\nSub DrawSky\n    Dim i\n    For i = 0 To ymax / 2\n        Line (0, i)-Step(xmax, 0), _RGB32(0, 0, 95 * i \\ (ymax / 2) + 160)\n    Next\nEnd Sub\n\nSub DrawBomb\n    Dim cx, cy, radius, angle, rad_angle, x1, y1\n    Dim As Long i\n    cx = xmax / 2: cy = ymax / 2 - 70: radius = 10\n    For i = 60 To 0 Step -1 'main body\n        Color _RGB32(240 - 4 * i, 180 - 3 * i, 120 - 2 * i)\n        fcirc cx, ymax / 2, i\n    Next\n\n    For angle = 0 To 180 'fuse shaft\n        rad_angle = _D2R(angle)\n        x1 = cx + radius * Cos(rad_angle)\n        y1 = cy + radius * .25 * Sin(rad_angle)\n        Line (x1, y1)-Step(0, 20), _RGB32(127 + 127 * Cos(rad_angle), 127 + 127 * Cos(rad_angle), 127 + 127 * Cos(rad_angle))\n    Next\n    Color _RGB32(0, 0, 0)\n    fEllipse cx, cy, radius, .25 * radius\nEnd Sub\n\nSub DrawFuse (length)\n    Dim cx, cy, rn, rad_angle, x1, y1, x2, y2\n    Dim As Long i\n    cx = xmax / 2: cy = ymax / 2 - 70\n    If length <= 0 Then Exit Sub\n    Color _RGB32(255, 255, 0)\n    Line (cx, cy - (5 + 2 * length))-Step(2, 5), , BF\n    fcirc cx, cy - (1 + 2 * length), 2\n    rn = (Rnd * 5) \\ 1 + 3\n    For i = 1 To rn\n        rad_angle = _Pi(Rnd) + _Pi\n        x1 = cx + 7 * Cos(rad_angle): x2 = cx + 14 * Cos(rad_angle)\n        y1 = cy - (1 + 2 * length) + 9 * Sin(rad_angle): y2 = cy - (1 + 2 * length) + (Rnd * 13 + 9) * Sin(rad_angle)\n        Line (x1, y1)-(x2, y2), _RGB32(255, 255, 255)\n    Next\n    For i = 1 To length\n        rad_angle = _Pi(Rnd * 2)\n        x1 = 3 * Cos(rad_angle)\n        y1 = 3 * .25 * Sin(rad_angle)\n        Line (cx, cy - 2 * i)-Step(x1, y1), _RGB32(Rnd * 65 + 190, Rnd * 65 + 190, Rnd * 20 + 235), BF\n    Next\nEnd Sub\n\nSub DrawGround\n    Dim As Long i\n    For i = ymax / 2 To ymax\n        Line (0, i)-Step(xmax, 0), _RGB32(0, 160 - 96 * (i - ymax / 2) \\ (ymax / 2), 0)\n    Next\nEnd Sub\n\nSub fcirc (CX As Long, CY As Long, R As Long)\n    Dim subRadius As Long, RadiusError As Long\n    Dim X As Long, Y As Long\n\n    subRadius = Abs(R)\n    RadiusError = -subRadius\n    X = subRadius\n    Y = 0\n\n    If subRadius = 0 Then PSet (CX, CY): Exit Sub\n\n    ' Draw the middle span here so we don't draw it twice in the main loop,\n    ' which would be a problem with blending turned on.\n    Line (CX - X, CY)-(CX + X, CY), , BF\n\n    While X > Y\n        RadiusError = RadiusError + Y * 2 + 1\n        If RadiusError >= 0 Then\n            If X <> Y + 1 Then\n                Line (CX - Y, CY - X)-(CX + Y, CY - X), , BF\n                Line (CX - Y, CY + X)-(CX + Y, CY + X), , BF\n            End If\n            X = X - 1\n            RadiusError = RadiusError - X * 2\n        End If\n        Y = Y + 1\n        Line (CX - X, CY - Y)-(CX + X, CY - Y), , BF\n        Line (CX - X, CY + Y)-(CX + X, CY + Y), , BF\n    Wend\nEnd Sub\n\nSub fEllipse (CX As Long, CY As Long, xRadius As Long, yRadius As Long)\n    Dim scale As Single, x As Long, y As Long\n    scale = yRadius / xRadius\n    Line (CX, CY - yRadius)-(CX, CY + yRadius), , BF\n    For x = 1 To xRadius\n        y = scale * Sqr(xRadius * xRadius - x * x)\n        Line (CX + x, CY - y)-(CX + x, CY + y), , BF\n        Line (CX - x, CY - y)-(CX - x, CY + y), , BF\n    Next\nEnd Sub\n"
  },
  {
    "input": "Missle Command",
    "output": "'Option _Explicit '    Get into this habit and save yourself grief from Typos comment out for QBJS\n\n_Title \"Missile Command QBJS EnRitchied\" '                b+ mod 2023-06-28, now try QBJS adaption\n'                                   I probably picked up this game at the JB forum some years ago.\n\n'    Get Constants, Shared Variables and Arrays() declared. These Will Start with Capital Letters.\n'        Get Main module variables and arrays declared with starting lower case letters for local.\n'         This is what Option _Explicit helps, by forcing us to at least declare these before use.\n'       While declaring, telling QB64 the Type we want to use, we can also give brief description.\n\n\nConst ScreenWidth = 800, ScreenHeight = 600 '                     for our custom screen dimensions\nDim As Integer bombX, bombY '                          incoming bomb screen position to shoot down\nDim As Single bombDX, bombDY '                  DX and DY mean change in X position and Y position\nDim As Integer missileX, missileY '                                               missile position\nDim As Single missileDX, missileDY '                            change X and Y of Missile position\nDim As Integer hits, misses '                                                score hits and misses\nDim As Integer mouseDistanceX, mouseDistanceY '       for calculations of missile DX, DY direction\nDim As Single distance '                                                                     ditto\nDim As Integer radius '                                      drawing hits with target like circles\nDim As Integer boolean '                         to shorten the code line with a bunch of OR tests\n\n\nScreen _NewImage(ScreenWidth, ScreenHeight, 32) ' sets up a graphics screen with custom dimensions\n'                                          the 32 is for _RGB32(red, green, blue, alpha) coloring.\n'\n'_ScreenMove 250, 60 ' out for QBJS   centers screen in my laptop, you may need different numbers\n\nWhile 1 '                                             reset game and start a round with a bomb falling\n    Cls\n    bombX = Rnd * ScreenWidth '                                starts bomb somewhere across the screen\n    bombY = 0 '                                                           starts bomb at top of screen\n    bombDX = Rnd * 6 - 3 '                                  pick rnd dx = change in x between -3 and 3\n    bombDY = Rnd * 3 + 3 '                 pick rnd dy = change in y between 3 and 6,  > 0 for falling\n    missileX = ScreenWidth / 2 '                                  missile base at middle across screen\n    missileY = ScreenHeight - 4 '   missile launch point at missile base is nearly at bottom of screen\n    missileDX = 0 '                           missile is not moving awaiting mouse click for direction\n    missileDY = 0 '                                                                              ditto\n    distance = 0 '                                             distance of mouse click to missile base\n\n    Do\n        'what's the score?\n        _Title \"Click mouse to intersect incoming   Hits:\" + Str$(hits) + \", misses:\" + Str$(misses)\n        _PrintString (400, 594), \"^\" '                                 draw missle base = launch point\n        While _MouseInput: Wend '                                             poll mouse to get update\n        If _MouseButton(1) Then '               the mouse was clicked calc the angle from missile base\n            mouseDistanceX = _MouseX - missileX\n            mouseDistanceY = _MouseY - missileY\n\n            'distance = (mouseDistanceX ^ 2 + mouseDistanceY ^ 2) ^ .5\n            '                   rewrite the above line using _Hypot() which is hidden distance forumla\n            distance = _Hypot(mouseDistanceX, mouseDistanceY)\n\n            missileDX = 5 * mouseDistanceX / distance\n            missileDY = 5 * mouseDistanceY / distance\n        End If\n\n        missileX = missileX + missileDX '                                      update missile position\n        missileY = missileY + missileDY '                                                        ditto\n        bombX = bombX + bombDX '                                                  update bomb position\n        bombY = bombY + bombDY '                                                                 ditto\n\n        '                     I am about to use a boolean variable to shorten a very long IF code line\n        '                                 boolean is either 0 or -1 when next 2 statements are execued\n        '                                            -1/0 or True/False is everything still in screen?\n        boolean = missileX < 0 Or missileY < 0 Or bombX < 0 Or bombY < 0\n        boolean = boolean Or missileX > ScreenWidth Or bombX > ScreenWidth Or bombY > ScreenHeight\n        If boolean Then '                                                       done with this boolean\n            '   reuse boolean to shorten another long code line checking if bomb and missile in screen\n            boolean = bombY > ScreenHeight Or missileX < 0 Or missileY < 0 Or missileX > ScreenWidth\n            If boolean Then misses = misses + 1\n            Exit Do\n        End If\n\n        '     if the distance between missle and bomb < 20 pixels then the missile got the bomb, a hit\n        'If ((missileX - bombX) ^ 2 + (missileY - bombY) ^ 2) ^ .5 < 20 Then '  show  strike as target\n        '                       rewrite the above line using _Hypot() which is hidden distance forumla\n        If _Hypot(missileX - bombX, missileY - bombY) < 20 Then\n\n            For radius = 1 To 20 Step 4 '                        draw concetric circles to show strike\n                Circle ((missileX + bombX) / 2, (missileY + bombY) / 2), radius\n                _Limit 60\n            Next\n            hits = hits + 1 '                                                    add hit to hits score\n            Exit Do\n        Else\n            Circle (missileX + 4, missileY), 2, &HFFFFFF00 '+4 center on ^ base  draw    missle yellow\n            Circle (bombX, bombY), 2, &HFF0000FF '                                      draw bomb blue\n        End If\n        _Limit 20\n    Loop\nWend\n\n"
  },
  {
    "input": "Starfield simulation",
    "output": "'Option _Explicit ' try for QBJS 2023-08-26\n_Title \"Starfield Simulation\" ' a mod of a codehunter post\n\nDim Shared Width As Integer\nDim Shared Height As Integer\nDim Shared CenterX As Integer\nDim Shared CenterY As Integer\n\nCreateCanvas 600, 600\nWindow (-Width, -Height)-(Width, Height)\n\n' Translate the Star Class into a UDT (User Defined Type)\nType newStar\n    x As Single\n    y As Single\n    z As Single\n    pz As Single\nEnd Type\n\n' Define how many Stars\nDim Shared starCount As Integer\nDim As Integer i, done\nDim sx, sy, px, py\n\nstarCount = 800\n\n' Setup the Stars\nDim Shared Stars(starCount) As newStar\n\nFor i = 1 To starCount\n    Stars(i).x = p5random(-Width, Width)\n    Stars(i).y = p5random(-Height, Height)\n    Stars(i).z = p5random(0, Width)\n    Stars(i).pz = Stars(i).z\nNext\n\nDim Shared Speed As Integer\nSpeed = 5\n\nDo\n    _Limit 60\n\n    Line (-_Width, -_Height)-(Width - 1, Height - 1), _RGBA32(0, 0, 0, 30), BF\n\n    For i = 1 To starCount\n        Stars(i).z = Stars(i).z - Speed\n\n        If Stars(i).z < 1 Then\n            Stars(i).x = p5random(-Width, Width)\n            Stars(i).y = p5random(-Width, Height)\n\n            Stars(i).z = Width\n            Stars(i).pz = Stars(i).z\n        End If\n\n        sx = map(Stars(i).x / Stars(i).z, 0, 1, 0, Width)\n        sy = map(Stars(i).y / Stars(i).z, 0, 1, 0, Height)\n        Circle (sx, sy), map(Stars(i).z, 0, Width, 2, 0)\n\n        px = map(Stars(i).x / Stars(i).pz, 0, 1, 0, Width)\n        py = map(Stars(i).y / Stars(i).pz, 0, 1, 0, Height)\n        Stars(i).pz = Stars(i).z\n        Line (px, py)-(sx, sy)\n    Next\n\n    _Display\nLoop Until done\n\n' p5.js Functions\nFunction map (value, minRange, maxRange, newMinRange, newMaxRange)\n    map = ((value - minRange) / (maxRange - minRange)) * (newMaxRange - newMinRange) + newMinRange\nEnd Function\n\nFunction p5random (mn, mx)\n    If mn > mx Then\n        Swap mn, mx\n    End If\n\n    p5random = Rnd * (mx - mn) + mn\nEnd Function\n\nSub CreateCanvas (x As Integer, y As Integer)\n    ' Define the screen\n    Width = x\n    Height = y\n\n    ' Center of the screen\n    CenterX = x \\ 2\n    CenterY = y \\ 2\n\n    ' Create the screen\n    Screen _NewImage(Width, Height, 32)\nEnd Sub\n"
  },
  {
    "input": "Screensaver of orbs pulsating in space",
    "output": "\n'=============\n'SpaceOrbs2.bas\n'=============\n'Screesaver of Orbs pulsating in space\n'Coded by Dav for QB64-PE, AUGUST/2023\n\n'v2 - added scrolling stars background\n'  - orbs get new x/y position after shrinking away\n'  - had to change alpha values of plasma cloud and orbs,\n'    because of scrolling stars background.  It's different.\n'  - Uses _PUTIMAGE screen trick to blur final _DISPLAY\n'Option _Explicit\nDim orbs, OrbSizeMin, OrbSizeMax, i, x, y, back&, backx, t, b, y2, x2, clr, r, g, tmpback&\n\nRandomize Timer\n\nScreen _NewImage(1000, 640, 32)\n\n\n'=== orb settings\n\norbs = 60 'number of orbs on screen\nOrbSizeMin = 5 'smallest size an orb can get\nOrbSizeMax = 60 'largest size an orb can get\n\nDim OrbX(orbs), OrbY(orbs), OrbSize(orbs), OrbGrowth(orbs), OrbDir(orbs)\n\n\n'=== generate some random orb values\n\nFor i = 1 To orbs\n    OrbX(i) = Rnd * _Width 'x pos\n    OrbY(i) = Rnd * _Height 'y pos\n    OrbSize(i) = OrbSizeMin + (Rnd * (OrbSizeMax - OrbSizeMin)) 'orb size\n    OrbGrowth(i) = Int(Rnd * 2) 'way orb is changing, 0=shrinking, 1=growing\n    OrbDir(i) = Int(Rnd * 4) 'random direction orb can drift (4 different ways)\nNext\n\n\n'=== make a space background image\n\nFor i = 1 To 100000\n    PSet (Rnd * _Width, Rnd * _Height), _RGBA(0, 0, Rnd * 255, Rnd * 225)\nNext\nFor i = 1 To 1000\n    x = Rnd * _Width: y = Rnd * _Height\n    Line (x, y)-(x + Rnd * 3, y + Rnd * 3), _RGBA(192, 192, 255, Rnd * 175), BF\nNext\n\n\n'=== grab screen image for repeated use\n\nback& = _CopyImage(_Display)\n\nbackx = 0\n\nDo\n\n    '=== scroll starry background first\n    _PutImage (backx, 0)-(backx + _Width, _Height), back&\n    _PutImage (backx - _Width, 0)-(backx, _Height), back&\n    backx = backx + 4\n    If backx >= _Width Then backx = 0\n\n\n    '=== draw moving plasma curtain next\n\n    t = Timer\n    For x = 0 To _Width Step 3\n        For y = 0 To _Height Step 3\n            b = Sin(x / (_Width / 2) + t + y / (_Height / 2))\n            b = b * (Sin(1.1 * t) * (_Height / 2) - y + (_Height / 2))\n            Line (x, y)-Step(2, 2), _RGBA(b / 3, 0, b, 50), BF\n        Next\n        t = t + .085\n    Next\n\n\n    '=== now process all the orbs\n\n    For i = 1 To orbs\n\n        '=== draw orb on screen\n\n        For y2 = OrbY(i) - OrbSize(i) To OrbY(i) + OrbSize(i) Step 3\n            For x2 = OrbX(i) - OrbSize(i) To OrbX(i) + OrbSize(i) Step 3\n                'make gradient plasma color\n                If Sqr((x2 - OrbX(i)) ^ 2 + (y2 - OrbY(i)) ^ 2) <= OrbSize(i) Then\n                    clr = (OrbSize(i) - (Sqr((x2 - OrbX(i)) * (x2 - OrbX(i)) + (y2 - OrbY(i)) * (y2 - OrbY(i))))) / OrbSize(i)\n                    r = Sin(6.005 * t) * OrbSize(i) - y2 + OrbSize(i) + 255\n                    g = Sin(3.001 * t) * OrbSize(i) - x2 + OrbSize(i) + 255\n                    b = Sin(2.001 * x2 / OrbSize(i) + t + y2 / OrbSize(i)) * r + 255\n                    Line (x2, y2)-Step(2, 2), _RGBA(clr * r, clr * g, clr * b, 30 + Rnd * 25), BF\n                End If\n            Next\n        Next\n\n        '=== change orb values\n\n        'if orb is shrinking, subtract from size, else add to it\n        If OrbGrowth(i) = 0 Then OrbSize(i) = OrbSize(i) - 1 Else OrbSize(i) = OrbSize(i) + 1\n        'if orb reaches maximum size, switch growth value to 0 to start shrinking now\n        If OrbSize(i) >= OrbSizeMax Then OrbGrowth(i) = 0\n        'if orb reaches minimum size, switch growth value to 1 to start growing now\n        'and reset x/y pos\n        If OrbSize(i) <= OrbSizeMin Then\n            OrbGrowth(i) = 1\n            OrbX(i) = Rnd * _Width\n            OrbY(i) = Rnd * _Height\n        End If\n        'creates the shakiness. randomly adjust x/y positions by +/-3 each\n        If Int(Rnd * 2) = 0 Then OrbX(i) = OrbX(i) + 3 Else OrbX(i) = OrbX(i) - 3\n        If Int(Rnd * 2) = 0 Then OrbY(i) = OrbY(i) + 3 Else OrbY(i) = OrbY(i) - 3\n\n        'drift orb in  1 of 4 directions we generated, and +x,-x,+y,-y to it.\n        If OrbDir(i) = 0 Then OrbX(i) = OrbX(i) + 2 'drift right\n        If OrbDir(i) = 1 Then OrbX(i) = OrbX(i) - 2 'drift left\n        If OrbDir(i) = 2 Then OrbY(i) = OrbY(i) + 2 'drift down\n        If OrbDir(i) = 3 Then OrbY(i) = OrbY(i) - 2 'drift up\n\n        'below handles if ball goes off screen, let it dissapear completely\n        If OrbX(i) > _Width + OrbSize(i) Then OrbX(i) = -OrbSize(i)\n        If OrbX(i) < -OrbSize(i) Then OrbX(i) = _Width + OrbSize(i)\n        If OrbY(i) > _Height + OrbSize(i) Then OrbY(i) = -OrbSize(i)\n        If OrbY(i) < -OrbSize(i) Then OrbY(i) = _Height + OrbSize(i)\n\n    Next\n\n    '== screen blur trick to make it more misty looking\n\n    tmpback& = _CopyImage(_Display)\n    '_SetAlpha 50, , tmpback&\n    _PutImage (-1, 0), tmpback&: _PutImage (1, 0), tmpback&\n    _PutImage (0, -1), tmpback&: _PutImage (0, 1), tmpback&\n    _PutImage (-1, -1), tmpback&: _PutImage (1, -1), tmpback&\n    _FreeImage tmpback&\n\n    _Display\n\n    _Limit 15\n\nLoop Until InKey$ <> \"\"\n\n"
  },
  {
    "input": "Draws balls with various textures",
    "output": "'===========\n'BALLSUB.BAS v1.1\n'===========\n'Simple Ball SUB that draws balls of different textures.\n'Coded by Dav, AUGUST/2023\n\n'New for v1.1: - Added 3 textures: Voronoi, checkered, fabric.\n\n'Ball types: Solid, Gradient, planet, plasma, noisey, striped,\n'            plasma mixed, Voronoi pattern, checkered, fabric.\n\n\n\nRANDOMIZE TIMER\n\nSCREEN _NEWIMAGE(1000, 600, 32)\n\nDO\n    'show all kinds of balls\n    ball INT(RND * 10), RND * _WIDTH, RND * _HEIGHT, RND * 300 + 25, RND * 255, RND * 255, RND * 255, 100 + RND * 155\n    _LIMIT 10\nLOOP UNTIL INKEY$ <> \"\"\n\n\nSUB ball (kind, x, y, size, r, g, b, a)\n    'SUB by Dav that draws many types of filled balls (circles).\n    'Not super fast, but small and easy to add to your programs.\n\n    'kind=0 (Gradient)\n    'kind=1 (noisey)\n    'kind=2 (planets)\n    'kind=3 (plasma)\n    'kind=4 (striped)\n    'kind=5 (plasma mixed)\n    'kind=6 (solid, non gradient)\n    'kind-7 (voronoi pattern)\n    'kind=8 (checkered pattern)\n    'kind=9 (fabric)\n\n    'The DIMs makes the SUB QBJS compatible\n    '(these are not needed if using QB64)\n    DIM displayStatus%%, t, y2, x2, clr, noise, dx, dy, dis\n    DIM scale, xf, yf, cell, cellsize, closest, min, p, Points\n\n\n    '=== check for and do special drawing kinds first\n\n    'fabric pattern\n    IF kind = 9 THEN\n        scale = size / 30\n        IF scale < 3 THEN scale = 3\n        IF scale > 9 THEN scale = 9\n        FOR y2 = y - size TO y + size\n            FOR x2 = x - size TO x + size\n                IF SQR((x2 - x) ^ 2 + (y2 - y) ^ 2) <= size THEN\n                    clr = (size - (SQR((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y)))) / size\n                    noise = INT(RND * 100)\n                    xf = x2 + INT(SIN(((x2 - size) / scale)) * scale)\n                    yf = y2 + INT(COS(((y2 - size) / scale)) * scale)\n                    PSET (xf, yf), _RGBA(clr * r - noise, clr * g - noise, clr * b - noise, a)\n                END IF\n            NEXT\n        NEXT\n        EXIT SUB\n    END IF\n\n    'checkered ball\n    IF kind = 8 THEN\n        cellsize = INT(size / 4)\n        IF cellsize < 5 THEN cell = 5\n        FOR y2 = y - size TO y + size\n            FOR x2 = x - size TO x + size\n                IF SQR((x2 - x) ^ 2 + (y2 - y) ^ 2) <= size THEN\n                    clr = (size - (SQR((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y)))) / size\n                    IF x2 MOD cellsize < (cellsize / 2) THEN\n                        IF y2 MOD cellsize < (cellsize / 2) THEN\n                            PSET (x2, y2), _RGBA(clr * r - noise, clr * g - noise, clr * b - noise, a)\n                        ELSE\n                            PSET (x2, y2), _RGBA(1, 1, 1, a)\n                        END IF\n                    ELSE\n                        IF y2 MOD cellsize < (cellsize / 2) THEN\n                            PSET (x2, y2), _RGBA(1, 1, 1, a)\n                        ELSE\n                            PSET (x2, y2), _RGBA(clr * r - noise, clr * g - noise, clr * b - noise, a)\n                        END IF\n                    END IF\n\n                END IF\n            NEXT\n        NEXT\n        EXIT SUB\n    END IF\n\n    'Voronoi pattern\n    IF kind = 7 THEN\n        Points = INT(size / 25)\n        IF Points < 7 THEN Points = 7\n        DIM PointX(Points), PointY(Points), PointR(Points), PointG(Points), PointB(Points)\n        FOR p = 1 TO Points\n            PointX(p) = x + (RND * size * 2) - (size)\n            PointY(p) = y + (RND * size * 2) - (size)\n            PointR(p) = RND * 255\n            PointG(p) = RND * 255\n            PointB(p) = RND * 255\n        NEXT\n        FOR x2 = x - size TO x + size\n            FOR y2 = y - size TO y + size\n                IF SQR((x2 - x) ^ 2 + (y2 - y) ^ 2) <= size THEN\n                    min = SQR((x2 - PointX(1)) ^ 2 + (y2 - PointY(1)) ^ 2)\n                    closest = 1\n                    FOR p = 2 TO Points\n                        dis = SQR((x2 - PointX(p)) ^ 2 + (y2 - PointY(p)) ^ 2)\n                        IF dis < min THEN min = dis: closest = p\n                    NEXT\n                    PSET (x2, y2), _RGBA(PointR(closest) - min, PointG(closest) - min, PointB(closest) - min, a)\n                END IF\n            NEXT\n        NEXT\n        EXIT SUB\n    END IF\n\n\n    '==== All other ball textures follow (they use same drawing method)\n\n    'get current display status to restore later\n    displayStatus%% = _AUTODISPLAY\n\n    'turn off screen updates while we draw\n    _DISPLAY\n\n    t = TIMER\n    FOR y2 = y - size TO y + size\n        FOR x2 = x - size TO x + size\n            IF SQR((x2 - x) ^ 2 + (y2 - y) ^ 2) <= size THEN\n\n                clr = (size - (SQR((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y)))) / size\n                SELECT CASE kind\n                    CASE 1: 'noisey (grainy)\n                        noise = RND * 255\n                    CASE 2: 'planet\n                        noise = 20 * SIN((x2 + y2) / 30) + 10 * SIN((x2 + y2) / 10)\n                    CASE 3: 'plasma\n                        r = (SIN(x2 / (size / 4)) + SIN(y2 / size / 2)) * 128 + 128\n                        g = (SIN(x2 / (size / 6)) + COS(y2 / (size / 4))) * 128 + 128\n                        b = (COS(x2 / (size / 4)) + SIN(y2 / (size / 6))) * 128 + 128\n                    CASE 4: 'striped\n                        dx = x2 - size: dy = y2 - size\n                        dis = SQR(dx * dx + dy * dy)\n                        r = SIN(dis / 5) * 255\n                        g = COS(dis / 25) * 255\n                        b = 255 - SIN(dis / 50) * 255\n                    CASE 5: 'plasma mix with gradient & noise\n                        noise = INT(RND * 50)\n                        r = SIN(6.005 * t) * size - y2 + size + 255\n                        g = SIN(3.001 * t) * size - x2 + size + 255\n                        b = SIN(2.001 * x2 / size + t + y2 / size) * r + 255\n                        t = t + .00195\n                    CASE ELSE: 'solid & gradient (no noise)\n                        noise = 0\n                END SELECT\n                IF kind = 6 THEN\n                    'if solid color only, then...\n                    PSET (x2, y2), _RGBA(r, g, b, a)\n                ELSE\n                    '...else, with noise & gradient color aware\n                    PSET (x2, y2), _RGBA(clr * r - noise, clr * g - noise, clr * b - noise, a)\n                END IF\n            END IF\n        NEXT\n    NEXT\n\n    'show the ball on the screen\n    _DISPLAY\n\n    'If autodislay was previously on, turn it back on\n    IF displayStatus%% = 1 THEN _AUTODISPLAY\n\nEND SUB\n"
  },
  {
    "input": "Particle Fountain",
    "output": "'Option _Explicit\n_Title \"Particle Fountain\"\nConst nP = 30000\nType particle\n    x As Single\n    y As Single\n    dx As Single\n    dy As Single\n    r As Single\n    c As _Unsigned Long\nEnd Type\nDim Shared p(nP) As particle\nScreen _NewImage(800, 600, 32)\nDim As Long i, lp\nFor i = 0 To nP\n    new i\nNext\nDo\n    Cls\n    If lp < nP Then\n        lp = lp + 10\n    End If\n    For i = 0 To lp\n        p(i).dy = p(i).dy + .1\n        p(i).x = p(i).x + p(i).dx\n        p(i).y = p(i).y + p(i).dy\n        If p(i).x < 0 Or p(i).x > _Width Then\n            new i\n        End If\n        If p(i).y > _Height And p(i).dy > 0 Then\n            p(i).dy = -.75 * p(i).dy\n            p(i).y = _Height - 5\n        End If\n        'Circle (p(i).x, p(i).y), p(i).r, p(i).c\n        PSet (p(i).x, p(i).y), p(i).c\n    Next\n    _Limit 100\nLoop\n\nSub new (i)\n    p(i).x = _Width / 2 + Rnd * 20 - 10\n    p(i).y = _Height + Rnd * 5\n    p(i).dx = Rnd * 1 - .5\n    p(i).dy = -10\n    p(i).r = Rnd * 3\n    p(i).c = _RGB32(100 * Rnd + 155, 100 * Rnd + 155, 200 + Rnd * 55)\nEnd Sub\n\n"
  },
  {
    "input": "Fun with Sin Waves",
    "output": "dim w, h, pi\npi = 4*atn(1)\nw = 640\nh = 480\nscreen _newimage(w, h, 32)\ndim i, t, x, y\nt = 0\ndo\n    t = t+0.1\n    cls\n    for i=1 to 4\n        for x=0 to w\n            y = 100*sin(pi*x/w)*sin(3*pi*x/w + t + i*t*pi*0.01)\n            pset (x, h/2 - y)\n        next\n    next\n    _limit 60\nloop"
  },
  {
    "input": "The Hypotrochoid Show",
    "output": "Import Gfx From \"lib/graphics/2d.bas\"\n_Title \"The Hypotrochoid Show\" 'for QB64 B+ 2019-07-18\nConst xmax = 700, ymax = 700\nScreen _NewImage(xmax, ymax, 32)\nDim As _Unsigned Long c2\nDim xc, yc, r, st, n, m, a, xReturn, yreturn\nc2~& = &HFFBB0000\nxc = xmax / 2: yc = ymax / 2: r = yc * .5: st = 1 / (2 * _Pi * r)\nn = 0: m = 3\nWhile _KeyDown(27) = 0\n    m = m + 1\n    For n = 5 To 30 Step .05\n        Cls\n        For a = 0 To 2 * _Pi Step st\n            xReturn = xc + r * (Cos(a) + Cos(n * a) / 3 + Sin(m * a) / 2)\n            yreturn = yc + r * (Sin(a) + Sin(n * a) / 3 + Cos(m * a) / 2)\n            Gfx.FillCircle xReturn, yReturn, 10, _RGB32(0, 200, 0, n)\n            Gfx.FillCircle xReturn, yReturn, 4, c2~&\n        Next\n        Print \"m = \"; m; \"  n = \"; n\n        _Display\n        _limit 100\n    Next\nWend\n"
  },
  {
    "input": "Rotating Tetraeder",
    "output": "'based on a YaBASIC example, ported by William33\n'the FillTriangle code is based on a Turbo Pascal example\n'Option _Explicit\n\nDim n, p, phi, dphi, psi, dpsi, r, g, dr, dg, db, p2, b, dm, m, p1, p3, n1, n2, n3, sp\n\n_Title \"Tetraeder\"\n\nScreen _NewImage(1280, 720, 32)\n\nDim opoints(4, 3)\nRestore points\nFor n = 1 To 4: For p = 1 To 3: Read opoints(n, p): Next p: Next n\n\nDim triangles(4, 3)\nRestore triangles\nFor n = 1 To 4: For p = 1 To 3: Read triangles(n, p): Next p: Next n\n\nphi = 0: dphi = 0.1: psi = 0: dpsi = 0.05\nDim points(4, 3)\n\nr = 60: g = 20\ndr = 0.5: dg = 1.2: db = 3\nDo\n    _Limit 60\n    Cls\n    phi = phi + dphi\n    psi = psi + dpsi\n    For n = 1 To 4\n        points(n, 1) = opoints(n, 1) * Cos(phi) - opoints(n, 2) * Sin(phi)\n        points(n, 2) = opoints(n, 2) * Cos(phi) + opoints(n, 1) * Sin(phi)\n        p2 = points(n, 2) * Cos(psi) - opoints(n, 3) * Sin(psi)\n        points(n, 3) = opoints(n, 3) * Cos(psi) + points(n, 2) * Sin(psi)\n        points(n, 2) = p2\n    Next n\n\n    r = r + dr\n    If (r < 0 Or r > 60) Then dr = -dr\n    g = g + dg\n    If (g < 0 Or g > 60) Then dg = -dg\n    b = b + db\n    If (b < 0 Or b > 60) Then db = -db\n    dm = dm + 0.01\n    m = 120 - 80 * Sin(dm)\n    For n = 1 To 4\n        p1 = triangles(n, 1)\n        p2 = triangles(n, 2)\n        p3 = triangles(n, 3)\n        n1 = points(p1, 1) + points(p2, 1) + points(p3, 1)\n        n2 = points(p1, 2) + points(p2, 2) + points(p3, 2)\n        n3 = points(p1, 3) + points(p2, 3) + points(p3, 3)\n        If (n3 > 0) Then\n            sp = n1 * 0.5 - n2 * 0.7 - n3 * 0.6\n            Color _RGB32(Int(60 + r + 30 * sp) Mod 256, Int(60 + g + 30 * sp) Mod 256, Int(60 + b + 30 * sp) Mod 256)\n            FillTriangle Int(_Width / 2) + m * points(p1, 1), Int(_Height / 2) + m * points(p1, 2), Int(_Width / 2) + m * points(p2, 1), Int(_Height / 2) + m * points(p2, 2), Int(_Width / 2) + m * points(p3, 1), Int(_Height / 2) + m * points(p3, 2)\n        End If\n    Next n\n    _Display\n\nLoop Until InKey$ = Chr$(27)\n\nSystem\n\npoints:\nData -1,-1,+1,+1,-1,-1,+1,+1,+1,-1,+1,-1\ntriangles:\nData 1,2,4,2,3,4,1,3,4,1,2,3\n\n\nSub FillTriangle (xa As Integer, ya As Integer, xb As Integer, yb As Integer, xc As Integer, yc As Integer)\n    Dim y1 As Long, y2 As Long, y3 As Long, x1 As Long, x2 As Long, x3 As Long\n    Dim dx12 As Long, dx13 As Long, dx23 As Long\n    Dim dy12 As Long, dy13 As Long, dy23 As Long, dy As Long\n    Dim a As Long, b As Long\n    If ya = yb Then\n        yb = yb + 1\n    End If\n    If ya = yc Then\n        yc = yc + 1\n    End If\n    If yc = yb Then\n        yb = yb + 1\n    End If\n    If (ya <> yb) And (ya <> yc) And (yc <> yb) Then\n        If (ya > yb) And (ya > yc) Then\n            y1 = ya: x1 = xa\n            If yb > yc Then\n                y2 = yb: x2 = xb\n                y3 = yc: x3 = xc\n            Else\n                y2 = yc: x2 = xc\n                y3 = yb: x3 = xb\n            End If\n        Else\n            If (yb > ya) And (yb > yc) Then\n                y1 = yb: x1 = xb\n                If ya > yc Then\n                    y2 = ya: x2 = xa\n                    y3 = yc: x3 = xc\n                Else\n                    y2 = yc: x2 = xc\n                    y3 = ya: x3 = xa\n                End If\n            Else\n                If (yc > yb) And (yc > ya) Then\n                    y1 = yc: x1 = xc\n                    If yb >= ya Then\n                        y2 = yb: x2 = xb\n                        y3 = ya: x3 = xa\n                    Else\n                        y2 = ya: x2 = xa\n                        y3 = yb: x3 = xb\n                    End If\n                End If\n            End If\n        End If\n        dx12 = x2 - x1: dy12 = y2 - y1\n        dx23 = x3 - x2: dy23 = y3 - y2\n        dx13 = x3 - x1: dy13 = y3 - y1\n        a = x2 - ((y2 - y3 + dy23) * dx23) / dy23\n        b = x3 + (-dy23 * dx13) / (dy13)\n        If (a < b) Then\n            Line (a, y2)-(b, y2)\n            For dy = 0 To -dy23 - 1\n                a = x2 + ((dy23 + dy) * dx23) / dy23\n                b = x3 + (dy * dx13) / (dy13)\n                Line (a, dy + y3)-(b, dy + y3)\n            Next\n            For dy = -dy23 + 1 To -dy13\n                a = x2 + ((dy23 + dy) * dx12) / dy12\n                b = x3 + (dy * dx13) / (dy13)\n                Line (a, dy + y3)-(b, dy + y3)\n\n            Next\n        Else\n            Line (b, y2)-(a, y2)\n            For dy = 0 To -dy23 - 1\n                a = x2 + ((dy23 + dy) * dx23) / dy23\n                b = x3 + (dy * dx13) / (dy13)\n                Line (a, dy + y3)-(b, dy + y3)\n            Next\n            For dy = -dy23 + 1 To -dy13\n                a = x2 + ((dy23 + dy) * dx12) / dy12\n                b = x3 + (dy * dx13) / (dy13)\n                Line (a, dy + y3)-(b, dy + y3)\n            Next\n        End If\n    End If\n\nEnd Sub\n"
  },
  {
    "input": "Demonstration of creating HTML elements with the QBJS Dom Library",
    "output": "Import Dom From \"lib/web/dom.bas\"\n\nDom.Container().style.overflow = \"scroll\"\nDom.Container().style.textAlign = \"left\"\nDom.Container().style.backgroundColor = \"#fff\"\nDom.GetImage(0).style.display = \"none\"\nDim Shared c\nc = Dom.Create(\"div\")\nc.style.padding = \"20px\"\nc.style.color = \"#333\"\nc.style.float = \"left\"\n\nDom.Create \"h1\", c, \"Heading 1\"\nDom.Create \"h2\", c, \"Heading 2\"\nDom.Create \"h3\", c, \"Heading 3\"\nDom.Create \"h4\", c, \"Heading 4\"\nDom.Create \"h5\", c, \"Heading 5\"\nDom.Create \"h6\", c, \"Heading 6\"\n\nDom.Create \"p\", c, \"This is content in a paragraph (p) tag.\"\nDom.Create \"b\", c, \"Bold content\": LineBreak 2\nDom.Create \"strong\", c, \"Strong content\": LineBreak 2\nDom.Create \"i\", c, \"Italic text\": LineBreak 2\nDom.Create \"em\", c, \"Emphasis text\": LineBreak 2\nDom.Create \"u\", c, \"Underlined text\": LineBreak 2\nDom.Create \"q\", c, \"This is a quote\": LineBreak 2\nDom.Create \"div\", c, \"This content is in a div\"\nDom.Create \"pre\", c, \"This is preformatted text. \" + Chr(10) + \"It respects newlines.\"\n\nc = Dom.Create(\"div\")\nc.style.padding = \"20px\"\nc.style.color = \"#333\"\nc.style.float = \"left\"\n\nDom.Create \"div\", c, \"Here's an image:\"\nDim img\nimg = Dom.Create(\"img\", c)\nimg.src = \"https://github.com/boxgaming/gx/raw/main/project/boxgaming.png\"\nimg.width = 200\nLineBreak 3\n\nDom.Create \"div\", c, \"Here's an audio control:\"\nDim a\na = Dom.Create(\"audio\", c)\na.controls = \"controls\"\nDim asource\nasource = Dom.Create(\"source\", a)\nasource.src = \"https://github.com/boxgaming/gx/raw/main/samples/santa/snd/intro.mp3\"\nLineBreak 2\n\nDom.Create \"div\", c, \"Here's a video control:\"\nDim v\nv = Dom.Create(\"video\", c)\nv.controls = \"controls\"\nv.width = 360\nv.height = 240\nDim vsource\nvsource = Dom.Create(\"source\", v)\nvsource.src = \"https://sample-videos.com/video321/mp4/240/big_buck_bunny_240p_1mb.mp4\"\n\nc = Dom.Create(\"div\")\nc.style.padding = \"20px\"\nc.style.color = \"#333\"\nc.style.float = \"left\"\n\nDom.Create \"div\", c, \"Here's an iframe:\"\nDim iframe\niframe = Dom.Create(\"iframe\", c)\niframe.src = \"https://qb64.com\"\n'iframe.allow = \"accelerometer; auto-play; encrypted-media; gyroscope\"\niframe.width = 480\niframe.height = 200\n\n\nSub LineBreak (count)\n    If count = undefined Then count = 1\n    Dim i\n    For i = 1 To count\n        Dom.Create \"br\", c\n    Next i\nEnd Sub"
  },
  {
    "input": "Demonstration of creating HTML controls with the QBJS Dom Library",
    "output": "Import Dom From \"lib/web/dom.bas\"\n\nDom.Container().style.overflow = \"scroll\"\nDom.Container().style.textAlign = \"left\"\nDom.Container().style.backgroundColor = \"#fff\"\nDom.GetImage(0).style.display = \"none\"\nDim c\nc = Dom.Create(\"div\")\nc.style.padding = \"20px\"\nc.style.color = \"#333\"\nDom.Create(\"a\", c, \"Link\").href = \"#\"\nAddInput \"button\"\nAddInput \"checkbox\"\nAddInput \"color\"\nAddInput \"date\"\nAddInput \"datetime-local\"\nAddInput \"email\"\nAddInput \"file\"\nAddInput \"hidden\"\nAddInput \"image\"\nAddInput \"month\"\nAddInput \"number\"\nAddInput \"password\"\nAddInput \"radio\"\nAddInput \"range\"\nAddInput \"reset\"\nAddInput \"search\"\nAddInput \"submit\"\nAddInput \"tel\"\nAddInput \"text\"\nAddInput \"time\"\nAddInput \"url\"\nAddInput \"week\"\nDim e\ne = AddControl(\"button\", \"I'm a Button, Push Me!\")\ne = AddControl(\"textarea\", \"I'm a Text Area, you can type in here!\")\ne = AddControl(\"select\")\nDom.Create \"option\", e, \"Option 1\"\nDom.Create \"option\", e, \"Option 2\"\nDom.Create \"option\", e, \"Option 3\"\n\nFunction AddControl (t, text)\n    Dim d, s, ctrl\n    d = Dom.Create(\"div\")\n    Dom.Add d, c\n    d.style.padding = \"3px\"\n    s = Dom.Create(\"span\", d, t)\n    s.style.display = \"inline-block\"\n    s.style.width = \"150px\"\n    ctrl = Dom.Create(t, d, text)\n    AddControl = ctrl\nEnd Function\n\nSub AddInput (t)\n    Dim d, s\n    d = Dom.Create(\"div\")\n    Dom.Add d, c\n    d.style.padding = \"3px\"\n    s = Dom.Create(\"span\", d, \"input:\" + t)\n    s.style.display = \"inline-block\"\n    s.style.width = \"150px\"\n    i = Dom.Create(\"input\", d)\n    i.type = t\n    Dom.Event i, \"change\", @OnInputChange\n    If t = \"button\" Then i.value = \"I'm an Input Button, Push Me!\"\nEnd Sub\n    \nSub OnInputChange (e)\n    Dom.Alert e.target.type + \" changed: [\" + e.target.value + \"]\"\nEnd Sub\n"
  },
  {
    "input": "Demonstration of drawing to multiple image canvases and using native web controls that interact with the QB screen.",
    "output": "Import Dom From \"lib/web/dom.bas\"\n\nDim Shared c, ccount, speed, cimg\nDim i\n\nInitControls\n\nDo\n    Cls , 15\n    For i = 1 To ccount.value\n        Circle (Rnd * 620, Rnd * 380), 5 + Rnd * 50, 1 + Rnd * 14\n    Next i\n    _Limit speed.value\nLoop\n\nColor 0, 15\nLocate 13, 36\nPrint \"Game Over\"\n\nSub OnAddSquare\n    Dim x, y, size\n    x = Rnd * 180\n    y = Rnd * 80\n    size = 5 + Rnd * 50\n    _Dest cimg\n    Line (x, y)-(x+size, y+size), Rnd * 14, B\n    _Dest 0\nEnd Sub\n\nSub InitControls\n    Dim main, container\n    main = Dom.GetImage(0)\n    main.style.border = \"1px solid #ccc\"\n    container = Dom.Container\n    container.style.overflow = \"scroll\"\n    container.style.textAlign = \"left\"\n    container.style.backgroundColor = \"#fff\"\n    \n    c = Dom.Create(\"div\")\n    c.style.padding = \"20px\"\n    c.style.color = \"#333\"\n    \n    Dom.Create \"div\", c, \"This is the main screen canvas:\"\n    Dom.Add main, c\n    Dom.Create \"br\", c\n    \n    Dom.Create \"span\", c, \"Circles: \"\n    ccount = Dom.Create(\"input\", c)\n    ccount.type = \"range\"\n    ccount.min = 1\n    ccount.max = 300\n    ccount.style.width = \"250px\"\n    ccount.style.verticalAlign = \"middle\"\n    \n    Dim s\n    s = Dom.Create(\"span\", c, \"Speed: \")\n    s.style.marginLeft = \"20px\"\n    speed = Dom.Create(\"input\", c)\n    speed.type = \"range\"\n    speed.style.verticalAlign = \"middle\"\n    speed.style.width = \"250px\"  \n    speed.min = 1\n    speed.max = 60\n    speed.value = 10\n\n    Dom.Create \"br\", c\n    Dom.Create \"br\", c\n    Dom.Create \"div\", c, \"This is a second image:\"\n    cimg = _NewImage(200, 100)\n    Dim dimg\n    dimg = Dom.GetImage(cimg)\n    dimg.style.border = \"1px solid #ccc\"\n    dimg.style.backgroundColor = \"#efefef\"\n    dimg.style.marginBottom = \"5px\"\n    Dom.Add dimg, c\n    Dom.Create \"br\", c\n    Dim btn\n    btn = Dom.Create(\"button\", c, \"Add Square\")\n    Dom.Event btn, \"click\", @OnAddSquare\nEnd Sub"
  },
  {
    "input": "Fullscreen Example",
    "output": "If Not _FullScreen Then _FullScreen\n\nPrint \"This is a fullscreen test\"\nPrint \"It only works if your browser supports it\"\nPrint\nPrint \"Click anywhere to draw a circle\"\nPrint \"Press any key to quit\"\n\n\nCircle (200, 200), 100, 10\nPaint (200, 200), 1, 10\n\nDim drawing As Integer\ndrawing = 0\n\nWhile Not _KeyHIt\n    If _MouseButton(1) Then\n        If Not drawing Then\n            drawing = -1\n            Circle (_MouseX, _MouseY), Rnd * 30 + 10, Rnd * 14 + 1\n        End If\n    Else\n        drawing = 0\n        End If\n    _Limit 30\nWend\n\nIf _FullScreen Then\n    Locate 24, 1\n    Print \"Press any key to exit fullscreen\"\n    Sleep\n    _FullScreen _OFF\nEnd If"
  },
  {
    "input": "Pong-like game with a unique twist. The object of this game is to move the green paddle around with your mouse to hit the white ball and make it go into the moving goal above. At the same time, don't let the white ball hit the red ball or it will explode.",
    "output": "'Pongy - by SierraKen\n'Made on October 30, 2024\n\n'Thanks to the QB64 Phoenix Forum for the inspiration and past help.\n'Thanks also to Chat GPT for the math code.\n\n'How to play: Use Mouse to bounce the white ball and try to aim it toward the moving goal slot above without having the white ball hit the red ball.\n'You start out with 5 balls. Feel free to change the variable ball number below to your needs.\n\n\nDo\n    Dim score As Single\n    Dim ball As Single\n    Dim boxRight As Single\n    Dim boxLeft As Single\n    Dim BoxTop As Single\n    Dim BoxBottom As Single\n    Dim a As String\n    Dim ag As String\n    Dim mousex As Single\n    Dim mousey As Single\n    score = 0\n    ball = 5\n\n    ' Set box boundaries\n    boxLeft = 25\n    boxRight = 775\n    BoxTop = 25\n    BoxBottom = 575\n\n\n    Cls\n    Screen _NewImage(800, 600, 32)\n    ' Ball properties\n    Dim As Integer ballX, ballY, ballx2, bally2\n    Dim As Single angle, angle2\n    Dim As Integer speedX, speedY, speedx2, speedy2\n    ballX = (boxRight + boxLeft) / 2 ' Start in the center\n    ballY = (BoxTop + BoxBottom) / 2\n    angle = 45 ' Starting angle in degrees\n\n    ballx2 = (boxRight + boxLeft) / 2 ' Start in the center\n    bally2 = (BoxTop + BoxBottom) / 2 + 100\n    angle2 = 45 ' Starting angle in degrees\n\n\n    ' Convert angle to radians\n    Dim As Single radAngle\n    radAngle = angle * 3.14159265 / 180\n\n    Dim As Single radAngle2\n    radAngle2 = angle2 * 3.14159265 / 180\n\n    Dim goalx As Single\n    Dim goaly As Single\n    Dim goaldir As Single\n    Dim redballout As Single\n    Dim starx As Single\n    Dim stary As Single\n\n\n    ' Set speed based on angle\n    speedX = Cos(radAngle) * 5\n    speedY = Sin(radAngle) * 5\n\n    speedx2 = Cos(radAngle2) * 5\n    speedy2 = Sin(radAngle2) * 5\n\n    goalx = 325: goaly = 20\n    goaldir = 1\n    redballout = 5\n\n\n    _Title \"Pongy - by SierraKen\"\n\n    Randomize Timer\n\n    Do\n        Cls\n        a = InKey$\n        If a = Chr$(27) Then End\n        ' Draw box boundaries\n        Line (boxLeft - 5, BoxTop - 5)-(boxRight + 5, BoxBottom + 5), _RGB32(255, 255, 255), B\n        Line (goalx, goaly)-(goalx + 100, goaly), _RGB32(1, 1, 1)\n        goalx = goalx + goaldir\n        If goalx = 680 And goaldir = 1 Then goaldir = -1\n        If goalx = 20 And goaldir = -1 Then goaldir = 1\n        ' Draw the ball\n        fillCircle ballX, ballY, 10, _RGB32(255, 255, 255)\n        If redballout = 0 Then fillCircle ballx2, bally2, 20, _RGB32(255, 0, 0)\n\n        While _MouseInput: Wend\n        mousex = _MouseX\n        mousey = _MouseY\n        fillCircle mousex, mousey, 20, _RGB32(0, 255, 0)\n\n        ' Update ball position\n        ballX = ballX + speedX\n        ballY = ballY + speedY\n        If redballout = 0 Then\n            ballx2 = ballx2 + speedx2\n            bally2 = bally2 + speedy2\n        End If\n        If ballX > goalx And ballX < goalx + 100 And ballY < 26 Then\n            score = score + 1: ballX = 375: ballY = 275: speedY = -speedY\n            'For snd = 300 To 900 Step 50\n                'Sound snd, .5\n            'Next snd\n        End If\n\n        Locate 1, 20: Print \"Score: \"; score\n        Locate 1, 70: Print \"Balls: \"; ball\n\n        ' Check for collision with box boundaries\n        If ballX <= boxLeft Or ballX >= boxRight Then\n            speedX = -speedX ' Reflect on the X axis\n            If redballout > 0 Then redballout = redballout - 1\n            'Sound 600, .5\n        End If\n        If ballY <= BoxTop Or ballY >= BoxBottom Then\n            speedY = -speedY ' Reflect on the Y axis\n            If redballout > 0 Then redballout = redballout - 1\n            'Sound 600, .5\n        End If\n        If ballY > BoxBottom + .4 Then ballY = BoxBottom - 7\n        If ballY < BoxTop - .4 Then ballY = BoxTop + 7\n        If ballX > boxRight + .4 Then ballX = boxRight - 7\n        If ballX < boxLeft - .4 Then ballX = boxLeft + 7\n        'If redballout > 0 Then GoTo skip:\n        If (ballx2 <= boxLeft Or ballx2 >= boxRight) And redballout = 0 Then\n            speedx2 = -speedx2 ' Reflect on the X axis\n            'Sound 600, .5\n        End If\n        If (bally2 <= BoxTop Or bally2 >= BoxBottom) And redballout = 0 Then\n            speedy2 = -speedy2 ' Reflect on the Y axis\n            'Sound 600, .5\n        End If\n        If bally2 > BoxBottom + .4 And redballout = 0 Then bally2 = BoxBottom - 7\n        If bally2 < BoxTop - .4 And redballout = 0 Then bally2 = BoxTop + 7\n        If ballx2 > boxRight + .4 And redballout = 0 Then ballx2 = boxRight - 7\n        If ballx2 < boxLeft - .4 And redballout = 0 Then ballx2 = boxLeft + 7\n        'skip:\n\n        ' Check for collision with mouse position\n        If Sqr((mousex - ballX) ^ 2 + (mousey - ballY) ^ 2) < 40 Then\n            ' Calculate deflection angle\n            radAngle = _Atan2(ballY - mousey, ballX - mousex) ' * 180 / 3.14159265\n            'radAngle = angle * 3.14159265 / 180\n            speedX = Cos(radAngle) * 5\n            speedY = Sin(radAngle) * 5\n            ballX = ballX + speedX\n            ballY = ballY + speedY\n            'Sound 600, .5\n        End If\n\n        ' Check for collision between red ball and white ball.\n        'If redballout > 0 Then GoTo skip2:\n        If Sqr((ballx2 - ballX) ^ 2 + (bally2 - ballY) ^ 2) < 50 And redballout = 0 Then\n            fillCircle ballX, ballY, 20, _RGB32(0, 0, 0)\n            snd = 300\n            _AutoDisplay\n            starx = ballX: stary = ballY\n            For t = 1 To 25\n                fillCircle starx, stary, t * 5, _RGB32(255, 255, 255)\n                'Sound snd - t, .5\n            Next t\n            redballout = 5\n            Locate 1, 70: ball = ball - 1: Print \"Balls: \"; ball\n            If ball = 0 Then\n                _AutoDisplay\n                Locate 20, 40: Print \"G A M E  O V E R\":\n                Locate 25, 40\n                Print \"Again (Y/N)?\"\n                Do\n                    ag = InKey$\n                    If ag = \"y\" Or ag = \"Y\" Then Exit Do\n                    If ag = \"n\" Or ag = \"N\" Then End\n                Loop\n                Exit Do\n            End If\n            'Sound 600, .5\n        End If\n        'skip2:\n\n        _Display\n        _Limit 60 ' Limit the speed of the loop to 60 FPS\n    Loop\nLoop\n\n'from Steve Gold standard\nSub fillCircle (CX As Integer, CY As Integer, R As Integer, C As _Unsigned Long)\n    Dim Radius As Integer, RadiusError As Integer\n    Dim X As Integer, Y As Integer\n    Radius = Abs(R): RadiusError = -Radius: X = Radius: Y = 0\n    If Radius = 0 Then PSet (CX, CY), C: Exit Sub\n    Line (CX - X, CY)-(CX + X, CY), C, BF\n    While X > Y\n        RadiusError = RadiusError + Y * 2 + 1\n        If RadiusError >= 0 Then\n            If X <> Y + 1 Then\n                Line (CX - Y, CY - X)-(CX + Y, CY - X), C, BF\n                Line (CX - Y, CY + X)-(CX + Y, CY + X), C, BF\n            End If\n            X = X - 1\n            RadiusError = RadiusError - X * 2\n        End If\n        Y = Y + 1\n        Line (CX - X, CY - Y)-(CX + X, CY - Y), C, BF\n        Line (CX - X, CY + Y)-(CX + X, CY + Y), C, BF\n    Wend\nEnd Sub\n\n\n\n\n\n"
  },
  {
    "input": "Lunar Lander Game",
    "output": "Screen _NewImage(800, 640, 32) ' b+ Lander 30 LOC (double parking cheat) 2020-11-13\nDim gi&, kh&, h, dx, x, y\ngi& = _NewImage(800, 640, 32)\nReDim g(-100 To 200)\nDo\n    Cls: _KeyClear\n    h = 30: dx = 1: x = 3: y = 2\n    For i = -10 To 110\n        If Rnd < .5 Then h = h + Int(Rnd * 3) - 1 Else h = h\n        If h > 39 Then h = 39\n        If h < 25 Then h = 25\n        Line (i * 8, h * 16)-(i * 8 + 8, _Height), _RGB32(128), BF\n        g(i) = h\n        _PutImage , 0, gi&\n    Next\n    While 1\n        _PutImage , gi&, 0\n        Circle (x * 8 + 4, y * 16 + 8), 4, &HFF00FFFF\n        Circle (x * 8, y * 16 + 16), 4, &HFFFFFF00, 0, _Pi\n        Circle (x * 8 + 8, y * 16 + 16), 4, &HFFFFFF00, 0, _Pi\n        If y >= g(x - 1) Or y >= g(x + 1) Or y >= g(x) Or y >= 40 Or x < -5 Or x > 105 Then _PrintString (46 * 8, 2 * 16), \"Crash\": Exit While\n        If y = g(x - 1) - 1 And y = g(x + 1) - 1 Then _PrintString (46 * 8, 2 * 16), \"Landed\": Exit While\n        kh& = _KeyHit\n        If kh& = 19200 Or kh& = 97 Then dx = dx - 1\n        If kh& = 19712 Or kh& = 100 Then dx = dx + 1\n        If kh& = 18432 Or kh& = 119 Then y = y - 5\n        x = x + dx: y = y + 1\n        _Limit 2\n    Wend\n    _Delay 2\nLoop\n' 2020-11-15 fix off-sides x, add alternate keys: a=left d=right w=up  so now arrow keys or WAD system works"
  },
  {
    "input": "Flower Wheel",
    "output": "_Title \"Flower Wheel\" ' b+ 2022-04?\nScreen 12\nDim o\nDo\n    Cls\n    o = o + _Pi / 180\n    drawc _Width / 2, _Height / 2, _Width / 5, .25, 4, o\n    _Display\n    _Limit 30\nLoop\n\nSub drawc (x, y, r, a, n, o)\n    Dim t, xx, yy\n    If n > 0 Then\n        For t = 0 To _Pi(2) Step _Pi(1 / 3)\n            xx = x + r * Cos(t + o)\n            yy = y + r * Sin(t + o)\n            Circle (xx, yy), r\n            drawc xx, yy, a * r, a, n - 1, -o - n * _Pi / 180\n        Next\n    End If\nEnd Sub"
  },
  {
    "input": "Horse Race",
    "output": "'Option _Explicit\n'_Title \"Horse Race 3\" ' b+ 2023-09-12\n' fix so the the list of horse is shown in order they came in at\n\n' 2023-09-24\n' Finally got this to work what a frustrating afternoon.\n\nConst track = 100\nConst nHorses = 10\nType horse\n    col As Single\n    loops As Integer\n    colr As Integer\nEnd Type\n\nScreen _NewImage(120 * 8, (nHorses * 3 + 4) * 16, 12) ' 16 colors\nRandomize Timer\n\nDim stillRunning, i\nDim horses(1 To nHorses) As horse\nFor i = 1 To nHorses 'load color/id number for after sort\n    horses(i).colr = i\nNext\n\nstillRunning = 1\nWhile stillRunning = 1\n    stillRunning = 0 ' clear flag\n    For i = 1 To nHorses\n        If horses(i).col <= track Then\n            horses(i).loops = horses(i).loops + 1\n            stillRunning = 1 'set flag\n            horses(i).col = horses(i).col + Rnd * .25\n        End If\n    Next\n    Cls\n    Print\n    For i = 1 To nHorses\n        Color i\n        _PrintString (Int(horses(i).col) * 8, (2 * horses(i).colr) * 16), _Trim$(Str$(horses(i).loops))\n        Print\n    Next\n    Color 15\n    Locate 1, 1\n    For i = 1 To nHorses\n        _PrintString (100 * 8, (2 * i - 1) * 16), \"|\"\n        Print\n    Next\n    _Limit 60\nWend\nColor 15\n_PrintString (48 * 8, 22 * 16), \"And the results are in:\"\nQuickSort 1, nHorses, horses()\nFor i = 1 To nHorses\n    Color horses(i).colr\n    _PrintString (57 * 8, (22 + i) * 16), Str$(horses(i).colr) + \" - \" + Str$(horses(i).loops)\nNext\n\nSub QuickSort (start As Long, finish As Long, array() As horse)\n    Dim Hi As Long, Lo As Long, Middle As Single\n    Hi = finish: Lo = start\n    Middle = array(Int((Lo + Hi) / 2)).loops 'find middle of array\n    Do\n        Do While array(Lo).loops < Middle: Lo = Lo + 1: Loop\n        Do While array(Hi).loops > Middle: Hi = Hi - 1: Loop\n        If Lo <= Hi Then\n            Swap array(Lo), array(Hi)\n            Lo = Lo + 1: Hi = Hi - 1\n        End If\n    Loop Until Lo > Hi\n    If Hi > start Then Call QuickSort(start, Hi, array())\n    If Lo < finish Then Call QuickSort(Lo, finish, array())\nEnd Sub"
  },
  {
    "input": "Sliding Block Puzzle",
    "output": "'Option _Explicit\n_Title \"Sliding Blocks Puzzle\"\nRandomize Timer\nDim As Long s, q, r, c, c0, r0, i, update, solved, mc, test, mb, mx, my, bx, by\nDim As Double t\nDim flash$\n\nDo ' get from user the desired board size = s\n    Locate 1, 3: Input \"(0 quits) Enter your number of blocks per side 3 - 9 you want > \", s\n    If s = 0 Then End\nLoop Until s > 2 And s < 10\n\n' screen setup: based on the square blocks q pixels a sides\nq = 540 / s 'square size, shoot for 540 x 540 pixel board display\nScreen _NewImage(q * s + 1, q * s + 1, 32) ': _ScreenMove 360, 60\n\n'initialize board = solution\nDim board(s, s)\nFor r = 1 To s\n    For c = 1 To s\n        board(c, r) = c + (r - 1) * s\n    Next\nNext\nboard(s, s) = 0: c0 = s: r0 = s\nDo\n    For i = 0 To s ^ 5 ' mix up blocks\n        Select Case Int(Rnd * 4) + 1\n            Case 1: If c0 < s Then board(c0, r0) = board(c0 + 1, r0): board(c0 + 1, r0) = 0: c0 = c0 + 1\n            Case 2: If c0 > 1 Then board(c0, r0) = board(c0 - 1, r0): board(c0 - 1, r0) = 0: c0 = c0 - 1\n            Case 3: If r0 < s Then board(c0, r0) = board(c0, r0 + 1): board(c0, r0 + 1) = 0: r0 = r0 + 1\n            Case 4: If r0 > 1 Then board(c0, r0) = board(c0, r0 - 1): board(c0, r0 - 1) = 0: r0 = r0 - 1\n        End Select\n    Next\n    t = Timer: mc = 0: update = -1 'OK user here you go!\n    Do\n        If update Then 'display status and determine if solved\n            solved = -1: update = 0\n            For r = 1 To s\n                For c = 1 To s\n                    If board(c, r) Then\n                        If board(c, r) <> (r - 1) * s + c Then solved = 0\n                        Color _RGB32(255, 255, 255), _RGB32(0, 0, 255)\n                        Line ((c - 1) * q + 1, (r - 1) * q + 2)-(c * q - 2, r * q - 2), _RGB32(0, 0, 255), BF\n                        _PrintString ((c - 1) * q + .4 * q, (r - 1) * q + .4 * q), Right$(\" \" + Str$(board(c, r)), 2)\n                    Else\n                        If board(s, s) <> 0 Then solved = 0\n                        Color _RGB32(0, 0, 0), _RGB32(0, 0, 0)\n                        Line ((c - 1) * q, (r - 1) * q)-(c * q, r * q), , BF\n                    End If\n                Next\n            Next\n            If solved Then 'flash the Solved Report then restart\n                flash$ = \"Solved!  \" + Str$(mc) + \" Moves in \" + _Trim$(Str$(Int(Timer - t))) + \" secs.\"\n                For i = 1 To 30: _Title flash$: _Delay .1: _Title \"  \": _Delay .1: Next\n                Exit Do\n            Else\n                _Title Str$(mc) + \" Moves in \" + _Trim$(Str$(Int(Timer - t))) + \" secs.\"\n            End If\n        End If\n        While _MouseInput: Wend\n        mb = _MouseButton(1): mx = _MouseX: my = _MouseY\n        If mb And solved = 0 Then\n            _Delay .25 ' for user to release mb\n            'convert mouse position to board array (x, y) are we near empty space?\n            bx = Int(mx / q) + 1: by = Int(my / q) + 1: update = -1\n            If bx = c0 + 1 And by = r0 Then\n                board(c0, r0) = board(c0 + 1, r0): board(c0 + 1, r0) = 0: c0 = c0 + 1: mc = mc + 1\n            ElseIf bx = c0 - 1 And by = r0 Then\n                board(c0, r0) = board(c0 - 1, r0): board(c0 - 1, r0) = 0: c0 = c0 - 1: mc = mc + 1\n            ElseIf bx = c0 And by = r0 + 1 Then\n                board(c0, r0) = board(c0, r0 + 1): board(c0, r0 + 1) = 0: r0 = r0 + 1: mc = mc + 1\n            ElseIf bx = c0 And by = r0 - 1 Then\n                board(c0, r0) = board(c0, r0 - 1): board(c0, r0 - 1) = 0: r0 = r0 - 1: mc = mc + 1\n            End If\n        End If\n        _Limit 60\n    Loop\nLoop\n"
  },
  {
    "input": "Spinner 2",
    "output": "'Option _Explicit\n_Title \"Spinner 2\" 'b+ 2021-06-18\n\n' 2023-09-25 convert to QBJS\n' 2023-09-27 use FArc for Fat Arcs!\n\n$If WEB Then\n    Import G2D From \"lib/graphics/2d.bas\"\n$End If\n\nDim As Long b, r\nDim a\nDim K As _Unsigned Long\nScreen _NewImage(500, 500, 32)\n\nWhile 1\n    Cls\n    b = b + 1\n    For r = 10 To 200 Step 10 ' tsh73 suggested fix for inner most\n        a = _D2R(b * r / 20)\n        If Int(r / 10) Mod 2 Then K = &HFF009900 Else K = &HFF0000FF\n        FArc 250, 250, r, 3, a, a + _Pi, K\n    Next\n    _Display\n    _Limit 30 \nWend\n\n'2023-02-04 Fill Arc draw an arc with thickness, tested in Profile Pong 3-0\n' this sub needs sub FCirc(CX As Long, CY As Long, R As Long, C As _Unsigned Long) for dots\nSub FArc (x, y, r, thickness, RadianStart, RadianStop, c As _Unsigned Long)\n    Dim al, a\n    'x, y origin of arc, r = radius, thickness is radius of dots, c = color\n    'RadianStart is first angle clockwise from due East = 0 in Radians\n    ' arc will start drawing there and clockwise until RadianStop angle reached\n\n    If RadianStop < RadianStart Then\n        FArc x, y, r, thickness, RadianStart, _Pi(2), c\n        FArc x, y, r, 0, thickness, RadianStop, c\n    Else\n        al = _Pi * r * r * (RadianStop - RadianStart) / _Pi(2)\n        For a = RadianStart To RadianStop Step 1 / r\n            FCirc x + r * Cos(a), y + r * Sin(a), thickness, c\n        Next\n    End If\nEnd Sub\n\n' modified for QBJS AND QB64\nSub FCirc (CX As Long, CY As Long, R As Long, C As _Unsigned Long)\n\n    ' put this at top of QB64 to QBJS code\n    '$If WEB Then\n    '        import G2D From \"lib/graphics/2d.bas\"\n    '$End If\n\n\n    $If WEB Then\n        G2D.FillCircle CX, CY, R, C\n    $Else\n        Dim Radius As Long, RadiusError As Long\n        Dim X As Long, Y As Long\n        Radius = Abs(R): RadiusError = -Radius: X = Radius: Y = 0\n        If Radius = 0 Then PSet (CX, CY), C: Exit Sub\n        Line (CX - X, CY)-(CX + X, CY), C, BF\n        While X > Y\n            RadiusError = RadiusError + Y * 2 + 1\n            If RadiusError >= 0 Then\n                If X <> Y + 1 Then\n                    Line (CX - Y, CY - X)-(CX + Y, CY - X), C, BF\n                    Line (CX - Y, CY + X)-(CX + Y, CY + X), C, BF\n                End If\n                X = X - 1\n                RadiusError = RadiusError - X * 2\n            End If\n            Y = Y + 1\n            Line (CX - X, CY - Y)-(CX + X, CY - Y), C, BF\n            Line (CX - X, CY + Y)-(CX + X, CY + Y), C, BF\n        Wend\n    $End If\nEnd Sub\n"
  },
  {
    "input": "Plasma Plus Voronoi",
    "output": "$If WEB Then\n        Import G2D From \"lib/graphics/2d.bas\"\n$End If\n\n'Option _Explicit\n_Title \"Real Plasma and Voronoi, press key for new scheme\" '2023-10-19  b+ overhaul of\n'fake-voronoi-plasma.bas Dav, OCT/2023\n\nScreen _NewImage(600, 600, 32)\n'_ScreenMove 290, 40\nRandomize Timer\n\n\n' cap all shared variables\nDim Shared As Long CX, CY, Radius\n' modified by Setup\nDim Shared As Single Rd, Gn, Bl ' plasma colorsfor RGB\nDim Shared As Long NP ' voronoi pt count mod in setup\nDim Shared As Single Angle ' mod in setup\nDim Shared As Long Direction ' mod random turning clockwise or counter\n\n' local\nDim As Long x, y ' from screen\nReDim As Single px(1 To NP), py(1 To NP) ' voronoi points hopefully a spinning polygon\nDim As Single px, py, d, dist ' Voronoi calcs point and distance\nDim As Single da ' is polygon animating index\nDim As Long i, t ' indexes i a regular one and t for plasma color\nDim k$ ' polling keypresses\nDim c As _Unsigned Long ' plasma color line is soooooo long! save it in c container\n\n'once and for all time\nCX = _Width / 2: CY = _Height / 2: Radius = _Height / 3\n\nSetup\nDo\n    For y = 0 To _Height - 1 Step 4\n        For x = 0 To _Width - 1 Step 4\n            d = 100000 ' too big!\n            For i = 1 To NP\n                px = CX + Radius * Cos(i * Angle + da)\n                py = CY + Radius * Sin(i * Angle + da)\n                dist = Sqr(((x - px) ^ 2) + ((y - py) ^ 2))\n                If dist < d Then d = dist\n            Next\n            d = d + t\n            c = _RGB32(127 + 127 * Sin(Rd * d), 127 + 127 * Sin(Gn * d), 127 + 127 * Sin(Bl * d))\n            FCirc x, y, 3, c\n        Next\n    Next\n\n    'animate!\n    t = t + 2: da = da + _Pi(2 / 90) * Direction\n    k$ = InKey$\n    If Len(k$) Then\n        'If Asc(k$) = 27 Then\n            'End\n        'Else 'reset plasma\n            Setup: t = 0\n        'End If\n    End If\n    _Display\n    _Limit 30 'ha!\n'Loop Until InKey$ = Chr$(27)\nLoop Until _Keydown(27)\n\nSub Setup ' reset shared\n    'setup plasma for RGB color\n    Rd = Rnd * Rnd: Gn = Rnd * Rnd: Bl = Rnd * Rnd\n\n    'setup voronoi variables for calcs\n    NP = Int(Rnd * 10) + 3 ' 9 + 3 max    number of poly points\n    Angle = _Pi(2 / NP) ' angle between\n    Direction = 2 * Int(Rnd * 2) - 1 ' turn clockwise or the other wise\nEnd Sub\n\n' this sub for circle fill so can use code in QBJS wo mod\nSub FCirc (CX As Long, CY As Long, R As Long, C As _Unsigned Long)\n    $If WEB Then\n            G2D.FillCircle CX, CY, R, C\n    $Else\n        Dim Radius As Long, RadiusError As Long\n        Dim X As Long, Y As Long\n        Radius = Abs(R): RadiusError = -Radius: X = Radius: Y = 0\n        If Radius = 0 Then PSet (CX, CY), C: Exit Sub\n        Line (CX - X, CY)-(CX + X, CY), C, BF\n        While X > Y\n            RadiusError = RadiusError + Y * 2 + 1\n            If RadiusError >= 0 Then\n                If X <> Y + 1 Then\n                    Line (CX - Y, CY - X)-(CX + Y, CY - X), C, BF\n                    Line (CX - Y, CY + X)-(CX + Y, CY + X), C, BF\n                End If\n                X = X - 1\n                RadiusError = RadiusError - X * 2\n            End If\n            Y = Y + 1\n            Line (CX - X, CY - Y)-(CX + X, CY - Y), C, BF\n            Line (CX - X, CY + Y)-(CX + X, CY + Y), C, BF\n        Wend\n    $End If\nEnd Sub\n"
  },
  {
    "input": "Plasma Plus Voronoi 2",
    "output": "'$If WEB Then\n'        Import G2D From \"lib/graphics/2d.bas\"\n'$End If\nScreen _NewImage(400, 300, 32)\nDim Shared As Single Rd, Gn, Bl\nDim Shared As Long NP\nReDim Shared As Long Px(1 To NP), Py(1 To NP)\nDim As Long x, y\nDim As Single d, dist\nDim As Long i\nDim As Single t\nDim k$\nDim c As _Unsigned Long\nSetup\nDo\n    For y = 0 To _Height - 1 Step 4\n        For x = 0 To _Width - 1 Step 4\n            d = 10000\n            For i = 1 To NP\n                dist = _Hypot(x - Px(i), y - Py(i))\n                If dist < d Then d = dist\n            Next\n            d = d + t\n            c = _RGB32(127 + 127 * Sin(Rd * d), 127 + 127 * Sin(Gn * d), 127 + 127 * Sin(Bl * d))\n            Line (x, y)-Step(4, 4), c, BF\n        Next\n    Next\n    t = t + 1\n    k$ = InKey$\n    If Len(k$) Then\n        Setup: t = 0\n    End If\n    _Display\n    _Limit 30 'ha!\nLoop Until _KeyDown(27)\n\nSub Setup\n    Dim As Long i\n    Rd = Rnd * Rnd: Gn = Rnd * Rnd: Bl = Rnd * Rnd\n    NP = Int(Rnd * 50) + 3\n    ReDim As Long Px(1 To NP), Py(1 To NP)\n    For i = 1 To NP\n        Px(i) = Int(Rnd * _Width)\n        Py(i) = Int(Rnd * _Height)\n    Next\nEnd Sub\n"
  },
  {
    "input": "Networking (no not that kind) Color Domination Theory",
    "output": "'Option _Explicit\n_Title \"Networking 1 translation\" 'by B+ started 2018-11-13 mod 2022-05-29\nRandomize Timer\nConst xmax = 800, ymax = 600, nP = 500, rD = 35\nScreen _NewImage(xmax, ymax, 32)\n_ScreenMove 200, 60\nDim x(nP), y(nP), dx(nP), dy(nP), c(nP) As _Unsigned Long\nDim As Long i, j, k\n'initialize points\nFor i = 0 To nP\n    x(i) = Rnd * xmax: y(i) = Rnd * ymax\n    If Rnd < .5 Then dx(i) = -3 * Rnd - .5 Else dx(i) = 3 * Rnd + .5\n    If Rnd < .5 Then dy(i) = -3 * Rnd - .5 Else dy(i) = 3 * Rnd + .5\n    c(i) = _RGB32(Rnd * 200 + 55, Rnd * 200 + 55, Rnd * 200 + 55)\nNext\nWhile _KeyDown(27) = 0\n    Cls\n    For i = 0 To nP 'big show of points and triangle\n        Color c(i)\n        Line (x(i), y(i))-Step(1, 1), c(i), BF\n        For j = i + 1 To nP 'search for triangle points within 100 pixels\n            If distance(x(i), y(i), x(j), y(j)) < rD Then\n                For k = j + 1 To nP\n                    If distance(x(k), y(k), x(j), y(j)) < rD Then\n                        If distance(x(k), y(k), x(i), y(i)) < rD Then\n                            'draw 3 lines of triangle\n                            Line (x(i), y(i))-(x(j), y(j)), c(i)\n                            Line (x(k), y(k))-(x(j), y(j)), c(i)\n                            Line (x(i), y(i))-(x(k), y(k)), c(i)\n                            c(j) = c(i): c(k) = c(i)\n                        End If\n                    End If\n                Next\n            End If\n        Next\n        'update points\n        x(i) = x(i) + dx(i)\n        y(i) = y(i) + dy(i)\n        If x(i) < 0 Then x(i) = xmax + x(i)\n        If x(i) > xmax Then x(i) = x(i) - xmax\n        If y(i) < 0 Then y(i) = 0: dy(i) = dy(i) * -1\n        If y(i) > ymax Then y(i) = ymax: dy(i) = dy(i) * -1\n    Next\n    _Display\n    _Limit 200\nWend\n\nFunction distance (x1, y1, x2, y2)\n    distance = ((x1 - x2) ^ 2 + (y1 - y2) ^ 2) ^ .5\nEnd Function\n"
  },
  {
    "input": "Mouse down, drag ball, release...  Boing",
    "output": "_Title \"Mouse down, drag ball, release...  Boing\" 'B+ 2019-01-08 from\n'boing.bas for SmallBASIC 2015-07-25 MGA/B+\n'coloring mods\n\nConst xmax = 1200\nConst ymax = 700\nScreen _NewImage(xmax, ymax, 32)\n_ScreenMove 80, 20\n\nDim oldtx, oldty, boingx, boingy, tx, ty, mb, corner, s1x, s1y, x, y, sx, sy\n\nDim s(1 To 4, 1 To 2)\ns(1, 1) = 0: s(1, 2) = 50\ns(2, 1) = 0: s(2, 2) = ymax - 50\ns(3, 1) = xmax + 30: s(3, 2) = 50\ns(4, 1) = xmax + 30: s(4, 2) = ymax - 50\noldtx = 0: oldtyty = 0: da = .03\nboingx = 0: boingy = 0\nWhile 1\n    While _MouseInput: Wend\n    mb = _MouseButton(1)\n    If mb Then\n        tx = _MouseX + 20\n        ty = _MouseY\n    Else\n        tx = xmax / 2\n        ty = ymax / 2\n        If tx <> oldtx Or ty <> oldty Then\n            boingx = 3 * (tx - oldtx) / 4\n            boingy = 3 * (ty - oldty) / 4\n        Else\n            boingx = -3 * boingx / 4\n            boingy = -3 * boingy / 4\n        End If\n        tx = tx + boingx\n        ty = ty + boingy\n    End If\n    a = 0\n    oldtx = tx\n    oldty = ty\n    Cls\n    For corner = 1 To 4\n        s1x = s(corner, 1)\n        s1y = s(corner, 2)\n        dx = (tx - s1x) / 2000\n        dy = (ty - s1y) / 2000\n        x = tx - 20\n        y = ty\n        For i = 1 To 2000\n            sx = 20 * Cos(a) + x\n            sy = 20 * Sin(a) + y\n            Line (sx, sy + 5)-(sx + 4, sy + 5), _RGB32(118, 118, 118), BF\n            Line (sx, sy + 4)-(sx + 4, sy + 4), _RGB32(148, 148, 148), BF\n            Line (sx, sy + 3)-(sx + 4, sy + 3), _RGB32(238, 238, 238), BF\n            Line (sx, sy + 2)-(sx + 4, sy + 3), _RGB32(208, 208, 208), BF\n            Line (sx, sy + 1)-(sx + 4, sy + 1), _RGB32(168, 168, 168), BF\n            Line (sx, sy)-(sx + 4, sy), _RGB32(108, 108, 108), BF\n            Line (sx, sy - 1)-(sx + 4, sy - 1), _RGB32(68, 68, 68), BF\n            x = x - dx: y = y - dy\n            a = a + da\n        Next\n    Next\n    For r = 50 To 1 Step -1\n        g = (50 - r) * 5 + 5\n        Color _RGB32(g, g, g)\n        fcirc tx - 20, ty, r\n    Next\n    _Display\n    _Limit 15\nWend\n\n'Steve McNeil's  copied from his forum   note: Radius is too common a name\nSub fcirc (CX As Long, CY As Long, R As Long)\n    Dim subRadius As Long, RadiusError As Long\n    Dim X As Long, Y As Long\n\n    subRadius = Abs(R)\n    RadiusError = -subRadius\n    X = subRadius\n    Y = 0\n\n    If subRadius = 0 Then PSet (CX, CY): Exit Sub\n\n    ' Draw the middle span here so we don't draw it twice in the main loop,\n    ' which would be a problem with blending turned on.\n    Line (CX - X, CY)-(CX + X, CY), , BF\n\n    While X > Y\n        RadiusError = RadiusError + Y * 2 + 1\n        If RadiusError >= 0 Then\n            If X <> Y + 1 Then\n                Line (CX - Y, CY - X)-(CX + Y, CY - X), , BF\n                Line (CX - Y, CY + X)-(CX + Y, CY + X), , BF\n            End If\n            X = X - 1\n            RadiusError = RadiusError - X * 2\n        End If\n        Y = Y + 1\n        Line (CX - X, CY - Y)-(CX + X, CY - Y), , BF\n        Line (CX - X, CY + Y)-(CX + X, CY + Y), , BF\n    Wend\nEnd Sub"
  },
  {
    "input": "Rotating Star Mouse Chaser",
    "output": "'Option _Explicit\n_Title \"Rotating Star Mouse Chaser\" 'b+ 2022-07-19 trans from:\n'Rotating Stars Mouse Chaser.bas for SmallBASIC 0.12.0 2015-11-09 MGA/B+\n'code is based on code: mouse chaser by tsh73\n'for the Just Basic contest, November 2008, I am 7 years later\n\nConst nPoints = 20, xMax = 1280, yMax = 700, pi = _Pi\nScreen _NewImage(xMax, yMax, 32)\n_FullScreen\nDim Shared x(nPoints), y(nPoints), i, twist\n\nDim As Long mx, my\nDim As Single dx, dy, v, r, dxN, dyN\n\nFor i = 1 To nPoints\n    x(i) = xMax\n    y(i) = yMax 'set it offscreen\nNext\n\nWhile _KeyDown(27) = 0\n    Cls\n    twist = twist + .05\n    While _MouseInput: Wend\n    mx = _MouseX: my = _MouseY\n    For i = 1 To nPoints\n        If i = 1 Then 'first sees mouse\n            dx = mx - x(i)\n            dy = my - y(i)\n            v = 4\n        Else 'others see previous\n            dx = x(i - 1) - x(i)\n            dy = y(i - 1) - y(i)\n            v = 0.6 * v + 0.2 * 3 * (2 - i / nPoints) 'use 0.8 v of previous, to pick up speed\n        End If\n        r = Sqr(dx ^ 2 + dy ^ 2)\n        dxN = dx / r\n        dyN = dy / r\n        x(i) = x(i) + v * dxN\n        y(i) = y(i) + v * dyN\n        drawstar\n    Next i\n    _Display\n    _Limit 60\nWend\n\nSub drawstar ()\n    Dim sp, s, t, u, j, b, v, w\n    sp = (nPoints + 1 - i) * 2 + 3 'star points when i is low, points are high\n    s = 5 * (50 ^ (1 / nPoints)) ^ (nPoints + 1 - i)\n    t = x(i) + s * Cos(0 + twist)\n    u = y(i) + s * Sin(0 + twist)\n    For j = 1 To sp\n        b = b + Int(sp / 2) * 2 * pi / sp\n        v = x(i) + s * Cos(b + twist)\n        w = y(i) + s * Sin(b + twist)\n        Line (t, u)-(v, w), _RGB32(255, 255, 100)\n        t = v: u = w\n    Next\nEnd Sub\n"
  },
  {
    "input": "Can we find speeds for disks going in  orbits around center st they form patterns?",
    "output": "_Title \"Orbit Patterns\" 'b+ started 2020-02-25\n'can we find speeds for disks going in  orbits around center st they form patterns\n\nConst xmax = 700, ymax = 700, center = 350, P1 = _Pi, P2 = P1 * 2, PD2 = P1 * .5\nDim a, i, x, y, r\nScreen _NewImage(xmax, ymax, 32)\n_ScreenMove 300, 20\nDim rate(1 To 20)\nFor i = 1 To 20\n    rate(i) = (21 - i) / 12\nNext\nWhile _KeyDown(27) = 0\n    Cls\n    For r = 10 To 200 Step 10\n        Circle (center, center), r\n        i = Int(r / 10)\n        x = center + r * Cos(rate(i) * a)\n        y = center + r * Sin(rate(i) * a)\n        Circle (x, y), 5\n    Next\n    a = a + _Pi(2 / 120)\n    _Display\n    _Limit 30\nWend"
  },
  {
    "input": "sb spiral of chatGPT - fixed by kay63 trans and mod by me, b+ 2023-01-04",
    "output": "_Title \"sb spiral of chatGPT - fixed by kay63 trans and mod by me, b+ 2023-01-04\"\nConst xmax = 600, ymax = 600\nDim Shared pi\npi = _Pi\nDim clr As _Unsigned Long\nDim cnt, x, y, r, angle_inc, max_r, max_loops, direction\nScreen _NewImage(xmax, ymax, 32)\n\n' Set the starting position and radius of the spiral\nx = ymax / 2 - .5 * ymax / pi\ny = ymax / 2 - .5 * ymax / pi\nr = 1\n\n' Set the angle increment for each loop iteration\nangle_inc = 5\n\n' Set the maximum radius of the spiral\nmax_r = ymax / 2\n\n' Set the maximum number of loops\nmax_loops = ymax\n\n' Set the spiral rotation direction\ndirection = 1\n\n' Draw the spiral\nFor i = 1 To max_loops\n    ' Set the color for this loop iteration\n    'Color i Mod 14\n    ' Draw the spiral segment\n    Select Case i Mod 3\n        Case 0: clr = _RGB32(0, 255 * (i / 600), 128 - (i * 127 / 600))\n        Case 1: clr = _RGB32(0, 100 * i / 600 + 55, 100 * i / 600 + 55)\n        Case 2: clr = _RGB32(0, 255 * (i / 600), 128 - (i * 127 / 600))\n    End Select\n    arc x, y, r, angle_inc * i / 180 * pi, angle_inc * (i + 30) / 180 * pi, clr\n    ' Increase the radius for the next loop iteration\n    r = r + direction\n    cnt = cnt + 1\n    ' Check if the radius has reached the maximum\n    If r > max_r Then\n        ' Reverse the growing of the spiral\n        direction = -direction\n        ' Reset the radius\n        r = max_r\n    End If\n    ' move the spiral:\n    x = x + 1 / pi\n    y = y + 1 / pi\n    _Limit 60\nNext\nSleep\n\n\nSub arc (x, y, r, raStart, raStop, c As _Unsigned Long) ' this does not check raStart and raStop like arcC does\n    Dim al, a\n    'x, y origin, r = radius, c = color\n\n    'raStart is first angle clockwise from due East = 0 degrees\n    ' arc will start drawing there and clockwise until raStop angle reached\n\n    If raStop < raStart Then\n        arc x, y, r, raStart, _Pi(2), c\n        arc x, y, r, 0, raStop, c\n    Else\n        ' modified to easier way suggested by Steve\n        'Why was the line method not good? I forgot.\n        al = _Pi * r * r * (raStop - raStart) / _Pi(2)\n        For a = raStart To raStop Step 1 / al\n            PSet (x + r * Cos(a), y + r * Sin(a)), c\n        Next\n    End If\nEnd Sub"
  },
  {
    "input": "Cardioid and Beyond",
    "output": "_Title \"Cardioid and Beyond\" 'B+ 2019-02-17\nConst xmax = 700\nConst ymax = 700\nConst npoints = 200\nScreen _NewImage(xmax, ymax, 32)\nDim Shared pR, pG, pB, cN\nCX = xmax / 2\nCY = ymax / 2\nDA = _Pi(2 / npoints)\nR = CX - 10\n\nFor Mult = 0 To 100 Step .01\n    Cls\n    Color &HFFFFFFFF\n    Print \"Multiple: \";\n    'Print Using \"###.##\"; Mult\n    Print _Round(Mult*100)/100\n    If Mult = Int(Mult) Then resetPlasma\n    Circle (CX, CY), R, _RGB32(0, 128, 0)\n    For i = 1 To 200\n        x1 = CX + R * Cos(i * DA)\n        y1 = CY + R * Sin(i * DA)\n        x2 = CX + R * Cos(Mult * i * DA)\n        y2 = CY + R * Sin(Mult * i * DA)\n        changePlasma\n        Line (x1, y1)-(x2, y2)\n    Next\n    _Display\n    _Limit 30\nNext\n\nSub changePlasma ()\n    cN = cN + 1\n    Color _RGB(127 + 127 * Sin(pR * cN), 127 + 127 * Sin(pG * cN), 127 + 127 * Sin(pB * cN))\nEnd Sub\n\nSub resetPlasma ()\n    pR = Rnd ^ 2: pG = Rnd ^ 2: pB = Rnd ^ 2\nEnd Sub"
  },
  {
    "input": "Hypno Mezmerizing Thingamajig",
    "output": "'LittleProggieForB+.bas\n'By Dav, SEP/2023\n\nScreen _NewImage(800, 600, 32)\ndim w2, h2, x, w, n, t '<-- for QBJS to use\nw2 = _Width / 2: h2 = _Height / 2\nDo\n    For x = 0 To _Width Step 5\n        For y = 0 To _Height Step 5\n            n = Abs(Sin((Sqr(((x - w2) / w2) ^ 2 + ((y - h2) / h2) ^ 2) + t) * t) * 200)\n            Line (x, y)-Step(5, 5), _RGBA(Rnd * n, n, 200, 200), BF\n        Next\n    Next: t = t + (Rnd * 10 - Rnd * 20)\n    _Limit 15\n    _Display\nLoop"
  },
  {
    "input": "DRAW Contest Fun",
    "output": "' Mod MG DRAW by bplus 2023-10-08\n'ref  https://qb64.boards.net/thread/219/qb64-dev-competition-idea?page=2&scrollTo=1228\n\nDim i As Integer, ai As Integer, cc As Integer, u As Integer\nDim a$, s$\n\nRandomize Timer\nScreen 13\nDo\n    a$ = \"\"\n    Do Until Len(a$) > 20\n        If Random1(2) = 1 Then\n            If Random1(2) = 1 Then a$ = a$ + \"L\" Else a$ = a$ + \"R\"\n        Else\n            If Random1(2) = 1 Then a$ = a$ + \"D\" Else a$ = a$ + \"U\"\n        End If\n        a$ = a$ + Str$(Rand(1, 15))\n    Loop\n    s$ = a$\n    Cls\n    For i = 1 To 24\n        stepper = Val(Mid$(\" 10 12 15 18 20 30 40 45 60 72 90120180\", Int(Rnd * 13) + 1, 3))\n        For ai = 0 To 360 - stepper Step stepper\n            cc = Rand(64, 160)\n            If i > 10 Then u = 10 Else u = i\n            If i Mod 2 Then cc = 9 Else cc = 15\n            PreSet (160, 100)\n            'Draw \"ta0\"  ' this needed?\n            a$ = \"S\" + Str$(22 - u * 2) + \"TA\" + Str$(ai) + \"C\" + Str$(cc) + s$\n            Draw a$\n        Next\n    Next\n    Print \"spacebar for another, esc to quit\"\n    Sleep\nLoop Until Asc(InKey$) = 27\n\nFunction Rand& (fromval&, toval&)\n    Dim sg%, f&, t&\n    If fromval& = toval& Then\n        Rand& = fromval&\n        Exit Function\n    End If\n    f& = fromval&\n    t& = toval&\n    If (f& < 0) And (t& < 0) Then\n        sg% = -1\n        f& = f& * -1\n        t& = t& * -1\n    Else\n        sg% = 1\n    End If\n    If f& > t& Then Swap f&, t&\n    Rand& = Int(Rnd * (t& - f& + 1) + f&) * sg%\nEnd Function\n\nFunction Random1& (maxvaluu&)\n    Dim sg%\n    sg% = Sgn(maxvaluu&)\n    If sg% = 0 Then\n        Random1& = 0\n    Else\n        If sg% = -1 Then maxvaluu& = maxvaluu& * -1\n        Random1& = Int(Rnd * maxvaluu& + 1) * sg%\n    End If\nEnd Function"
  },
  {
    "input": "Flame On",
    "output": "_Title \"Flame on by bplus 2017-11-23\"\n' flame on.bas SmallBASIC 0.12.9 (B+=MGA) 2017-11-22\n\nConst xmax = 800\nConst ymax = 550\n\nScreen _NewImage(xmax, ymax, 32)\n'_ScreenMove 360, 60 'adjust as needed _MIDDLE needs a delay .5 or more for me\n\nDim xxmax, yymax, xstep, ystep, i, fr, x, r, y\n\nxxmax = 200: yymax = 75 'pixels too slow\nxstep = xmax / xxmax: ystep = ymax / yymax\nDim p&(300) 'pallette\nFor i = 1 To 100\n    fr = Round(240 * i / 100 + 15)\n    p&(i) = _RGB(fr, 0, 0)\n    p&(i + 100) = _RGB(255, fr, 0)\n    p&(i + 200) = _RGB(255, 255, fr)\nNext\nDim f(xxmax, yymax + 2) 'fire array and seed\nFor x = 0 To xxmax\n    f(x, yymax + 1) = Round(Int(Rnd * 2) * 300)\n    f(x, yymax + 2) = 300\nNext\n'Color , &HFF4444DD\nWhile 1 'main fire\n    Cls\n    For x = 1 To xxmax - 1 'shift fire seed a bit\n        r = Rnd\n        If r < .15 Then\n            f(x, yymax + 1) = f(x - 1, yymax + 1)\n        ElseIf r < .3 Then\n            f(x, yymax + 1) = f(x + 1, yymax + 1)\n        ElseIf r < .35 Then\n            f(x, yymax + 1) = Int(Rnd * 2) * 300\n        End If\n    Next\n    For y = 0 To yymax 'fire based literally on 4 pixels below it like cellular automata\n        For x = 1 To xxmax - 1\n            f(x, y) = Round(max((f(x - 1, y + 1) + f(x, y + 1) + f(x + 1, y + 1) + f(x - 1, y + 2)) / 4 - 5, 0))\n            Line (x * xstep, y * ystep)-Step(xstep, ystep), p&(f(x, y)), BF\n        Next\n    Next\n    _Limit 60\n    _Display\nWend\nFunction max (a, b)\n    If a > b Then max = a Else max = b\nEnd Function\n"
  },
  {
    "input": "Sine Wave Water",
    "output": "'sinwavewater.bas\n'Dav, AUG/2024\n \nScreen _NewImage(800, 600, 32)\n \nDo\n    Cls\n    For waves = 1 To 10\n        For x = 0 To _Width\n            'choose of two ways to float\n            If waves Mod 2 Then\n                y = (60 * waves) + (2 + waves) * Sin(x / (15 + waves) - Timer * waves)\n            Else\n                y = (60 * waves) + (2 + waves) * Sin(x / (15 + waves) + Timer * waves)\n            End If\n            Line (x, _Height)-(x, y), _RGB(waves, waves, 25 * waves)\n        Next\n    Next\n    _Limit 30\n    _Display\nLoop Until InKey$ <> \"\"\n"
  },
  {
    "input": "Plasma with Pulse Factor",
    "output": " \nScreen _NewImage(800, 600, 32)\n \ncx = _Width / 2\ncy = _Height / 2\n \nDo\n    t = Timer\n    pulse = Sin(t) * .8 'pulse factor\n \n    For y = 0 To _Height Step 3\n        For x = 0 To _Width Step 3\n            a = _Atan2(y - cy, x - cx) + t\n            rad = Sqr((x - cx) ^ 2 + (y - cy) ^ 2) / 100\n \n            '1st plasma colors\n            r1 = (Sin(rad * 2 + t) + Sin(a * 5 + t)) * 127 + 128\n            g1 = (Sin(rad * 2 + t + 1) + Sin(a * 5 + t + 1)) * 127 + 128\n            b1 = (Sin(rad * 2 + t + 2) + Sin(a * 5 + t + 2)) * 127 + 128\n \n            '2nd plasma colors\n            r2 = (Sin(rad * 3 + t) + Sin(a * 3 + t + 1)) * 127 + 128\n            g2 = (Sin(rad * 3 + t + 2) + Sin(a * 3 + t + 3)) * 127 + 128\n            b2 = (Sin(rad * 3 + t + 4) + Sin(a * 3 + t + 4)) * 127 + 128\n \n            'Blend plasma colors using pulse factor\n            r = r1 * (1 - pulse) + r2 * pulse\n            g = g1 * (1 - pulse) + g2 * pulse\n            b = b1 * (1 - pulse) + b2 * pulse\n \n            c = _RGB(r, g, b)\n            For y1 = 0 To 2\n                For x1 = 0 To 2\n                    PSet (x + x1, y + y1), _RGB(r, g, b)\n                Next x1\n            Next y1\n        Next\n    Next\n \n    _Display\n    _Limit 30\n \nLoop Until InKey$ <> \"\"\n"
  },
  {
    "input": "Plinko",
    "output": "type ptype\n    x as double\n    y as double\n    vx as double\n    vy as double\nend type\n \ndim shared sw, sh, mx, my, mb, mw\n \nsw = 800\nsh = 600\nscreen _newimage(sw, sh, 32)\nif _resize then\n    sw = _resizewidth - 20\n    sh = _resizeheight - 20\n    screen _newimage(sw, sh, 32)\nend if\n \nimg = _newimage(sw, sh, 32)\n'cls ,_rgba(0,0,0,0)\n \n \nscore = 500\namount = 10\n \nh = 50\nrp = 7\nrb = 12\n \nredim pin(1000) as ptype\nrows = 8\nx = sw/2 - 2*h\ny = (sh - rows*h)/2\nm=0\nfor i=2 to rows + 2\n    for j=1 to i + 1\n        if j=1 then\n            pin(m).vx = 1\n        elseif j=i+1 then\n            pin(m).vx = -1\n        else\n            pin(m).vx = 0\n        end if\n \n        pin(m).x = x + j*h\n        pin(m).y = y\n        'circle (pin(m).x, pin(m).y), rp\n        m = m + 1\n    next\n    x = x - h/2\n    y = y + h\nnext\n \nredim ball(2) as ptype\nn = -1\nfor i=0 to n\n    ball(i).x = sw/2 - h + rp + (2*h - rp)*rnd \n    ball(i).y = (sh - rows*h)/2 - h*0.5\n    ball(i).vx = 0\n    ball(i).vy = 0\n \n    score = score - amount\nnext\n \n \n \n_dest img\ncls\nfor i=0 to m-1\n    circle(pin(i).x, pin(i).y), rp, _rgb(200,200,200)\nnext\ny0 = (sh - rows*h)/2\n'line (0, sh - y)-step(sw, 0)\nfor i=0 to rows+1\n    if i=0 or i=rows+1 then\n        color _rgb(255,0,0)\n        _printstring ((sw - (rows+2)*h)/2 + i*h, sh - y0 + h/2), \"  10x\"\n    elseif i=1 or i=rows then\n        color _rgb(255,80,0)\n        _printstring ((sw - (rows+2)*h)/2 + i*h, sh - y0 + h/2), \"  4x\"\n    elseif i=2 or i=rows-1 then\n        color _rgb(255,150,0)\n        _printstring ((sw - (rows+2)*h)/2 + i*h, sh - y0 + h/2), \"  2x\"\n    elseif i>2 or i<rows-1 then\n        color _rgb(155,155,0)\n        _printstring ((sw - (rows+2)*h)/2 + i*h, sh - y0 + h/2), \" 0.2x\"\n    end if\nnext\n \nx0 = (sw - (rows+2)*h)/2 \nline (x0, y0-200)-step((rows+2)*h,140),_rgb(155,155,155),b\n \nq = \"\"\n \n_dest 0\nmb_state = 0\ndo\n    mx = _mousex\n    my = _mousey\n    mb = _mousebutton(1)\n \n \n    _putimage (0,0),img\n \n    for i=0 to n\n        for r=1 to rb\n            circle(ball(i).x, ball(i).y), r, _rgb(155,0,0)\n        next\n        circle(ball(i).x, ball(i).y), rb, _rgb(255,0,0)\n        circle(ball(i).x, ball(i).y), rb-3, _rgb(255,0,0)\n \n        ball(i).x = ball(i).x + ball(i).vx\n        ball(i).y = ball(i).y + ball(i).vy \n        ball(i).vy = ball(i).vy + 0.2\n \n        for j=0 to m-1\n            d = (ball(i).x - pin(j).x)^2 + (ball(i).y - pin(j).y)^2\n \n            if d <= (rp + rb)^2 then\n                a = atan2(ball(i).y - pin(j).y, ball(i).x - pin(j).x)\n \n                if abs(a + pi/2) < 0.0001 then\n                    ball(i).vx = 0.1*ball(i).vx\n                    ball(i).vy = 0.1*ball(i).vy\n                    \n                    if rnd > 0.5 then aa = 1 else aa = -1\n                    if abs(pin(j).vx)>0.0001 then aa = pin(j).vx\n                \n                    ball(i).x = pin(j).x + (rp + rb + 0)*cos(a + aa*0.2)\n                    ball(i).y = pin(j).y + (rp + rb + 0)*sin(a + aa*0.2)\n                else\n                    v = sqr(ball(i).vx^2 + ball(i).vy^2)\n \n                    ball(i).vx = 0.5*v*cos(a)\n                    ball(i).vy = 0.5*v*sin(a)\n \n                    ball(i).x = pin(j).x + (rp + rb + 0)*cos(a )\n                    ball(i).y = pin(j).y + (rp + rb + 0)*sin(a )\n                end if\n \n                circle (pin(j).x, pin(j).y), rb, _rgb(255,255,255)\n            end if\n        next\n \n \n        if ball(i).y > sh - (sh - rows*h)/2 then\n \n            if ball(i).x > x0 and ball(i).x < x0+h then\n                q = q + \", 10x\"\n                score = score + amount*10\n            elseif ball(i).x > x0+9*h and ball(i).x < x0+10*h then\n                q = q + \", 10x\"\n                score = score + amount*10\n            elseif ball(i).x > x0+1*h and ball(i).x < x0+2*h then\n                q = q + \", 4x\"\n                score = score + amount*4\n            elseif ball(i).x > x0+8*h and ball(i).x < x0+9*h then\n                q = q + \", 4x\"\n                score = score + amount*4\n            elseif ball(i).x > x0+2*h and ball(i).x < x0+3*h then\n                q = q + \", 2x\"\n                score = score + amount*2\n            elseif ball(i).x > x0+7*h and ball(i).x < x0+8*h then\n                q = q + \", 2x\"\n                score = score + amount*2\n            elseif ball(i).x > x0+3*h and ball(i).x < x0+6*h then\n                q = q + \", 0.2x\"\n                score = score + amount*0.2\n            end if\n \n \n            for j=i to n-1\n                ball(j).x  = ball(j + 1).x \n                ball(j).y  = ball(j + 1).y \n                ball(j).vx = ball(j + 1).vx\n                ball(j).vy = ball(j + 1).vy\n            next\n            n = n - 1\n            redim _preserve ball(n) \n \n      end if\n    next\n \n    w0 = (rows+2)*h\n \n    color _rgb(0,255,0)\n    _printstring (x0 + 10, y0-200+10), \"$\"+_trim(str(int(score)))\n \n    color _rgb(255,0,0)\n    a = \"$\"+_trim(str(int(amount)))\n    _printstring(x0 +(rows+2)*h - len(a)*8 - 10, y0-200+10), a\n \n    color _rgb(155,155,0)\n    _printstring (x0 + 10, y0-200+140-16-10), right(q, w0/8 - 2)\n \n \n    if mx > x0 and mx < x0+w0 and my>y0-200 and my<y0-200+140 then\n        color _rgb(255,0,0)\n \n        if mb then mb_state = -1\n        if mb_state and mb = 0 then\n            mb_state = 0\n \n            n = n + 1\n            redim _preserve ball(n) \n            ball(n).x = sw/2 - h + rp + (2*h - rp)*rnd \n            ball(n).y = (sh - rows*h)/2 - h*0.5\n            ball(n).vx = 0\n            ball(n).vy = 0\n \n            score = score - amount\n        end if\n    else\n        color _rgb(155,155,155)\n    end if\n    _printstring (sw/2 - 15, y0-200+60), \"Play\"\n \n    if _keydown(18432) then amount = amount + 1\n    if amount > 1 then\n        if _keydown(20480) then amount = amount - 1\n    end if\n \n    _display\n    _limit 60\nloop until _keyhit = 27\n"
  },
  {
    "input": "Icosahedron",
    "output": "Import GFX From \"/lib/graphics/2d.bas\"\n\ndim shared xx(4*3), yy(4*3), zz(4*3)\ndim shared x, y, z\ndim shared p, q\ndim shared zoom\n\ndim shared phi\ndim shared rotx, roty, rotz, phiz, phix\nphiz = 0\nphix = 0\n\nrotx = 1\nroty = 1\nrotz = 1\n\nphi = 0\n\nzoom = 150\n\ndim shared sw, sh\nsw = 800\nsh = 600\nscreen newimage(sw, sh) \n\n\nzoom = sh/3\n\n\n\ndim c(2)\nc(0) = rgb(100,0,0)\nc(1) = rgb(0,100,0)\nc(2) = rgb(0,0,100)\nfor j=0 to 2\n    color c(j)\n    x = xx(4*j)\n    y = yy(4*j)\n    z = zz(4*j)\n    proj\n    preset (sw/2 + p*zoom, sh/2 - q*zoom)\n    for i=1 to 3\n        x = xx(4*j + i)\n        y = yy(4*j + i)\n        z = zz(4*j + i)\n        proj\n        line -(sw/2 + p*zoom, sh/2 - q*zoom)\n    next\n    x = xx(4*j)\n    y = yy(4*j)\n    z = zz(4*j)\n    proj\n    line -(sw/2 + p*zoom, sh/2 - q*zoom)\nnext\n\n\n\ndrag = 0\nox = 0\noy = 0\nmw = 0\ndo\n    do while mouseinput\n        zoom = zoom - 20*mousewheel\n    loop\n    \n    if mousebutton(1) then\n        if drag = 0 then\n            drag = 1\n            ox = mousex\n            oy = mousey\n        else\n            phiz = phiz - 0.01*(mousex - ox)\n            phix = phix - 0.01*(mousey - oy)\n            ox = mousex\n            oy = mousey\n        end if\n    else\n        drag = 0\n    end if\n\n    if resize then\n        sw = _resizewidth - 20\n        sh = _resizeheight - 20\n        screen newimage(sw, sh) \n    end if\n    \n    if not mousebutton(2) then\n        phi = phi + 0.01\n    end if\n\n    w = 0.5 + 0.5*sin(phi)\n    l = 0.5 + 0.5*cos(phi)\n    icos w, l\n\n    cls\n\n    'minor faces\n    tri 0, 4+0, 1\n    tri 0, 1, 4+3\n    tri 2, 4+1, 3\n    tri 2, 3, 4+2\n\n    tri 4+0, 4+1, 8+1\n    tri 4+0, 8+2, 4+1\n    tri 4+2, 4+3, 8+0\n    tri 4+2, 8+3, 4+3\n\n    tri 8+0, 1, 8+1\n    tri 8+2, 0, 8+3\n    tri 8+2, 8+3, 3\n    tri 8+0, 8+1, 2\n\n    'major faces\n    tri 0, 4+3, 8+3\n    tri 0, 8+2, 4+0\n    tri 1, 8+0, 4+3\n    tri 1, 4+0, 8+1\n\n    tri 2, 4+2, 8+0\n    tri 3, 8+3, 4+2\n    tri 2, 8+1, 4+1\n    tri 3, 4+1, 8+2\n\n    display\n    limit 30\nloop until keyhit=27\n\nsystem\n\nsub proj\n    d = 10\n    y0 = 10\n\n    'rot phi, rotx, roty, rotz\n    rot phiz, 0,0,1\n    rot phix, 1,0,0\n     \n    p = x*d/(y0 + y)\n    q = z*d/(y0 + y)\nend sub\n\nsub tri(a, b, c)\n    'centroid\n    x = (xx(a) + xx(b) + xx(c))/3\n    y = (yy(a) + yy(b) + yy(c))/3\n    z = (zz(a) + zz(b) + zz(c))/3\n    proj\n    cx = x\n    cy = y\n    cz = z\n    \n    rcy = y\n    \n    x = xx(b) - xx(a)\n    y = yy(b) - yy(a)\n    z = zz(b) - zz(a)\n    proj\n    x1 = x\n    y1 = y\n    z1 = z\n    \n    x = xx(b) - xx(c)\n    y = yy(b) - yy(c)\n    z = zz(b) - zz(c)\n    proj\n    x2 = x\n    y2 = y\n    z2 = z\n\n    x1 = xx(b) - xx(a)\n    y1 = yy(b) - yy(a)\n    z1 = zz(b) - zz(a)\n    \n    x2 = xx(b) - xx(c)\n    y2 = yy(b) - yy(c)\n    z2 = zz(b) - zz(c)\n\n    px = y1*z2 - z1*y2\n    py = z1*x2 - x1*z2\n    pz = x1*y2 - y1*x2\n\n\n    'dd = 10*sqr(px*px + py*py + pz*pz)\n    'px = px/dd\n    'py = py/dd\n    'pz = pz/dd\n\n    x = cx - px\n    y = cy - py\n    z = cz - pz\n    proj\n   \n    'line -(sw/2 + p*zoom, sh/2 - q*zoom), rgb(255,255,255)\n\n    x = px\n    y = py\n    z = pz\n    proj\n    if y<0.01 then\n        x = xx(a)\n        y = yy(a)\n        z = zz(a)\n        proj\n        'preset (sw/2 + p*zoom, sh/2 - q*zoom)\n        tx1 = sw/2 + p*zoom\n        ty1 = sh/2 - q*zoom\n\n        x = xx(b)\n        y = yy(b)\n        z = zz(b)\n        proj\n        'line -(sw/2 + p*zoom, sh/2 - q*zoom), rgb(255,255,255)\n        tx2 = sw/2 + p*zoom\n        ty2 = sh/2 - q*zoom\n\n        x = xx(c)\n        y = yy(c)\n        z = zz(c)\n        proj\n        'line -(sw/2 + p*zoom, sh/2 - q*zoom), rgb(255,255,255)\n        tx3 = sw/2 + p*zoom\n        ty3 = sh/2 - q*zoom\n\n        x = xx(a)\n        y = yy(a)\n        z = zz(a)\n        proj\n        'line -(sw/2 + p*zoom, sh/2 - q*zoom), rgb(255,255,255)\n        \n        c = 50 + rcy*100\n        GFX.FillTriangle tx1,ty1, tx2,ty2, tx3,ty3, rgb(c,c,c)\n        \n        \n        preset (tx1,ty1)\n        line -(tx2,ty2), rgb(c+50,c+50,c+50)\n        line -(tx3,ty3), rgb(c+50,c+50,c+50)\n        line -(tx1,ty1), rgb(c+50,c+50,c+50)\n    end if\n\nend sub\n\nsub icos(w, l)\n    xx(0) = -w\n    yy(0) = -l\n    zz(0) = 0\n    xx(1) = w\n    yy(1) = -l\n    zz(1) = 0\n    xx(2) = w\n    yy(2) = l\n    zz(2) = 0\n    xx(3) = -w\n    yy(3) = l\n    zz(3) = 0\n    for i=0 to 3\n        x = xx(i)\n        y = yy(i)\n        z = zz(i)\n        rot pi/2, 1,0,0\n        rot pi/2, 0,0,1\n        xx(4 + i) = x\n        yy(4 + i) = y\n        zz(4 + i) = z\n    next\n    for i=0 to 3\n        x = xx(i)\n        y = yy(i)\n        z = zz(i)\n        rot pi/2, 0,1,0\n        rot pi/2, 0,0,1\n        xx(8 + i) = x\n        yy(8 + i) = y\n        zz(8 + i) = z\n    next\nend sub\n\n'V_rot = V cos u + (R x V) sin u + R(R . V)(1 - cos u)\nsub rot(u, rx, ry, rz)\n    dd = sqr(rx*rx + ry*ry + rz*rz)\n    rx = rx/dd\n    ry = ry/dd\n    rz = rz/dd\n\n    x1 = x\n    y1 = y\n    z1 = z\n\n    x2 = ry*z - rz*y\n    y2 = rz*x - rx*z\n    z2 = rx*y - ry*x\n\n    dt = x*rx + y*ry + z*rz\n    x3 = rx*dt\n    y3 = ry*dt\n    z3 = rz*dt\n\n    x = x1*cos(u) + x2*sin(u) + x3*(1 - cos(u))\n    y = y1*cos(u) + y2*sin(u) + y3*(1 - cos(u))\n    z = z1*cos(u) + z2*sin(u) + z3*(1 - cos(u))\nend sub\n"
  },
  {
    "input": "Damesh",
    "output": "Randomize Timer ' damesh.bas Danilin from Russia\nScreen 12 ' 1! 2 3? 4 5! 6 7? 8 9!\nn=8: u=256: Dim x(n,9),y(n,9)\n\nFor i=1 To n\n    x(i,1)=Int(Rnd*u+3): y(i,1)=Int(Rnd*u+3)\n    x(i,9)=Int(Rnd*u+3): y(i,9)=Int(Rnd*u+3)\nNext\n\nData -5,1,9,-3,1,5,-2,1,3,-4,3,5,-7,5,9,-6,5,7,-8,7,9\n\nFor g=1 To 9 - 2: Read d,a,v\n    For i=1 To n: x(i,-d)=(x(i,a) +x(i,v))/2: y(i,-d)=(y(i,a) +y(i,v))/2: Next\nNext\n\nFor g=1 To 10: For k=1 To 9: _Delay .1: Cls\n    For i=1 To n: For j=1 To n: Circle (x(i,k),y(i,k)),2: Next: Next\n\n        For i=1 To n - 1: For j=i To n\n            Line (x(i,k),y(i,k))-(x(j,k),y(j,k)),i\n           'Line (x(i,k),y(i,k))-(x(i+1,k),y(i+1,k)),i\n    Next: Next: Next\n\n    For k=8 To 2 Step -1: _Delay .1: Cls\n\nFor p=1 To 9\n    For i=1 To n: For j=1 To n: Circle (x(i,p),y(i,p)),2,i: Next: Next\nNext\n    For i=1 To n - 1: For j=i To n\n       Line (x(i,k),y(i,k))-(x(j,k),y(j,k)),i\n      'Line (x(i,k),y(i,k))-(x(i+1,k),y(i+1,k)),i\n    Next: Next: Next\nNext"
  },
  {
    "input": "Relief 3D",
    "output": "N = 200:q = 15: SCREEN 12: DIM a(q + 1, N)'relup.bas 5d relief up\nFOR x = 1 TO q: FOR y = 1 TO N - 5\n        IF INT(RND * 100) MOD 7 = 5 THEN\n            a(x, y) = 5: a(x, y + 1) = 10: a(x, y + 2) = 20: a(x, y + 3) = 40: a(x, y + 4) = 80: y = y + 5\n        END IF\nNEXT: NEXT\nFOR t = 1 TO N-q\n    FOR i = 1 TO q-1: FOR j = 1 TO q-1: a(i, j) = a(i, j + t): NEXT: NEXT: CLS\n \n    FOR y = 1 TO q-1: FOR x = 1 TO q-2\n            LINE (30 + 20 * x + 20 * y, 400-20 * y - a(x, y))-(30 + 20 * (x + 1) + 20 * y, 400 - 20 * y - a(x + 1, y)), (y + t MOD 7) + 1\n    NEXT: NEXT\n \n    FOR x = 1 TO q-1: FOR y = 1 TO q-2\n            LINE (30 + 20 * x + 20 * y, 400 - 20 * y - a(x, y))-(30 + 20 * (x + 1) + 20 * y, 400 - 20 * (y + 1) - a(x, y + 1)), 7\nNEXT: NEXT: _DELAY 0.2: NEXT\nEND"
  },
  {
    "input": "Xonix",
    "output": "Randomize Timer: ' xonixdig.bas Danilin Russia \nb = Int(Rnd*10+15): a = Int(Rnd*10+15): ' _Font 17 \nN = Int(Rnd*3+5): Dim dx(N), dy(N), y(N), x(N), c(N) \n\nFor i = 1 To N\n    dx(i) = 1+Int(Rnd-.5)*2\n    dy(i) = 1+Int(Rnd-.5)*2\n    y(i) = Int(Rnd*(b-3)+2): x(i) = Int(Rnd*(a-3)+2)\n    c(i) = Int(Rnd*5+1)\nNext\n\nFor i = 1 To a: Print \"#\";: Next: Print ' area\nFor j = 1 To b-2: Print \"#\";: For k = 1 To a-2: Print \".\";: Next: Print \"#\": Next\nFor i = 1 To a: Print \"#\";: Next\n\nFor q = 1 To 1000: _Delay .08\n    For i = 1 To N: Locate y(i), x(i): Print \"  \"\n\n        If y(i)+dy(i) < 2 Or y(i)+dy(i) > b-1 Then dy(i) = -dy(i)\n        y(i) = y(i)+dy(i)\n        If x(i)+dx(i) < 2 Or x(i)+dx(i) > a-3 Then dx(i) = -dx(i)\n        x(i) = x(i)+dx(i)\n\n        For k = 1 To N-1: For m = k+1 To N\n            If y(k) = y(m) And x(k) = x(m) Then c(k) = Int(Rnd*5+1): c(m) = Int(Rnd*5+1)\n        Next: Next\n        Locate y(i), x(i): Color c(i): Print c(i)\nNext: Next\n"
  },
  {
    "input": "ASCII Cube",
    "output": "Screen _NewImage(605, 300, 32)\nRandomize Timer ' KUBIK.bas\n'........T=====T 1\n'......./-----/| 2\n'....../-----/|| 2\n'...../-----/||| 2\n'..../-----/|||J 3\n'.../-----/|||/ 4\n'../-----/|||/ 4\n'./-----/|||/ 4\n'T=====T|||/ 4\n'|*****|||/ 4\n'|*****||/ 4\n'|*****|/ 4\n'L=====J 5\nfor z=1 to 10: cls\na = Int(Rnd * 9) + 3: b = Int(Rnd * 7) + 3: c = Int(Rnd * 7) + 3\nLocate 1, 1: For i = 1 To c: Print \".\";: Next\nPrint \"T\";: For i = 1 To a - 2: Print \"=\";: Next: Print \"T 1\"\n\nFor i = 1 To b - 2:\n    For j = 1 To a + c - 2: Print \".\";: Next: Print \"|| 2\"\nNext\n\nFor i = 1 To a + c - 2: Print \".\";: Next: Print \"|J 3\"\n\nFor i = 1 To c - 1: Locate i + 1, 1\n    For j = c - i To 1 Step -1: Print \".\";: Next: Print \"/\";\n    For k = 1 To a - 2: Print \"-\";: Next: Print \"/\"\n\n    For m = 1 To b - 2\n        For n = 1 To c + a - 1 - i: Print \"|\";: Next: Print\n    Next: _Delay .25\n\n    For p = 1 To a + c - 1 - i: Print \"|\";: Next: Print \"/ 4\"\nNext\n\nLocate i + 1, 1: Print \"T\";:\nFor i = 1 To a - 2: Print \"=\";: Next: Print \"T\"\nFor i = 1 To b - 2: Print \"|\";\n    For j = 1 To a - 2: Print \"*\";: Next: Print \"|\"\nNext\n\nPrint \"L\";: For i = 1 To a - 2: Print \"=\";: Next: Print \"J 5\"\n_Delay 2\nNext\n"
  },
  {
    "input": "Russian Circle Diagram",
    "output": "Screen 12: Randomize Timer 'diagram.bas  Russian Circle Diagram\nN = 12: s = 0: Dim d(N+5),r(N+1+5):\nFor i = 1 To N: d(i) = Int(Rnd * 90+9): s = s+d(i): Print d(i): Next: Print \"SUM= \"; s\nFor i = 2 To N: r(i) = r(i-1)+d(i) * 2 * 3.1416 / s: Next: r(N+1) = r(1)\n \nFor i = 2 To N+1: For j = 1 To 100: Circle (150,100),j,i,r(i-1),r(i)\n    Circle (149,99),j,i,r(i-1),r(i): Circle (151,99),j,i,r(i-1),r(i)\n_Delay .002: Next: Next\n \nFor j = 1 To 100: For i = 2 To N+1: Circle (350,100),j,i,r(i-1),r(i)\n    Circle (349,100),j,i,r(i-1),r(i): Circle (351,99),j,i,r(i-1),r(i)\nNext: _Delay .01: Next\n\n_Delay 1: Cls 'Screen 12: Randomize Timer diagout.bas  Russian Circle Diagram\nN = 16: s = 0 ': Dim d(N),r(N+1):\nFor i = 1 To N: d(i) = Int(Rnd * 90+9): s = s+d(i): Print d(i): Next: Print \"SUM= \"; s\nFor i = 2 To N: r(i) = r(i-1)+d(i) * 2 * 3.1416 / s: Next: r(N+1) = r(1)\n\nFor i = 2 To N+1 Step 2: For j = 1 To 100: Circle (150,100),j,i,r(i-1),r(i)\n    Circle (149,99),j,i,r(i-1),r(i): Circle (151,99),j,i,r(i-1),r(i)\n_Delay .002: Next: Next\n\nFor i = 3 To N+1 Step 2: For j = 100 To 1 Step -1: Circle (150,100),j,i,r(i-1),r(i)\n    Circle (149,99),j,i,r(i-1),r(i): Circle (151,99),j,i,r(i-1),r(i)\n_Delay .002: Next: Next\n\nFor j = 1 To 100: For i = 2 To N+1\n    If (i Mod 2) = 0 Then Circle (350,100),j,i,r(i-1),r(i): Circle (349,99),j,i,r(i-1),r(i): Circle (351,99),j,i,r(i-1),r(i)\n        If (i Mod 2) = 1 Then Circle (350,100),100-j,i,r(i-1),r(i): Circle (349,99),100-j,i,r(i-1),r(i): Circle (351,99),100-j,i,r(i-1),r(i)\nNext: _Delay .01: Next: End"
  },
  {
    "input": "Mobile-friendly pool game with an interesting twist",
    "output": "type balltype\n    x  as double\n    y  as double\n    vx as double\n    vy as double\n    c  as long\nend type\n\ndim shared img as long\n\n'balls\ndim shared n\nredim shared ball(10) as balltype\n\n'sizes\ndim shared sw, sh, ar, br, fc, xc, yc\nsw = 375\nsh = 667\nar = sw/sh\n\n'geometry\ndim drx, dry, dvx, dvy, drmag, nx, ny, qmag\n\ninit\n\ndim x, y\ndim mb_state, ox, oy\nmb_state = 0\nox = 0\noy = 0\n\ndo\n    if _resize then\n        sh = _resizeheight - 20\n        sw = ar*sh\n        'sw = _resizewidth - 20\n\n        init\n    end if\n\n    mx = _mousex\n    my = _mousey\n    mb = _mousebutton(1)\n\n    'redraw\n    _putimage (0,0), img\n    for i=0 to n\n        r = red(ball(i).c)\n        g = green(ball(i).c)\n        b = blue(ball(i).c)\n        for j=0 to br\n            circle (ball(i).x, ball(i).y), j, rgb(r-7*j, g-7*j, b-7*j)\n        next\n        for j=br to 1.1*br\n            circle (ball(i).x, ball(i).y), j, rgba(0, 255 - (j-br)*70, 0, 35)\n        next\n    next\n\n    'balls\n    for i=0 to n\n        ball(i).x = ball(i).x + ball(i).vx\n        ball(i).y = ball(i).y + ball(i).vy\n\n        'ball(i).vx = 0.99*ball(i).vx\n        'ball(i).vy = 0.99*ball(i).vy\n        b = atan2( ball(i).vy, ball(i).vx )\n        v = sqr(ball(i).vx*ball(i).vx + ball(i).vy*ball(i).vy)\n\n        'terminal velocity\n        maxv = 49\n        if (v > maxv) then\n            ball(i).vx = maxv*cos(b)\n            ball(i).vy = maxv*sin(b)\n        end if\n\n        'friction\n        ball(i).vx = (0.99 - 0.01*(v/maxv))*ball(i).vx\n        ball(i).vy = (0.99 - 0.01*(v/maxv))*ball(i).vy\n        'ball(i).vx = 0.5*(1 + tanh(3.5*v/maxv))*ball(i).vx\n        'ball(i).vy = 0.5*(1 + tanh(3.5*v/maxv))*ball(i).vy\n\n\n        x = ball(i).x - sw/2\n        y = sh/2 - ball(i).y\n\n        'wall collision\n        if ((x/(sw/2 - br))^2 + (y/(sh/2 - br))^2) > 1 then\n            a = atan2( -(sh/2)*(sh/2)*x, (sw/2)*(sw/2)*(ball(i).y-sh/2) )\n\n            c = 2*a - b - pi\n            ball(i).vx = -1.07*v*cos(c)\n            ball(i).vy = -1.07*v*sin(c)\n\n            'reset out of bounds\n            a = atan2((ball(i).y - sh/2)/(sh/2 - br - 1), (ball(i).x - sw/2)/(sw/2 - br - 1))\n            'line (sw/2, sh/2)-(ball(0).x, ball(0).y), rgb(255,0,0)\n            'line (sw/2, sh/2)-step((sw/2 - br - 1)*cos(a), (sh/2 - br - 1)*sin(a)), rgb(255,0,0)\n            'circle step(0,0),br,rgb(255,0,0)\n\n            ball(i).x = sw/2 + (sw/2 - br - 1)*cos(a)\n            ball(i).y = sh/2 + (sh/2 - br - 1)*sin(a)\n\n        end if\n\n        'ball to ball collision\n        for j=0 to n\n        if i<>j then\n            if ((ball(i).x - ball(j).x)^2 + (ball(i).y - ball(j).y)^2) < 4*br*br then\n                'a = atan2(ball(i).y - ball(j).y, ball(i).x - ball(j).x)\n                'v1 = sqr(ball(i).vx*ball(i).vx + ball(i).vy*ball(i).vy)\n                'v2 = sqr(ball(j).vx*ball(j).vx + ball(j).vy*ball(j).vy)\n                'v = 0.5*(v1 + v2)\n                'ball(i).vx = v*cos(a)\n                'ball(i).vy = v*sin(a)\n                'ball(j).vx =-v*cos(a)\n                'ball(j).vy =-v*sin(a)\n\n                ''e = 0.5\n                ''v1f = 0.5*(v1*(1 - e) + v2*(1 + e))\n                ''v2f = 0.5*(v1*(1 + e) + v2*(1 - e))\n                ''ball(i).vx = v1f*cos(a)\n                ''ball(i).vy = v1f*sin(a)\n                ''ball(j).vx =-v2f*cos(a)\n                ''ball(j).vy =-v2f*sin(a)\n\n                'momentum exchange\n                drx = ball(i).x - ball(j).x\n                dry = ball(i).y - ball(j).y\n                dvx = ball(i).vx - ball(j).vx\n                dvy = ball(i).vy - ball(j).vy\n                drmag = sqr(drx*drx + dry*dry)\n                nx = drx / drmag\n                ny = dry / drmag\n                qmag = nx * dvx + ny * dvy\n                ball(i).vx = ball(i).vx - nx * qmag\n                ball(i).vy = ball(i).vy - ny * qmag\n                ball(j).vx = ball(j).vx + nx * qmag\n                ball(j).vy = ball(j).vy + ny * qmag\n\n                'boost along equal and opposite directions\n                'ball(i).x = ball(i).x + .2*nx\n                'ball(i).y = ball(i).y + .2*ny\n                'ball(j).x = ball(j).x - .2*nx\n                'ball(j).y = ball(j).y - .2*ny\n\n                'teleport apart on overlap\n                cx = 0.5*(ball(i).x + ball(j).x)\n                cy = 0.5*(ball(i).y + ball(j).y)\n                ball(i).x = cx + br*nx\n                ball(i).y = cy + br*ny\n                ball(j).x = cx - br*nx\n                ball(j).y = cy - br*ny\n\n            end if\n        end if\n        next\n\n        'holed\n        if i<>0 then\n        if ((ball(i).x - xc)^2 + (ball(i).y - yc)^2) < (1.4*br)^2 then\n            for j=i to n\n                ball(j).x  = ball(j+1).x\n                ball(j).y  = ball(j+1).y\n                ball(j).vx = ball(j+1).vx\n                ball(j).vy = ball(j+1).vy\n                ball(j).c  = ball(j+1).c\n            next\n\n            n = n - 1\n\n        end if\n        end if\n    next\n\n    'mouse state\n    if mb and mb_state = 0 then\n        'if (mx-ball(0).x)^2 + (my-ball(0).y)^2 < br*br then\n            mb_state = 1\n            ox = mx\n            oy = my\n        'end if\n    end if\n    if mb and mb_state then\n        line (ox, oy)-(mx, my),rgba(100,100,100,100)\n        a = atan2(my - oy, mx - ox)\n        v = sqr((my - oy)^2 + (mx - ox)^2)\n        x = ball(0).x + (br + 2)*cos(a)\n        y = ball(0).y + (br + 2)*sin(a)\n        line (x, y)-step(3*br*cos(a), 3*br*sin(a)), rgb(10 + 1*v,155,0)\n        line (x, y)-step(br*cos(a+pi/10), br*sin(a+pi/10)), rgb(10 + 1*v,155,0)\n        line (x, y)-step(br*cos(a-pi/10), br*sin(a-pi/10)), rgb(10 + 1*v,155,0)\n    end if\n    if mb = 0 and mb_state then\n        ball(0).vx = -0.08*(mx - ox)\n        ball(0).vy = -0.08*(my - oy)\n        mb_state = 0\n    end if\n\n    _display\n    _limit 30\nloop until _keyhit=27\nsystem\n\nsub init()\n    br = (18/375)*sw\n\n    if sw>=sh then\n        fc = sqr((sw/2)^2 - (sh/2)^2)\n        xc = sw/2 + fc\n        yc = sh/2\n    else\n        fc = sqr((sh/2)^2 - (sw/2)^2)\n        xc = sw/2\n        yc = sh/2 + fc\n    end if\n\n    n = 6\n    ball(0).x = sw/2\n    ball(0).y = sh/2\n    ball(0).vx = 0\n    ball(0).vy = 0\n    ball(0).c = rgb(255,255,255)\n\n    ball(1).x  = sw/2\n    ball(1).y  = sh/4\n    ball(1).vx = 0\n    ball(1).vy = 0\n    ball(1).c  = rgb(255,0,0)\n    ball(2).x  = sw/2 + br*2+1\n    ball(2).y  = sh/4\n    ball(2).vx = 0\n    ball(2).vy = 0\n    ball(2).c  = rgb(255,0,255)\n    ball(3).x  = sw/2 - br*2-1\n    ball(3).y  = sh/4\n    ball(3).vx = 0\n    ball(3).vy = 0\n    ball(3).c  = rgb(0,0,255)\n\n    ball(4).x  = sw/2 - br*1\n    ball(4).y  = sh/4 + br*2+0.8\n    ball(4).vx = 0\n    ball(4).vy = 0\n    ball(4).c  = rgb(255,255,0)\n    ball(5).x  = sw/2 + br*1\n    ball(5).y  = sh/4 + br*2+0.8\n    ball(5).vx = 0\n    ball(5).vy = 0\n    ball(5).c  = rgb(255,155,0)\n    ball(6).x  = sw/2 + br*0\n    ball(6).y  = sh/4 + br*4+0.8\n    ball(6).vx = 0\n    ball(6).vy = 0\n    ball(6).c  = rgb(155,255,0)\n\n    screen _newimage(sw, sh, 32)\n\n    img = _newimage(sw, sh, 32)\n    _dest img\n    cls ,_rgba(0,0,0, 250)\n\n    dim x, y\n    dim w(1), z(1)\n    for y=0 to sh\n    for x=0 to sw\n        dist = ((x - sw/2)/(sw/2))^2 + ((sh/2 - y)/(sh/2))^2\n        if dist < 1 then\n            g = 35*rnd + 14\n            g = g + 35*dist\n\n            ''uncomment for bad ass mod\n            'w(0) = 1\n            'w(1) = 0\n            'z(0) = (x - sw/2)/100\n            'z(1) = (sh/2 - y - fc)/100\n            'cdiv w, w, z\n            'z(0) = (x - xc)/100\n            'z(1) = (y - yc)/100\n            'cdiv w, w, z\n            'z(0) = log(100*sqr(w(0)*w(0) + w(1)*w(1)))\n            'z(1) = atan2(w(1), w(0))/(pi/8)\n            'g = 0\n            'g = g + 70*(abs(cos(2*pi*z(0))*cos(2*pi*z(1))))^0.7\n            'if g>255 or g<0 then g=0\n            'g = g - 14*rnd\n            'if g>255 or g<0 then g=0\n            'g = g + 100*(dist)^4\n\n            pset (x, y), rgb(0,g,0)\n        end if\n    next\n    next\n\n    preset (sw, sh/2)\n    for a=0 to 2*pi+0.1 step 0.1\n        x = (sw/2)*cos(a)\n        y = (sh/2)*sin(a)\n\n        line -(sw/2 + x, sh/2 - y), rgb(0,255,0)\n    next\n\n    for i=0 to 1.1*br\n        circle (xc, yc), i, rgb(0,0,0)\n    next\n    circle (xc, yc), 1.2*br, rgb(0,255,0)\n    for i=1.2*br to 1.5*br\n        circle (xc, yc), i, rgba(0, 255 - 50*(i - 1.2*br), 0, 100)\n    next\n\n    _dest 0\n    _putimage (0,0), img\n\nend sub\n\nsub cdiv( w(), z1(), z2() )\n    x = z1(0)\n    y = z1(1)\n    a = z2(0)\n    b = z2(1)\n\n    d = a*a + b*b\n    w(0) = (x*a + y*b)/d\n    w(1) = (y*a - x*b)/d\nend sub\n"
  },
  {
    "input": "Math Function Utility",
    "output": "dim pi\npi = 4*atn(1)\n\ndim x1, y1, x2, y2\nx1 = -pi\nx2 = pi\ny1 = 1.2\ny2 = -1.2\n\ndim w, h\nw = 800\nh = 600\nscreen _newimage(w, h)\n\ndim redraw\nredraw = 1\n\nwindow screen(x1, y1)-(x2, y2)\n\ndo\nif _resize then\n    w = _resizewidth - 20\n    h = _resizeheight - 20\n    screen _newimage(w, h)\n    window screen(x1, y1)-(x2, y2)\n    redraw = 1\nend if\n\nif redraw then\ncls\ndim a\nfor a = x1 to x2 step pi/4\n    line (a, y1)-(a, y2),_rgb(50,50,50)\nnext\nfor a = y1 to y2 step -0.1\n    line (x1, a)-(x2, a),_rgb(50,50,50)\nnext\nline (0, y1)-(0, y2),_rgb(150,150,150)\nline (x1, 0)-(x2, 0),_rgb(150,150,150)\n\ndim x, y\n\ncolor _rgb(200,0,0): locate 1,1: print \"y = sin(x)\"\npset (x1, 0)\nfor x=x1 to x2 step 0.01 \n\n    y = sin(x)\n    \n    line -(x, y), _rgb(200,0,0)\nnext\n\ncolor _rgb(0,200,0): locate 2,1: print \"y = (tanh(x) + 1)/2\"\npset (x1, 0)\nfor x=x1 to x2 step 0.01 \n\n    y = 0.5 + 0.5*(exp(2*x) - 1)/(exp(2*x) + 1)\n    \n    line -(x, y), _rgb(0,200,0)\nnext\n\ncolor _rgb(255,255,0): locate 3,1: print \"y = smoothstep(x)\"\npset (x1, 0)\nfor x=x1 to x2 step 0.01 \n\n    y = (3*x^2 - 2*x^3)*(x>=0 and x<1) + (x>=1)\n    \n    line -(x, y), _rgb(255,255,0)\nnext\n\ncolor _rgb(100,100,0): locate 4,1: print \"y = smootherstep(x)\"\npset (x1, 0)\nfor x=x1 to x2 step 0.01 \n\n    y = (-20*x^7 + 70*x^6 - 84*x^5 + 35*x^4)*(x>=0 and x<1) + (x>=1)\n    \n    line -(x, y), _rgb(100,100,0)\nnext\n\nredraw = 0\nend if\nloop"
  },
  {
    "input": "Flow Field",
    "output": "SCREEN _NEWIMAGE(800, 600, 32)\n\nTYPE Particle\n    x AS SINGLE\n    y AS SINGLE\n    angle AS SINGLE\n    speed AS SINGLE\nEND TYPE\n\nCONST NUM_PARTICLES = 3000\nCONST PI = 3.14159\n\nDIM SHARED particles(1 TO NUM_PARTICLES) AS Particle\nDIM SHARED t AS SINGLE\n\nFOR i = 1 TO NUM_PARTICLES\n    particles(i).x = RND * 800\n    particles(i).y = RND * 600\n    particles(i).speed = 0.5 + RND * 1.5\n    particles(i).angle = RND * PI * 2\nNEXT i\n\nDO\n    t = t + 0.01\n    FOR i = 1 TO NUM_PARTICLES\n        fieldAngle = SIN(particles(i).x / 100 + t) * COS(particles(i).y / 100) + _\n                     COS(particles(i).x / 150 - t * 0.5) * SIN(particles(i).y / 120) + _\n                     SIN(particles(i).x / 80 + t * 0.7) * SIN(particles(i).y / 90 + t)\n\n        fieldAngle = fieldAngle + (RND - 0.5) * 0.1\n\n        particles(i).angle = particles(i).angle * 0.98 + fieldAngle * 0.02\n        particles(i).speed = 0.5 + ABS(SIN(particles(i).x / 200 + t)) * 1.5\n        particles(i).x = particles(i).x + COS(particles(i).angle) * particles(i).speed\n        particles(i).y = particles(i).y + SIN(particles(i).angle) * particles(i).speed\n\n        IF particles(i).x < 0 THEN\n            particles(i).x = 800\n            particles(i).y = particles(i).y + (RND - 0.5) * 20\n        END IF\n        IF particles(i).x > 800 THEN\n            particles(i).x = 0\n            particles(i).y = particles(i).y + (RND - 0.5) * 20\n        END IF\n        IF particles(i).y < 0 THEN\n            particles(i).y = 600\n            particles(i).x = particles(i).x + (RND - 0.5) * 20\n        END IF\n        IF particles(i).y > 600 THEN\n            particles(i).y = 0\n            particles(i).x = particles(i).x + (RND - 0.5) * 20\n        END IF\n\n        c = _RGB32(127 + 127 * SIN(particles(i).x / 200 + t), _\n                   127 + 127 * COS(particles(i).y / 180 + t * 0.7), _\n                   127 + 127 * SIN((particles(i).x + particles(i).y) / 300 + t * 0.5))\n        PSET (particles(i).x, particles(i).y), c\n    NEXT i\n\n    _LIMIT 60\n    _DISPLAY\n    CLS\n\nLOOP"
  },
  {
    "input": "Particle Mist Eddies",
    "output": "_Title \"Particle Mist Eddies Mod, go ahead and try a keypress\" ' b+ mod issues37 QBJS post at Discord\nType Particle\n    x As Single\n    y As Single\n    angle As Single\n    speed As Single\nEnd Type\n\nConst nParticles = 20000\nConst Pi = _Pi\nDim p(1 To nParticles) As Particle\nDim t As Single, i As Long, c As _Unsigned Long\n\nScreen _NewImage(800, 600, 32): _ScreenMove 280, 60\nRandomize Timer\nFor i = 1 To nParticles\n    p(i).x = Rnd * 800\n    p(i).y = Rnd * 600\n    p(i).speed = 0.5 + Rnd * 1.5\n    p(i).angle = Rnd * Pi * 2\nNext\n\nDo\n    t = t + 0.03\n    For i = 1 To nParticles\n        fieldAngle = SIN(p(i).x / 101 + t) * COS(p(i).y / 103) + _\n                     COS(p(i).x / 157 - t * .5) * SIN(p(i).y / 127) + _\n                     SIN(p(i).x / 83 + t * .7) * SIN(p(i).y / 79 + t)\n\n        fieldAngle = fieldAngle + (Rnd - 0.5) * 0.1\n\n        p(i).angle = p(i).angle * 0.98 + fieldAngle * 1.0007 '.02\n        p(i).speed = 0.5 + Abs(Sin(p(i).x / 200 + t)) * 1.5\n        p(i).x = p(i).x + Cos(p(i).angle) * p(i).speed\n        p(i).y = p(i).y + Sin(p(i).angle) * p(i).speed\n\n        If p(i).x < 0 Then\n            p(i).x = 800\n            p(i).y = p(i).y + (Rnd - 0.5) * 20\n        End If\n        If p(i).x > 800 Then\n            p(i).x = 0\n            p(i).y = p(i).y + (Rnd - 0.5) * 20\n        End If\n        If p(i).y < 0 Then\n            p(i).y = 600\n            p(i).x = p(i).x + (Rnd - 0.5) * 20\n        End If\n        If p(i).y > 600 Then\n            p(i).y = 0\n            p(i).x = p(i).x + (Rnd - 0.5) * 20\n        End If\n        c = _RGB32(127 + 127 * Sin(p(i).x / 200 + t * .5), _\n            127 + 127 * Cos(p(i).y / 180 + t * 0.35), _\n            127 + 127 * Sin((p(i).x + p(i).y) / 300 + t * .25))\n\n        PSet (p(i).x, p(i).y), c\n    Next\n    _Limit 60\n    _Display\n    Cls\nLoop\n"
  },
  {
    "input": "Parametric Clock",
    "output": "_TITLE \"Parametric Clock\"\n\nDIM SHARED MainScreen AS LONG\nDIM SHARED BackScreen AS LONG\nMainScreen = _NEWIMAGE(600, 600, 32)\nBackScreen = _NEWIMAGE(600, 600, 32)\nSCREEN MainScreen\n\nRANDOMIZE TIMER\n\nDIM SHARED pi AS DOUBLE\nDIM SHARED phi AS DOUBLE\npi = 4 * ATN(1)\nphi = (1 + SQR(5)) / 2\n\nTYPE TimeValue\n    Hour AS INTEGER\n    Minute AS INTEGER\n    Second AS DOUBLE\n    TenthSecond AS DOUBLE\nEND TYPE\n\nTYPE Vector\n    x AS DOUBLE\n    y AS DOUBLE\nEND TYPE\n\nTYPE ClockHand\n    Center AS Vector\n    HandPosition AS Vector\n    Length AS DOUBLE\n    Angle AS DOUBLE\n    Shade AS _UNSIGNED LONG\nEND TYPE\n\nDIM SHARED TheTime AS TimeValue\nDIM SHARED HourHand AS ClockHand\nDIM SHARED MinuteHand AS ClockHand\nDIM SHARED SecondHand AS ClockHand\nDIM SHARED TenthSecondHand AS ClockHand\n\nDIM SHARED Mode AS INTEGER\nDIM SHARED ModeList(12) AS INTEGER\nDIM SHARED TimeShift AS DOUBLE\nTimeShift = 0\n\nHourHand.Center.x = 0\nHourHand.Center.y = 0\nHourHand.Length = 150\nMinuteHand.Length = HourHand.Length / (phi)\nSecondHand.Length = HourHand.Length / (phi ^ 2)\nTenthSecondHand.Length = HourHand.Length / (phi ^ 3)\nHourHand.Shade = _RGB32(200, 50, 50, 255)\nMinuteHand.Shade = _RGB32(65, 105, 225, 255)\nSecondHand.Shade = _RGB32(255, 165, 0, 255)\nTenthSecondHand.Shade = _RGB32(138, 43, 226, 255)\n\nCALL InitializeModes\nMode = 12\n\nCALL PrepareClockface(1)\nDO\n    CALL KeyProcess\n    CALL UpdateTime(TIMER + TimeShift)\n    CALL UpdateClock\n    CALL DrawEverything\n    _KEYCLEAR\n    _LIMIT 60\nLOOP\n\nSYSTEM\n\nSUB InitializeModes\n    DIM k AS INTEGER\n    FOR k = 1 TO 12\n        ModeList(k) = k\n    NEXT\nEND SUB\n\nSUB PrepareClockface (metric AS INTEGER)\n    DIM p AS DOUBLE\n    DIM q AS LONG\n    _DEST BackScreen\n    CLS\n    CALL ccircle(0, 0, HourHand.Length, HourHand.Shade)\n    p = RND\n    FOR q = 0 TO ((Mode * 3600) - (metric)) STEP (metric)\n        CALL UpdateTime(q)\n        CALL UpdateClock\n        CALL lineSmooth(SecondHand.Center.x, SecondHand.Center.y, SecondHand.HandPosition.x, SecondHand.HandPosition.y, _RGB32(255 * p, 255 * RND * 155, 255 * (1 - p), 10))\n    NEXT\n    FOR q = 0 TO ((Mode * 3600) - (3600)) STEP (3600)\n        CALL UpdateTime(q)\n        CALL UpdateClock\n        CALL ccircle(HourHand.HandPosition.x, HourHand.HandPosition.y, 6, HourHand.Shade)\n        CALL ccirclefill(HourHand.HandPosition.x, HourHand.HandPosition.y, 5, _RGB32(0, 0, 0, 255))\n    NEXT\n    _DEST MainScreen\nEND SUB\n\nSUB KeyProcess\n    IF (_KEYDOWN(32) = -1) THEN ' Space\n        TimeShift = -TIMER\n    END IF\n    IF ((_KEYDOWN(114) = -1) OR (_KEYDOWN(84) = -1)) THEN ' r or R\n        TimeShift = 0\n    END IF\n    IF (_KEYDOWN(19200) = -1) THEN ' Leftarrow\n        CALL DecreaseMode\n        CALL PrepareClockface(1)\n        _DELAY .1\n    END IF\n    IF (_KEYDOWN(19712) = -1) THEN ' Rightarrow\n        CALL IncreaseMode\n        CALL PrepareClockface(1)\n        _DELAY .1\n    END IF\n    IF (_KEYDOWN(18432) = -1) THEN ' Uparrow\n        TimeShift = TimeShift + 60\n    END IF\n    IF (_KEYDOWN(20480) = -1) THEN ' Downarrow\n        TimeShift = TimeShift - 60\n    END IF\nEND SUB\n\nSUB UpdateTime (z AS DOUBLE)\n    DIM t AS DOUBLE\n    t = z\n    TheTime.Hour = INT(t / 3600)\n    t = t - TheTime.Hour * 3600\n    TheTime.Hour = TheTime.Hour MOD Mode\n    IF (TheTime.Hour = 0) THEN TheTime.Hour = Mode\n    TheTime.Minute = INT(t / 60)\n    t = t - TheTime.Minute * 60\n    TheTime.Second = t\n    TheTime.TenthSecond = (TheTime.Second - INT(TheTime.Second))\nEND SUB\n\nSUB UpdateClock\n    HourHand.Angle = -((TheTime.Hour + (TheTime.Minute / 60) + (TheTime.Second / 3600)) / Mode) * 2 * pi + (pi / 2)\n    MinuteHand.Angle = -((TheTime.Minute / 60) + (TheTime.Second / 3600)) * 2 * pi + (pi / 2)\n    SecondHand.Angle = -(TheTime.Second / 60) * 2 * pi + (pi / 2)\n    HourHand.HandPosition.x = HourHand.Center.x + HourHand.Length * COS(HourHand.Angle)\n    HourHand.HandPosition.y = HourHand.Center.y + HourHand.Length * SIN(HourHand.Angle)\n    MinuteHand.Center.x = HourHand.HandPosition.x\n    MinuteHand.Center.y = HourHand.HandPosition.y\n    MinuteHand.HandPosition.x = MinuteHand.Center.x + MinuteHand.Length * COS(MinuteHand.Angle)\n    MinuteHand.HandPosition.y = MinuteHand.Center.y + MinuteHand.Length * SIN(MinuteHand.Angle)\n    SecondHand.Center.x = MinuteHand.HandPosition.x\n    SecondHand.Center.y = MinuteHand.HandPosition.y\n    SecondHand.HandPosition.x = SecondHand.Center.x + SecondHand.Length * COS(SecondHand.Angle)\n    SecondHand.HandPosition.y = SecondHand.Center.y + SecondHand.Length * SIN(SecondHand.Angle)\nEND SUB\n\nSUB DrawEverything\n    CLS\n    _PUTIMAGE (0, 0)-(_WIDTH, _HEIGHT), BackScreen, MainScreen, (0, 0)-(_WIDTH, _HEIGHT)\n    CALL DrawModeList\n    CALL DrawHUD\n    CALL DrawClockHands\n    CALL DrawDigitalClock\n    _DISPLAY\nEND SUB\n\nSUB DrawModeList\n    DIM k AS INTEGER\n    FOR k = 1 TO UBOUND(ModeList)\n        IF (Mode = k) THEN\n            COLOR _RGB32(255, 255, 0, 255), _RGB32(0, 0, 255, 255)\n        ELSE\n            COLOR _RGB32(100, 100, 100, 255), _RGB32(0, 0, 0, 0)\n        END IF\n        _PRINTSTRING ((4 + 5 * k) * 8, _HEIGHT - (1) * 16), LTRIM$(RTRIM$(STR$(ModeList(k))))\n    NEXT\n    COLOR _RGB32(200, 200, 0, 255), _RGB32(0, 0, 0, 0)\n    '_PRINTSTRING ((4 + 1) * 8, _HEIGHT - (1) * 16), \">\"\n    '_PRINTSTRING ((4 + 5 * (UBOUND(ModeList) + 1)) * 8, _HEIGHT - (1) * 16), \"<\"\nEND SUB\n\nSUB IncreaseMode\n    IF (Mode < 12) THEN\n        Mode = Mode + 1\n    ELSE\n        Mode = 1\n    END IF\nEND SUB\n\nSUB DecreaseMode\n    IF (Mode = 1) THEN\n        Mode = 12\n    ELSE\n        Mode = Mode - 1\n    END IF\nEND SUB\n\nSUB DrawClockHands\n    DIM k AS DOUBLE\n    DIM ctmp AS _UNSIGNED LONG\n    DIM SeedLength AS DOUBLE\n    SeedLength = 12\n    FOR k = 0 TO 1 STEP .01\n        ctmp = ColorMix(_RGB32(0, 0, 255, 255), HourHand.Shade, k)\n        ctmp = _RGB32(_RED32(ctmp), _GREEN32(ctmp), _BLUE32(ctmp), 255)\n        CALL ccirclefill(HourHand.Center.x + (k * HourHand.Length) * COS(HourHand.Angle), HourHand.Center.y + (k * HourHand.Length) * SIN(HourHand.Angle), k * SeedLength, ctmp)\n    NEXT\n    FOR k = 0 TO 1 STEP .01\n        ctmp = ColorMix(HourHand.Shade, MinuteHand.Shade, k)\n        ctmp = _RGB32(_RED32(ctmp), _GREEN32(ctmp), _BLUE32(ctmp), 255)\n        CALL ccirclefill(MinuteHand.Center.x + (k * MinuteHand.Length) * COS(MinuteHand.Angle), MinuteHand.Center.y + (k * MinuteHand.Length) * SIN(MinuteHand.Angle), SeedLength * (1 - k / phi), ctmp)\n    NEXT\n    FOR k = 0 TO 1 STEP .005\n        ctmp = ColorMix(MinuteHand.Shade, SecondHand.Shade, k)\n        ctmp = _RGB32(_RED32(ctmp), _GREEN32(ctmp), _BLUE32(ctmp), 255)\n        CALL ccirclefill(SecondHand.Center.x + (k * SecondHand.Length) * COS(SecondHand.Angle), SecondHand.Center.y + (k * SecondHand.Length) * SIN(SecondHand.Angle), (SeedLength * (1 - 1 / phi)) * (1 - k), ctmp)\n    NEXT\n\n    CALL DrawPulley(HourHand.Center.x, HourHand.Center.x, 0, HourHand.HandPosition.x, HourHand.HandPosition.y, SeedLength + 2, _RGB32(255, 255, 255, 255))\n    CALL DrawPulley(HourHand.HandPosition.x, HourHand.HandPosition.y, SeedLength + 2, MinuteHand.HandPosition.x, MinuteHand.HandPosition.y, (SeedLength * (1 - 1 / phi)) + 1, _RGB32(255, 255, 255, 255))\n    CALL DrawPulley(MinuteHand.HandPosition.x, MinuteHand.HandPosition.y, (SeedLength * (1 - 1 / phi)) + 1, SecondHand.HandPosition.x, SecondHand.HandPosition.y, 0, _RGB32(255, 255, 255, 255))\nEND SUB\n\nSUB DrawDigitalClock\n    DIM t AS STRING\n    COLOR _RGB32(200, 200, 0, 255), _RGB32(0, 0, 0, 0)\n    DIM h AS STRING\n    DIM m AS STRING\n    DIM s AS STRING\n    DIM n AS STRING\n    h = LTRIM$(RTRIM$(STR$(TheTime.Hour)))\n    IF LEN(h) = 1 THEN h = \"0\" + h\n    m = LTRIM$(RTRIM$(STR$(TheTime.Minute)))\n    IF LEN(m) = 1 THEN m = \"0\" + m\n    s = LTRIM$(RTRIM$(STR$(INT(TheTime.Second))))\n    IF LEN(s) = 1 THEN s = \"0\" + s\n    n = LTRIM$(RTRIM$(STR$((INT(10 * TheTime.TenthSecond)))))\n    t = h + \":\" + m + \":\" + s ' + \":\" + n\n    LOCATE 1, (_WIDTH / 8) / 2 - LEN(t) / 2\n    PRINT t\nEND SUB\n\nSUB DrawHUD\n    COLOR _RGB32(0, 200, 200, 255), _RGB32(0, 0, 0, 0)\n    LOCATE 1, 2: PRINT \"SPACE = Midnight\"\n    LOCATE 2, 2: PRINT \"    R = Reset\"\n    LOCATE 1, 58: PRINT \"Up Arrow = Time +\"\n    LOCATE 2, 58: PRINT \"Dn Arrow = Time -\"\nEND SUB\n\nFUNCTION ColorMix~& (Shade1 AS _UNSIGNED LONG, Shade2 AS _UNSIGNED LONG, param AS DOUBLE)\n    ColorMix~& = _RGB32((1 - param) * _RED32(Shade1) + param * _RED32(Shade2), (1 - param) * _GREEN32(Shade1) + param * _GREEN32(Shade2), (1 - param) * _BLUE32(Shade1) + param * _BLUE32(Shade2))\nEND FUNCTION\n\nSUB cpset (x1, y1, col AS _UNSIGNED LONG)\n    PSET (_WIDTH / 2 + x1, -y1 + _HEIGHT / 2), col\nEND SUB\n\nSUB cline (x1 AS DOUBLE, y1 AS DOUBLE, x2 AS DOUBLE, y2 AS DOUBLE, col AS _UNSIGNED LONG)\n    LINE (_WIDTH / 2 + x1, -y1 + _HEIGHT / 2)-(_WIDTH / 2 + x2, -y2 + _HEIGHT / 2), col\nEND SUB\n\nSUB ccircle (x1 AS DOUBLE, y1 AS DOUBLE, rad AS DOUBLE, col AS _UNSIGNED LONG)\n    CIRCLE (_WIDTH / 2 + x1, -y1 + _HEIGHT / 2), rad, col\nEND SUB\n\nSUB ccirclefill (x1 AS DOUBLE, y1 AS DOUBLE, rad AS DOUBLE, col AS _UNSIGNED LONG)\n    CALL CircleFill(_WIDTH / 2 + x1, -y1 + _HEIGHT / 2, rad, col)\nEND SUB\n\nSUB CircleFill (CX AS INTEGER, CY AS INTEGER, R AS INTEGER, C AS _UNSIGNED LONG)\n    ' CX = center x coordinate\n    ' CY = center y coordinate\n    '  R = radius\n    '  C = fill color\n    DIM Radius AS INTEGER, dr AS INTEGER\n    DIM X AS INTEGER, Y AS INTEGER\n    Radius = ABS(R)\n    dr = -Radius\n    X = Radius\n    Y = 0\n    IF Radius = 0 THEN PSET (CX, CY), C: EXIT SUB\n    LINE (CX - X, CY)-(CX + X, CY), C, BF\n    WHILE X > Y\n        dr = dr + Y * 2 + 1\n        IF dr >= 0 THEN\n            IF X <> Y + 1 THEN\n                LINE (CX - Y, CY - X)-(CX + Y, CY - X), C, BF\n                LINE (CX - Y, CY + X)-(CX + Y, CY + X), C, BF\n            END IF\n            X = X - 1\n            dr = dr - X * 2\n        END IF\n        Y = Y + 1\n        LINE (CX - X, CY - Y)-(CX + X, CY - Y), C, BF\n        LINE (CX - X, CY + Y)-(CX + X, CY + Y), C, BF\n    WEND\nEND SUB\n\nSUB DrawPulley (x1 AS DOUBLE, y1 AS DOUBLE, rad1 AS DOUBLE, x2 AS DOUBLE, y2 AS DOUBLE, rad2 AS DOUBLE, col AS _UNSIGNED LONG)\n    DIM ang AS DOUBLE\n    ang = _ATAN2(y2 - y1, x2 - x1) + pi / 2\n    CALL lineSmooth(x1 + rad1 * COS(ang), y1 + rad1 * SIN(ang), x2 + rad2 * COS(ang), y2 + rad2 * SIN(ang), col)\n    CALL lineSmooth(x1 - rad1 * COS(ang), y1 - rad1 * SIN(ang), x2 - rad2 * COS(ang), y2 - rad2 * SIN(ang), col)\n    CALL ccircle(x1, y1, rad1, col)\n    CALL ccircle(x2, y2, rad2, col)\nEND SUB\n\nSUB lineSmooth (x0, y0, x1, y1, c AS _UNSIGNED LONG)\n    'FellippeHeitor 2020\n    'https://en.wikipedia.org/w/index.html?title=Xiaolin_Wu%27s_line_algorithm&oldid=852445548\n    'STxAxTIC 2020 Correction to alpha channel.\n\n    IF (1 = 1) THEN\n        CALL cline(x0, y0, x1, y1, c)\n    ELSE\n\n        DIM plX AS INTEGER, plY AS INTEGER, plI\n\n        DIM steep AS _BYTE\n        steep = ABS(y1 - y0) > ABS(x1 - x0)\n\n        IF steep THEN\n            SWAP x0, y0\n            SWAP x1, y1\n        END IF\n\n        IF x0 > x1 THEN\n            SWAP x0, x1\n            SWAP y0, y1\n        END IF\n\n        DIM dx, dy, gradient\n        dx = x1 - x0\n        dy = y1 - y0\n        gradient = dy / dx\n\n        IF dx = 0 THEN\n            gradient = 1\n        END IF\n\n        'handle first endpoint\n        DIM xend, yend, xgap, xpxl1, ypxl1\n        xend = _ROUND(x0)\n        yend = y0 + gradient * (xend - x0)\n        xgap = (1 - ((x0 + .5) - INT(x0 + .5)))\n        xpxl1 = xend 'this will be used in the main loop\n        ypxl1 = INT(yend)\n        IF steep THEN\n            plX = ypxl1\n            plY = xpxl1\n            plI = (1 - (yend - INT(yend))) * xgap\n            CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n\n            plX = ypxl1 + 1\n            plY = xpxl1\n            plI = (yend - INT(yend)) * xgap\n            CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n        ELSE\n            plX = xpxl1\n            plY = ypxl1\n            plI = (1 - (yend - INT(yend))) * xgap\n            CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n\n            plX = xpxl1\n            plY = ypxl1 + 1\n            plI = (yend - INT(yend)) * xgap\n            CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n        END IF\n\n        DIM intery\n        intery = yend + gradient 'first y-intersection for the main loop\n\n        'handle second endpoint\n        DIM xpxl2, ypxl2\n        xend = _ROUND(x1)\n        yend = y1 + gradient * (xend - x1)\n        xgap = ((x1 + .5) - INT(x1 + .5))\n        xpxl2 = xend 'this will be used in the main loop\n        ypxl2 = INT(yend)\n        IF steep THEN\n            plX = ypxl2\n            plY = xpxl2\n            plI = (1 - (yend - INT(yend))) * xgap\n            CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n\n            plX = ypxl2 + 1\n            plY = xpxl2\n            plI = (yend - INT(yend)) * xgap\n            CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n        ELSE\n            plX = xpxl2\n            plY = ypxl2\n            plI = (1 - (yend - INT(yend))) * xgap\n            CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n\n            plX = xpxl2\n            plY = ypxl2 + 1\n            plI = (yend - INT(yend)) * xgap\n            CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n        END IF\n\n        'main loop\n        DIM x\n        IF steep THEN\n            FOR x = xpxl1 + 1 TO xpxl2 - 1\n                plX = INT(intery)\n                plY = x\n                plI = (1 - (intery - INT(intery)))\n                CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n\n                plX = INT(intery) + 1\n                plY = x\n                plI = (intery - INT(intery))\n                CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n\n                intery = intery + gradient\n            NEXT\n        ELSE\n            FOR x = xpxl1 + 1 TO xpxl2 - 1\n                plX = x\n                plY = INT(intery)\n                plI = (1 - (intery - INT(intery)))\n                CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n\n                plX = x\n                plY = INT(intery) + 1\n                plI = (intery - INT(intery))\n                CALL cpset(plX, plY, _RGB32(_RED32(c), _GREEN32(c), _BLUE32(c), plI * _ALPHA32(c)))\n\n                intery = intery + gradient\n            NEXT\n        END IF\n\n        'plot:\n        ' Change to regular PSET for standard coordinate orientation.\n        'Call cpset(plX, plY, _RGB32(_Red32(c), _Green32(c), _Blue32(c), plI * _Alpha32(c)))\n        'Return\n\n    END IF\nEND SUB"
  },
  {
    "input": "Logic Circuits",
    "output": "_TITLE \"Logic Circuits\"\n\n' Use numbers 1-9 to push buttons.\n' Press left/right arrow to choose new circuit.\n\nSCREEN _NEWIMAGE(800, 600, 32)\n\nTYPE Wire\n    Identity AS _UNSIGNED LONG ' 1000-x\n    Pointer AS INTEGER ' Downstream component\n    Value AS INTEGER ' Voltage\nEND TYPE\n\nTYPE Element\n    Species AS STRING ' Type of component\n    Identity AS _UNSIGNED LONG ' Uniquely identifies component. (1-999)\n    A AS Wire\n    B AS Wire\n    C AS Wire\nEND TYPE\n\nTYPE Interact\n    Species AS STRING ' Type of Output\n    Identity AS _UNSIGNED LONG\n    Pointer AS INTEGER ' Connected component\n    Value AS INTEGER ' Voltage\nEND TYPE\n\nDIM SHARED Component(1 TO 999) AS Element\nDIM SHARED Button(1 TO 9) AS Interact\nDIM SHARED Light(1 TO 9) AS Interact\nDIM SHARED StateHistory(1 TO 4) AS STRING\n\nDIM SHARED ExampleCircuitNumber AS INTEGER\nDIM SHARED ExampleCircuitName AS STRING\n\nDIM SHARED AS _UNSIGNED LONG Greenish\nDIM SHARED AS _UNSIGNED LONG Yellowish\nGreenish = _RGB32(80, 200, 120, 255)\nYellowish = _RGB32(244, 196, 48, 255)\n\n' '''''''''' '''''''''' '''''''''' '''''''''' '''''''''' ''''''''''\n\nExampleCircuitNumber = 16\n\nCALL Initialize\nCALL LoadCircuit\n\n' Main Loop\n\nDO\n\n    CALL RefreshInput\n\n    CLS\n    LINE (0, 0)-(_WIDTH, _HEIGHT), _RGB32(255, 255, 255, 255), BF\n    COLOR _RGB32(0, 0, 0, 255), _RGB32(255, 255, 255, 255)\n    CALL PrintCircuit\n    CALL PrintInput\n    CALL PrintOutput\n    CALL PrintStateHistory\n    CALL DrawGlyph\n    CALL DrawControls\n    _DISPLAY\n\n    CALL UpdateState\n\n    _LIMIT 60\nLOOP\n\nEND\n\n' Example circuits\n\nSUB LoadCircuit\n    SELECT CASE ExampleCircuitNumber\n        CASE 1\n            ExampleCircuitName = \"On/Off Switch\"\n            'Call NewComponent(\"SPL\", 10, 1001, 2001, 2002, 20, 20)\n            'Call NewComponent(\"AND\", 20, 2001, 2002, 2005, -1, -1)\n            'Call NewButton(1, \"TOG\", 1001, 10)\n            'Call NewLight(1, \"LED\", 2005, 20)\n            CALL NewComponent(\"SPL\", 20, 1001, 2001, 2002, 10, 10)\n            CALL NewComponent(\"AND\", 10, 2001, 2002, 2005, -1, -1)\n            CALL NewButton(1, \"TOG\", 1001, 20)\n            CALL NewLight(1, \"LED\", 2005, 10)\n\n        CASE 2\n            ' --- Latch remembers first time 1 or 2 is pressed. ---\n            ExampleCircuitName = \"SR Latch\"\n            CALL NewComponent(\"NOR\", 10, 1001, 1002, 1005, -1, 20)\n            CALL NewComponent(\"NOR\", 30, 3001, 3002, 3005, -1, 40)\n            CALL NewComponent(\"SPL\", 20, 1005, 3002, 2005, 30, -1)\n            CALL NewComponent(\"SPL\", 40, 3005, 1002, 4005, 10, -1)\n            CALL NewButton(1, \"PSH\", 1001, 10)\n            CALL NewButton(2, \"PSH\", 3001, 30)\n            CALL NewLight(1, \"LED\", 2005, 20)\n            CALL NewLight(2, \"LED\", 4005, 40)\n        CASE 3\n            ' --- Button 1 and 3 only have an effect when 2 is being held. ---\n            ExampleCircuitName = \"SR Latch with Enable\"\n            CALL NewComponent(\"NOR\", 10, 1001, 1002, 1005, -1, 20)\n            CALL NewComponent(\"SPL\", 20, 1005, 3002, 2005, 30, -1)\n            CALL NewComponent(\"NOR\", 30, 3001, 3002, 3005, -1, 40)\n            CALL NewComponent(\"SPL\", 40, 3005, 1002, 4005, 10, -1)\n            CALL NewComponent(\"AND\", 50, 5001, 5002, 1001, -1, 10)\n            CALL NewComponent(\"SPL\", 60, 6001, 5002, 7002, 50, 70)\n            CALL NewComponent(\"AND\", 70, 7001, 7002, 3001, -1, 30)\n            CALL NewButton(1, \"PSH\", 5001, 50)\n            CALL NewButton(2, \"PSH\", 6001, 60)\n            CALL NewButton(3, \"PSH\", 7001, 70)\n            CALL NewLight(1, \"LED\", 2005, 20)\n            CALL NewLight(2, \"LED\", 4005, 40)\n        CASE 4\n            ' --- A pulse drives input 2. ---\n            ExampleCircuitName = \"SR Latch on Pulse\"\n            CALL NewComponent(\"NOR\", 10, 1001, 1002, 1005, -1, 20)\n            CALL NewComponent(\"SPL\", 20, 1005, 3002, 2005, 30, -1)\n            CALL NewComponent(\"NOR\", 30, 3001, 3002, 3005, -1, 40)\n            CALL NewComponent(\"SPL\", 40, 3005, 1002, 4005, 10, -1)\n            CALL NewComponent(\"AND\", 50, 5001, 5002, 1001, -1, 10)\n            CALL NewComponent(\"SPL\", 60, 6001, 5002, 7002, 50, 70)\n            CALL NewComponent(\"AND\", 70, 7001, 7002, 3001, -1, 30)\n            CALL NewButton(1, \"PSH\", 5001, 50)\n            CALL NewButton(2, \"PLS\", 6001, 60)\n            CALL NewButton(3, \"PSH\", 7001, 70)\n            CALL NewLight(1, \"LED\", 2005, 20)\n            CALL NewLight(2, \"LED\", 4005, 40)\n        CASE 5\n            ExampleCircuitName = \"D Latch\"\n            CALL NewComponent(\"NOR\", 1, 1001, 1002, 1005, -1, 2)\n            CALL NewComponent(\"SPL\", 2, 1005, 3002, 2005, 3, -1)\n            CALL NewComponent(\"NOR\", 3, 3001, 3002, 3005, -1, 4)\n            CALL NewComponent(\"SPL\", 4, 3005, 1002, 4005, 1, -1)\n            CALL NewComponent(\"AND\", 5, 5001, 5002, 1001, -1, 1)\n            CALL NewComponent(\"SPL\", 6, 6001, 5002, 7002, 5, 7)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 3001, -1, 3)\n            CALL NewComponent(\"SPL\", 8, 8001, 7001, 9001, 7, 9)\n            CALL NewComponent(\"INV\", 9, 9001, 5001, 0, 5, -1)\n            CALL NewButton(1, \"PSH\", 8001, 8)\n            CALL NewButton(2, \"PSH\", 6001, 6)\n            CALL NewLight(1, \"LED\", 2005, 2)\n            CALL NewLight(2, \"LED\", 4005, 4)\n        CASE 6\n            ExampleCircuitName = \"Half Adder\"\n            CALL NewComponent(\"XOR\", 10, 1001, 1002, 1005, -1, -1)\n            CALL NewComponent(\"SPL\", 20, 2001, 1001, 3001, 10, 30)\n            CALL NewComponent(\"AND\", 30, 3001, 3002, 3005, -1, -1)\n            CALL NewComponent(\"SPL\", 40, 4001, 1002, 3002, 10, 30)\n            CALL NewButton(1, \"PSH\", 2001, 20)\n            CALL NewButton(2, \"PSH\", 4001, 40)\n            CALL NewLight(1, \"LED\", 1005, 10)\n            CALL NewLight(2, \"LED\", 3005, 30)\n        CASE 7\n            ExampleCircuitName = \"Full Adder\"\n            CALL NewComponent(\"XOR\", 10, 1001, 1002, 1005, -1, -1)\n            CALL NewComponent(\"SPL\", 20, 6005, 1001, 4002, 10, 40)\n            CALL NewComponent(\"SPL\", 30, 3001, 1002, 4001, 10, 40)\n            CALL NewComponent(\"AND\", 40, 4001, 4002, 5001, -1, 50)\n            CALL NewComponent(\"OR\", 50, 5001, 5002, 5005, 10, 30)\n            CALL NewComponent(\"XOR\", 60, 6001, 6002, 6005, -1, 20)\n            CALL NewComponent(\"AND\", 70, 7001, 7002, 5002, -1, 50)\n            CALL NewComponent(\"SPL\", 80, 8001, 6001, 7002, 60, 70)\n            CALL NewComponent(\"SPL\", 90, 9001, 6002, 7001, 60, 70)\n            CALL NewButton(1, \"PSH\", 8001, 80) 'n1\n            CALL NewButton(2, \"PSH\", 9001, 90) 'n2\n            CALL NewButton(3, \"PSH\", 3001, 30) 'carry in\n            CALL NewLight(1, \"LED\", 5005, 50) 'carry out\n            CALL NewLight(2, \"LED\", 1005, 10) 'sum\n        CASE 8\n            ExampleCircuitName = \"2 Bit Adder\"\n            CALL NewComponent(\"XOR\", 1, 1001, 1002, 1005, -1, -1)\n            CALL NewComponent(\"SPL\", 2, 6005, 1001, 4002, 1, 4)\n            CALL NewComponent(\"SPL\", 3, 3001, 1002, 4001, 1, 4)\n            CALL NewComponent(\"AND\", 4, 4001, 4002, 5001, -1, 5)\n            CALL NewComponent(\"OR\", 5, 5001, 5002, 5005, -1, 13)\n            CALL NewComponent(\"XOR\", 6, 6001, 6002, 6005, -1, 2)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 5002, -1, 5)\n            CALL NewComponent(\"SPL\", 8, 8001, 6001, 7002, 6, 7)\n            CALL NewComponent(\"SPL\", 9, 9001, 6002, 7001, 6, 7)\n            CALL NewComponent(\"XOR\", 11, 11001, 11002, 11005, -1, -1)\n            CALL NewComponent(\"SPL\", 12, 16005, 11001, 14002, 11, 14)\n            CALL NewComponent(\"SPL\", 13, 5005, 11002, 14001, 11, 14)\n            CALL NewComponent(\"AND\", 14, 14001, 14002, 15001, -1, 15)\n            CALL NewComponent(\"OR\", 15, 15001, 15002, 15005, -1, -1)\n            CALL NewComponent(\"XOR\", 16, 16001, 16002, 16005, -1, 12)\n            CALL NewComponent(\"AND\", 17, 17001, 17002, 15002, -1, 15)\n            CALL NewComponent(\"SPL\", 18, 18001, 16001, 17002, 16, 17)\n            CALL NewComponent(\"SPL\", 19, 19001, 16002, 17001, 16, 17)\n            CALL NewButton(9, \"PSH\", 3001, 3) 'carry in\n            CALL NewButton(1, \"TOG\", 8001, 8) 'a0\n            CALL NewButton(2, \"TOG\", 9001, 9) 'b0\n            CALL NewButton(3, \"TOG\", 18001, 18) 'a1\n            CALL NewButton(4, \"TOG\", 19001, 19) 'b1\n            CALL NewLight(1, \"LED\", 15005, 15) 'carry out\n            CALL NewLight(2, \"LED\", 11005, 11) 'sum1\n            CALL NewLight(3, \"LED\", 1005, 1) 'sum0\n        CASE 9\n            ExampleCircuitName = \"3 Bit Adder\"\n            CALL NewComponent(\"XOR\", 1, 1001, 1002, 1005, -1, -1)\n            CALL NewComponent(\"SPL\", 2, 6005, 1001, 4002, 1, 4)\n            CALL NewComponent(\"SPL\", 3, 3001, 1002, 4001, 1, 4)\n            CALL NewComponent(\"AND\", 4, 4001, 4002, 5001, -1, 5)\n            CALL NewComponent(\"OR\", 5, 5001, 5002, 5005, -1, 13)\n            CALL NewComponent(\"XOR\", 6, 6001, 6002, 6005, -1, 2)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 5002, -1, 5)\n            CALL NewComponent(\"SPL\", 8, 8001, 6001, 7002, 6, 7)\n            CALL NewComponent(\"SPL\", 9, 9001, 6002, 7001, 6, 7)\n            CALL NewComponent(\"XOR\", 11, 11001, 11002, 11005, -1, -1)\n            CALL NewComponent(\"SPL\", 12, 16005, 11001, 14002, 11, 14)\n            CALL NewComponent(\"SPL\", 13, 5005, 11002, 14001, 11, 14)\n            CALL NewComponent(\"AND\", 14, 14001, 14002, 15001, -1, 15)\n            CALL NewComponent(\"OR\", 15, 15001, 15002, 15005, -1, 23)\n            CALL NewComponent(\"XOR\", 16, 16001, 16002, 16005, -1, 12)\n            CALL NewComponent(\"AND\", 17, 17001, 17002, 15002, -1, 15)\n            CALL NewComponent(\"SPL\", 18, 18001, 16001, 17002, 16, 17)\n            CALL NewComponent(\"SPL\", 19, 19001, 16002, 17001, 16, 17)\n            CALL NewComponent(\"XOR\", 21, 21001, 21002, 21005, -1, -1)\n            CALL NewComponent(\"SPL\", 22, 26005, 21001, 24002, 21, 24)\n            CALL NewComponent(\"SPL\", 23, 15005, 21002, 24001, 21, 24)\n            CALL NewComponent(\"AND\", 24, 24001, 24002, 25001, -1, 25)\n            CALL NewComponent(\"OR\", 25, 25001, 25002, 25005, -1, -1)\n            CALL NewComponent(\"XOR\", 26, 26001, 26002, 26005, -1, 22)\n            CALL NewComponent(\"AND\", 27, 27001, 27002, 25002, -1, 25)\n            CALL NewComponent(\"SPL\", 28, 28001, 26001, 27002, 26, 27)\n            CALL NewComponent(\"SPL\", 29, 29001, 26002, 27001, 26, 27)\n            CALL NewButton(9, \"PSH\", 3001, 3) 'carry in\n            CALL NewButton(1, \"TOG\", 8001, 8) 'a0\n            CALL NewButton(2, \"TOG\", 9001, 9) 'b0\n            CALL NewButton(3, \"TOG\", 18001, 18) 'a1\n            CALL NewButton(4, \"TOG\", 19001, 19) 'b1\n            CALL NewButton(5, \"TOG\", 28001, 28) 'a2\n            CALL NewButton(6, \"TOG\", 29001, 29) 'b2\n            CALL NewLight(1, \"LED\", 25005, 25) 'carry out\n            CALL NewLight(2, \"LED\", 21005, 21) 'sum2\n            CALL NewLight(3, \"LED\", 11005, 11) 'sum1\n            CALL NewLight(4, \"LED\", 1005, 1) 'sum0\n        CASE 10\n            ExampleCircuitName = \"4 Bit Adder\"\n            CALL NewComponent(\"XOR\", 1, 1001, 1002, 1005, -1, -1)\n            CALL NewComponent(\"SPL\", 2, 6005, 1001, 4002, 1, 4)\n            CALL NewComponent(\"SPL\", 3, 3001, 1002, 4001, 1, 4)\n            CALL NewComponent(\"AND\", 4, 4001, 4002, 5001, -1, 5)\n            CALL NewComponent(\"OR\", 5, 5001, 5002, 5005, -1, 13)\n            CALL NewComponent(\"XOR\", 6, 6001, 6002, 6005, -1, 2)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 5002, -1, 5)\n            CALL NewComponent(\"SPL\", 8, 8001, 6001, 7002, 6, 7)\n            CALL NewComponent(\"SPL\", 9, 9001, 6002, 7001, 6, 7)\n            CALL NewComponent(\"XOR\", 11, 11001, 11002, 11005, -1, -1)\n            CALL NewComponent(\"SPL\", 12, 16005, 11001, 14002, 11, 14)\n            CALL NewComponent(\"SPL\", 13, 5005, 11002, 14001, 11, 14)\n            CALL NewComponent(\"AND\", 14, 14001, 14002, 15001, -1, 15)\n            CALL NewComponent(\"OR\", 15, 15001, 15002, 15005, -1, 23)\n            CALL NewComponent(\"XOR\", 16, 16001, 16002, 16005, -1, 12)\n            CALL NewComponent(\"AND\", 17, 17001, 17002, 15002, -1, 15)\n            CALL NewComponent(\"SPL\", 18, 18001, 16001, 17002, 16, 17)\n            CALL NewComponent(\"SPL\", 19, 19001, 16002, 17001, 16, 17)\n            CALL NewComponent(\"XOR\", 21, 21001, 21002, 21005, -1, -1)\n            CALL NewComponent(\"SPL\", 22, 26005, 21001, 24002, 21, 24)\n            CALL NewComponent(\"SPL\", 23, 15005, 21002, 24001, 21, 24)\n            CALL NewComponent(\"AND\", 24, 24001, 24002, 25001, -1, 25)\n            CALL NewComponent(\"OR\", 25, 25001, 25002, 25005, -1, 33)\n            CALL NewComponent(\"XOR\", 26, 26001, 26002, 26005, -1, 22)\n            CALL NewComponent(\"AND\", 27, 27001, 27002, 25002, -1, 25)\n            CALL NewComponent(\"SPL\", 28, 28001, 26001, 27002, 26, 27)\n            CALL NewComponent(\"SPL\", 29, 29001, 26002, 27001, 26, 27)\n            CALL NewComponent(\"XOR\", 31, 31001, 31002, 31005, -1, -1)\n            CALL NewComponent(\"SPL\", 32, 36005, 31001, 34002, 31, 34)\n            CALL NewComponent(\"SPL\", 33, 25005, 31002, 34001, 31, 34)\n            CALL NewComponent(\"AND\", 34, 34001, 34002, 35001, -1, 35)\n            CALL NewComponent(\"OR\", 35, 35001, 35002, 35005, -1, -1)\n            CALL NewComponent(\"XOR\", 36, 36001, 36002, 36005, -1, 32)\n            CALL NewComponent(\"AND\", 37, 37001, 37002, 35002, -1, 35)\n            CALL NewComponent(\"SPL\", 38, 38001, 36001, 37002, 36, 37)\n            CALL NewComponent(\"SPL\", 39, 39001, 36002, 37001, 36, 37)\n            CALL NewButton(9, \"PSH\", 3001, 3) 'carry in\n            CALL NewButton(1, \"TOG\", 8001, 8) 'a0\n            CALL NewButton(2, \"TOG\", 9001, 9) 'b0\n            CALL NewButton(3, \"TOG\", 18001, 18) 'a1\n            CALL NewButton(4, \"TOG\", 19001, 19) 'b1\n            CALL NewButton(5, \"TOG\", 28001, 28) 'a2\n            CALL NewButton(6, \"TOG\", 29001, 29) 'b2\n            CALL NewButton(7, \"TOG\", 38001, 38) 'a3\n            CALL NewButton(8, \"TOG\", 39001, 39) 'b3\n            CALL NewLight(1, \"LED\", 35005, 35) 'carry out\n            CALL NewLight(2, \"LED\", 31005, 31) 'sum3\n            CALL NewLight(3, \"LED\", 21005, 21) 'sum2\n            CALL NewLight(4, \"LED\", 11005, 11) 'sum1\n            CALL NewLight(5, \"LED\", 1005, 1) 'sum0\n        CASE 11\n            ExampleCircuitName = \"Edge Detector\"\n            CALL NewComponent(\"SPL\", 1, 1001, 2002, 3001, 2, 3)\n            CALL NewComponent(\"INV\", 2, 2002, 4001, 0, 4, -1)\n            CALL NewComponent(\"AND\", 3, 3001, 3002, 3010, -1, -1)\n            CALL NewComponent(\"INV\", 4, 4001, 5001, 0, 5, -1) ' pair of extra inverters\n            CALL NewComponent(\"INV\", 5, 5001, 3002, 0, 3, -1) ' (must be a pair)\n            CALL NewButton(1, \"PSH\", 1001, 1)\n            CALL NewLight(1, \"LED\", 3010, 3)\n        CASE 12\n            ExampleCircuitName = \"D Flip-Flop\"\n            CALL NewComponent(\"NOR\", 1, 1001, 1002, 1005, -1, 2)\n            CALL NewComponent(\"SPL\", 2, 1005, 3002, 2005, 3, -1)\n            CALL NewComponent(\"NOR\", 3, 3001, 3002, 3005, -1, 4)\n            CALL NewComponent(\"SPL\", 4, 3005, 1002, 4005, 1, -1)\n            CALL NewComponent(\"AND\", 5, 5001, 5002, 1001, -1, 1)\n            CALL NewComponent(\"SPL\", 6, 6001, 5002, 7002, 5, 7)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 3001, -1, 3)\n            CALL NewComponent(\"SPL\", 8, 8001, 7001, 9001, 7, 9)\n            CALL NewComponent(\"INV\", 9, 9001, 5001, 0, 5, -1)\n            CALL NewComponent(\"SPL\", 11, 11001, 12002, 13001, 12, 13)\n            CALL NewComponent(\"INV\", 12, 12002, 14001, 0, 14, -1)\n            CALL NewComponent(\"AND\", 13, 13001, 13002, 6001, -1, 6)\n            CALL NewComponent(\"INV\", 14, 14001, 15001, 0, 15, -1) ' pair of extra inverters\n            CALL NewComponent(\"INV\", 15, 15001, 13002, 0, 13, -1) ' (must be a pair)\n            CALL NewButton(1, \"PSH\", 8001, 8) ' data\n            CALL NewButton(2, \"PSH\", 11001, 11) ' enable\n            CALL NewLight(1, \"LED\", 2005, 2)\n            CALL NewLight(2, \"LED\", 4005, 4) ' often omitted for clarity\n        CASE 13\n            ExampleCircuitName = \"1 Bit Counter\"\n            CALL NewComponent(\"NOR\", 1, 1001, 1002, 1005, -1, 2)\n            CALL NewComponent(\"SPL\", 2, 1005, 3002, 2005, 3, -1)\n            CALL NewComponent(\"NOR\", 3, 3001, 3002, 3005, -1, 4)\n            CALL NewComponent(\"SPL\", 4, 3005, 1002, 8001, 1, 8)\n            CALL NewComponent(\"AND\", 5, 5001, 5002, 1001, -1, 1)\n            CALL NewComponent(\"SPL\", 6, 6001, 5002, 7002, 5, 7)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 3001, -1, 3)\n            CALL NewComponent(\"SPL\", 8, 8001, 7001, 9001, 7, 9)\n            CALL NewComponent(\"INV\", 9, 9001, 5001, 0, 5, -1)\n            CALL NewComponent(\"SPL\", 11, 11001, 12002, 13001, 12, 13)\n            CALL NewComponent(\"INV\", 12, 12002, 14001, 0, 14, -1)\n            CALL NewComponent(\"AND\", 13, 13001, 13002, 6001, -1, 6)\n            CALL NewComponent(\"INV\", 14, 14001, 15001, 0, 15, -1)\n            CALL NewComponent(\"INV\", 15, 15001, 13002, 0, 13, -1)\n            CALL NewButton(1, \"PSH\", 11001, 11)\n            CALL NewLight(1, \"LED\", 8001, 8)\n        CASE 14\n            ExampleCircuitName = \"2 Bit Counter\"\n            CALL NewComponent(\"NOR\", 1, 1001, 1002, 1005, -1, 2)\n            CALL NewComponent(\"SPL\", 2, 1005, 3002, 31001, 3, 31)\n            CALL NewComponent(\"NOR\", 3, 3001, 3002, 3005, -1, 4)\n            CALL NewComponent(\"SPL\", 4, 3005, 1002, 8001, 1, 8)\n            CALL NewComponent(\"AND\", 5, 5001, 5002, 1001, -1, 1)\n            CALL NewComponent(\"SPL\", 6, 6001, 5002, 7002, 5, 7)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 3001, -1, 3)\n            CALL NewComponent(\"SPL\", 8, 8001, 7001, 9001, 7, 9)\n            CALL NewComponent(\"INV\", 9, 9001, 5001, 0, 5, -1)\n            CALL NewComponent(\"SPL\", 11, 11001, 12002, 13001, 12, 13)\n            CALL NewComponent(\"INV\", 12, 12002, 14001, 0, 14, -1)\n            CALL NewComponent(\"AND\", 13, 13001, 13002, 6001, -1, 6)\n            CALL NewComponent(\"INV\", 14, 14001, 15001, 0, 15, -1)\n            CALL NewComponent(\"INV\", 15, 15001, 13002, 0, 13, -1)\n            CALL NewComponent(\"NOR\", 21, 21001, 21002, 21005, -1, 22)\n            CALL NewComponent(\"SPL\", 22, 21005, 23002, 22005, 23, -1)\n            CALL NewComponent(\"NOR\", 23, 23001, 23002, 23005, -1, 24)\n            CALL NewComponent(\"SPL\", 24, 23005, 21002, 28001, 21, 28)\n            CALL NewComponent(\"AND\", 25, 25001, 25002, 21001, -1, 21)\n            CALL NewComponent(\"SPL\", 26, 26001, 25002, 27002, 25, 27)\n            CALL NewComponent(\"AND\", 27, 27001, 27002, 23001, -1, 23)\n            CALL NewComponent(\"SPL\", 28, 28001, 27001, 29001, 27, 29)\n            CALL NewComponent(\"INV\", 29, 29001, 25001, 0, 25, -1)\n            CALL NewComponent(\"SPL\", 31, 31001, 32002, 33001, 32, 33)\n            CALL NewComponent(\"INV\", 32, 32002, 34001, 0, 34, -1)\n            CALL NewComponent(\"AND\", 33, 33001, 33002, 26001, -1, 26)\n            CALL NewComponent(\"INV\", 34, 34001, 35001, 0, 35, -1)\n            CALL NewComponent(\"INV\", 35, 35001, 33002, 0, 33, -1)\n            CALL NewButton(1, \"PSH\", 11001, 11)\n            CALL NewLight(1, \"LED\", 8001, 8)\n            CALL NewLight(2, \"LED\", 28001, 28)\n        CASE 15\n            ExampleCircuitName = \"3 Bit Counter\"\n            CALL NewComponent(\"NOR\", 1, 1001, 1002, 1005, -1, 2)\n            CALL NewComponent(\"SPL\", 2, 1005, 3002, 31001, 3, 31)\n            CALL NewComponent(\"NOR\", 3, 3001, 3002, 3005, -1, 4)\n            CALL NewComponent(\"SPL\", 4, 3005, 1002, 8001, 1, 8)\n            CALL NewComponent(\"AND\", 5, 5001, 5002, 1001, -1, 1)\n            CALL NewComponent(\"SPL\", 6, 6001, 5002, 7002, 5, 7)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 3001, -1, 3)\n            CALL NewComponent(\"SPL\", 8, 8001, 7001, 9001, 7, 9)\n            CALL NewComponent(\"INV\", 9, 9001, 5001, 0, 5, -1)\n            CALL NewComponent(\"SPL\", 11, 11001, 12002, 13001, 12, 13)\n            CALL NewComponent(\"INV\", 12, 12002, 14001, 0, 14, -1)\n            CALL NewComponent(\"AND\", 13, 13001, 13002, 6001, -1, 6)\n            CALL NewComponent(\"INV\", 14, 14001, 15001, 0, 15, -1)\n            CALL NewComponent(\"INV\", 15, 15001, 13002, 0, 13, -1)\n            CALL NewComponent(\"NOR\", 21, 21001, 21002, 21005, -1, 22)\n            CALL NewComponent(\"SPL\", 22, 21005, 23002, 51001, 23, 51)\n            CALL NewComponent(\"NOR\", 23, 23001, 23002, 23005, -1, 24)\n            CALL NewComponent(\"SPL\", 24, 23005, 21002, 28001, 21, 28)\n            CALL NewComponent(\"AND\", 25, 25001, 25002, 21001, -1, 21)\n            CALL NewComponent(\"SPL\", 26, 26001, 25002, 27002, 25, 27)\n            CALL NewComponent(\"AND\", 27, 27001, 27002, 23001, -1, 23)\n            CALL NewComponent(\"SPL\", 28, 28001, 27001, 29001, 27, 29)\n            CALL NewComponent(\"INV\", 29, 29001, 25001, 0, 25, -1)\n            CALL NewComponent(\"SPL\", 31, 31001, 32002, 33001, 32, 33)\n            CALL NewComponent(\"INV\", 32, 32002, 34001, 0, 34, -1)\n            CALL NewComponent(\"AND\", 33, 33001, 33002, 26001, -1, 26)\n            CALL NewComponent(\"INV\", 34, 34001, 35001, 0, 35, -1)\n            CALL NewComponent(\"INV\", 35, 35001, 33002, 0, 33, -1)\n            CALL NewComponent(\"NOR\", 41, 41001, 41002, 41005, -1, 42)\n            CALL NewComponent(\"SPL\", 42, 41005, 43002, 42005, 43, -1)\n            CALL NewComponent(\"NOR\", 43, 43001, 43002, 43005, -1, 44)\n            CALL NewComponent(\"SPL\", 44, 43005, 41002, 48001, 41, 48)\n            CALL NewComponent(\"AND\", 45, 45001, 45002, 41001, -1, 41)\n            CALL NewComponent(\"SPL\", 46, 46001, 45002, 47002, 45, 47)\n            CALL NewComponent(\"AND\", 47, 47001, 47002, 43001, -1, 43)\n            CALL NewComponent(\"SPL\", 48, 48001, 47001, 49001, 47, 49)\n            CALL NewComponent(\"INV\", 49, 49001, 45001, 0, 45, -1)\n            CALL NewComponent(\"SPL\", 51, 51001, 52002, 53001, 52, 53)\n            CALL NewComponent(\"INV\", 52, 52002, 54001, 0, 54, -1)\n            CALL NewComponent(\"AND\", 53, 53001, 53002, 46001, -1, 46)\n            CALL NewComponent(\"INV\", 54, 54001, 55001, 0, 55, -1)\n            CALL NewComponent(\"INV\", 55, 55001, 53002, 0, 53, -1)\n            CALL NewButton(1, \"PSH\", 11001, 11)\n            CALL NewLight(1, \"LED\", 8001, 8)\n            CALL NewLight(2, \"LED\", 28001, 28)\n            CALL NewLight(3, \"LED\", 48001, 48)\n        CASE 16\n            ExampleCircuitName = \"4 Bit Counter\"\n            CALL NewComponent(\"NOR\", 1, 1001, 1002, 1005, -1, 2)\n            CALL NewComponent(\"SPL\", 2, 1005, 3002, 31001, 3, 31)\n            CALL NewComponent(\"NOR\", 3, 3001, 3002, 3005, -1, 4)\n            CALL NewComponent(\"SPL\", 4, 3005, 1002, 8001, 1, 8)\n            CALL NewComponent(\"AND\", 5, 5001, 5002, 1001, -1, 1)\n            CALL NewComponent(\"SPL\", 6, 6001, 5002, 7002, 5, 7)\n            CALL NewComponent(\"AND\", 7, 7001, 7002, 3001, -1, 3)\n            CALL NewComponent(\"SPL\", 8, 8001, 7001, 9001, 7, 9)\n            CALL NewComponent(\"INV\", 9, 9001, 5001, 0, 5, -1)\n            CALL NewComponent(\"SPL\", 11, 11001, 12002, 13001, 12, 13)\n            CALL NewComponent(\"INV\", 12, 12002, 14001, 0, 14, -1)\n            CALL NewComponent(\"AND\", 13, 13001, 13002, 6001, -1, 6)\n            CALL NewComponent(\"INV\", 14, 14001, 15001, 0, 15, -1)\n            CALL NewComponent(\"INV\", 15, 15001, 13002, 0, 13, -1)\n            CALL NewComponent(\"NOR\", 21, 21001, 21002, 21005, -1, 22)\n            CALL NewComponent(\"SPL\", 22, 21005, 23002, 51001, 23, 51)\n            CALL NewComponent(\"NOR\", 23, 23001, 23002, 23005, -1, 24)\n            CALL NewComponent(\"SPL\", 24, 23005, 21002, 28001, 21, 28)\n            CALL NewComponent(\"AND\", 25, 25001, 25002, 21001, -1, 21)\n            CALL NewComponent(\"SPL\", 26, 26001, 25002, 27002, 25, 27)\n            CALL NewComponent(\"AND\", 27, 27001, 27002, 23001, -1, 23)\n            CALL NewComponent(\"SPL\", 28, 28001, 27001, 29001, 27, 29)\n            CALL NewComponent(\"INV\", 29, 29001, 25001, 0, 25, -1)\n            CALL NewComponent(\"SPL\", 31, 31001, 32002, 33001, 32, 33)\n            CALL NewComponent(\"INV\", 32, 32002, 34001, 0, 34, -1)\n            CALL NewComponent(\"AND\", 33, 33001, 33002, 26001, -1, 26)\n            CALL NewComponent(\"INV\", 34, 34001, 35001, 0, 35, -1)\n            CALL NewComponent(\"INV\", 35, 35001, 33002, 0, 33, -1)\n            CALL NewComponent(\"NOR\", 41, 41001, 41002, 41005, -1, 42)\n            CALL NewComponent(\"SPL\", 42, 41005, 43002, 71001, 43, 71)\n            CALL NewComponent(\"NOR\", 43, 43001, 43002, 43005, -1, 44)\n            CALL NewComponent(\"SPL\", 44, 43005, 41002, 48001, 41, 48)\n            CALL NewComponent(\"AND\", 45, 45001, 45002, 41001, -1, 41)\n            CALL NewComponent(\"SPL\", 46, 46001, 45002, 47002, 45, 47)\n            CALL NewComponent(\"AND\", 47, 47001, 47002, 43001, -1, 43)\n            CALL NewComponent(\"SPL\", 48, 48001, 47001, 49001, 47, 49)\n            CALL NewComponent(\"INV\", 49, 49001, 45001, 0, 45, -1)\n            CALL NewComponent(\"SPL\", 51, 51001, 52002, 53001, 52, 53)\n            CALL NewComponent(\"INV\", 52, 52002, 54001, 0, 54, -1)\n            CALL NewComponent(\"AND\", 53, 53001, 53002, 46001, -1, 46)\n            CALL NewComponent(\"INV\", 54, 54001, 55001, 0, 55, -1)\n            CALL NewComponent(\"INV\", 55, 55001, 53002, 0, 53, -1)\n            CALL NewComponent(\"NOR\", 61, 61001, 61002, 61005, -1, 62)\n            CALL NewComponent(\"SPL\", 62, 61005, 63002, 62005, 63, -1)\n            CALL NewComponent(\"NOR\", 63, 63001, 63002, 63005, -1, 64)\n            CALL NewComponent(\"SPL\", 64, 63005, 61002, 68001, 61, 68)\n            CALL NewComponent(\"AND\", 65, 65001, 65002, 61001, -1, 61)\n            CALL NewComponent(\"SPL\", 66, 66001, 65002, 67002, 65, 67)\n            CALL NewComponent(\"AND\", 67, 67001, 67002, 63001, -1, 63)\n            CALL NewComponent(\"SPL\", 68, 68001, 67001, 69001, 67, 69)\n            CALL NewComponent(\"INV\", 69, 69001, 65001, 0, 65, -1)\n            CALL NewComponent(\"SPL\", 71, 71001, 72002, 73001, 72, 73)\n            CALL NewComponent(\"INV\", 72, 72002, 74001, 0, 74, -1)\n            CALL NewComponent(\"AND\", 73, 73001, 73002, 66001, -1, 66)\n            CALL NewComponent(\"INV\", 74, 74001, 75001, 0, 75, -1)\n            CALL NewComponent(\"INV\", 75, 75001, 73002, 0, 73, -1)\n            CALL NewButton(1, \"PLS\", 11001, 11)\n            CALL NewLight(1, \"LED\", 8001, 8)\n            CALL NewLight(2, \"LED\", 28001, 28)\n            CALL NewLight(3, \"LED\", 48001, 48)\n            CALL NewLight(4, \"LED\", 68001, 68)\n        CASE ELSE\n            ExampleCircuitName = \"\"\n    END SELECT\nEND SUB\n\n' '''''''''' '''''''''' '''''''''' '''''''''' '''''''''' ''''''''''\n\n' Subs and Functions\n\nSUB Initialize\n    DIM k AS INTEGER\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        Component(k).Species = \"\"\n        Component(k).Identity = 0\n        Component(k).A.Identity = 0\n        Component(k).B.Identity = 0\n        Component(k).C.Identity = 0\n        Component(k).A.Pointer = 0\n        Component(k).B.Pointer = 0\n        Component(k).C.Pointer = 0\n        Component(k).A.Value = 0\n        Component(k).B.Value = 0\n        Component(k).C.Value = 0\n    NEXT\n    FOR k = LBOUND(Button) TO UBOUND(Button)\n        Button(k).Species = \"\"\n        Button(k).Identity = 0\n        Button(k).Pointer = 0\n        Button(k).Value = 0\n    NEXT\n    FOR k = LBOUND(Light) TO UBOUND(Light)\n        Light(k).Species = \"\"\n        Light(k).Identity = 0\n        Light(k).Pointer = 0\n        Light(k).Value = 0\n    NEXT\n    FOR k = LBOUND(StateHistory) TO UBOUND(StateHistory)\n        StateHistory(k) = \"\"\n    NEXT\nEND SUB\n\nSUB Ground\n    DIM k AS INTEGER\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        Component(k).A.Value = 0\n        Component(k).B.Value = 0\n        Component(k).C.Value = 0\n    NEXT\n    FOR k = LBOUND(Button) TO UBOUND(Button)\n        Button(k).Value = 0\n    NEXT\n    FOR k = LBOUND(Light) TO UBOUND(Light)\n        Light(k).Value = 0\n    NEXT\nEND SUB\n\nSUB NewComponent (TheSpecies AS STRING, TheIdentity AS _UNSIGNED LONG, WireAId AS _UNSIGNED LONG, WireBId AS _UNSIGNED LONG, WireCId AS _UNSIGNED LONG, WireBPo AS INTEGER, WireCPo AS INTEGER)\n    Component(TheIdentity).Species = TheSpecies\n    Component(TheIdentity).Identity = TheIdentity\n    Component(TheIdentity).A.Identity = WireAId\n    Component(TheIdentity).B.Identity = WireBId\n    Component(TheIdentity).C.Identity = WireCId\n    'Component(TheIdentity).A.Pointer = WireAPo\n    Component(TheIdentity).B.Pointer = WireBPo\n    Component(TheIdentity).C.Pointer = WireCPo\nEND SUB\n\nSUB NewButton (TheIndex AS INTEGER, TheSpecies AS STRING, TheIdentity AS _UNSIGNED LONG, ThePointer AS INTEGER)\n    Button(TheIndex).Species = TheSpecies\n    Button(TheIndex).Identity = TheIdentity\n    Button(TheIndex).Pointer = ThePointer\nEND SUB\n\nSUB NewLight (TheIndex AS INTEGER, TheSpecies AS STRING, TheIdentity AS _UNSIGNED LONG, ThePointer AS INTEGER)\n    Light(TheIndex).Species = TheSpecies\n    Light(TheIndex).Identity = TheIdentity\n    Light(TheIndex).Pointer = ThePointer\nEND SUB\n\nSUB RefreshInput\n    DIM AS _UNSIGNED LONG r\n    DIM AS INTEGER h, i, j, k, q\n    DIM AS DOUBLE t\n    h = _KEYHIT\n\n    FOR i = 48 + LBOUND(Button) TO 48 + UBOUND(Button)\n        k = i - 48\n        SELECT CASE Button(k).Species\n            CASE \"\"\n                ' Unused\n            CASE \"PSH\" ' PuSHy Inputs\n                IF (_KEYDOWN(i) <> 0) THEN\n                    q = 1\n                ELSE\n                    q = 0\n                END IF\n                r = Button(k).Identity\n                j = Button(k).Pointer\n                IF (r = Component(j).A.Identity) THEN\n                    Component(j).A.Value = q\n                ELSEIF (r = Component(j).B.Identity) THEN\n                    Component(j).B.Value = q\n                ELSEIF (r = Component(j).C.Identity) THEN\n                    Component(j).C.Value = q\n                END IF\n            CASE \"TOG\" ' Sticky Inputs\n                IF (h = i) THEN\n                    r = Button(k).Identity\n                    j = Button(k).Pointer\n                    IF (r = Component(j).A.Identity) THEN\n                        q = Component(j).A.Value\n                        IF (q = 0) THEN\n                            Component(j).A.Value = 1\n                        ELSE\n                            Component(j).A.Value = 0\n                        END IF\n                    END IF\n                    IF (r = Component(j).B.Identity) THEN\n                        q = Component(j).B.Value\n                        IF (q = 0) THEN\n                            Component(j).B.Value = 1\n                        ELSE\n                            Component(j).B.Value = 0\n                        END IF\n                    END IF\n                    IF (r = Component(j).C.Identity) THEN\n                        q = Component(j).C.Value\n                        IF (q = 0) THEN\n                            Component(j).C.Value = 1\n                        ELSE\n                            Component(j).C.Value = 0\n                        END IF\n                    END IF\n                END IF\n            CASE \"PLS\" ' Pulse\n                t = TIMER\n                t = t - INT(t)\n                IF (t >= 2 / 3) THEN q = 1 ELSE q = 0\n                IF (k <= UBOUND(Button)) THEN\n                    r = Button(k).Identity\n                    j = Button(k).Pointer\n                    IF (j <> -1) THEN\n                        IF (r = Component(j).A.Identity) THEN\n                            Component(j).A.Value = q\n                        ELSEIF (r = Component(j).B.Identity) THEN\n                            Component(j).B.Value = q\n                        ELSEIF (r = Component(j).C.Identity) THEN\n                            Component(j).C.Value = q\n                        END IF\n                    END IF\n                END IF\n        END SELECT\n    NEXT\n\n    IF (h = 19712) THEN ' rightarrow\n        ExampleCircuitNumber = ExampleCircuitNumber + 1\n        IF (ExampleCircuitNumber > 16) THEN ExampleCircuitNumber = 1\n        CALL Initialize\n        CALL LoadCircuit\n    END IF\n\n    IF (h = 19200) THEN ' leftarrow\n        ExampleCircuitNumber = ExampleCircuitNumber - 1\n        IF (ExampleCircuitNumber < 1) THEN ExampleCircuitNumber = 16\n        CALL Initialize\n        CALL LoadCircuit\n    END IF\n\n    IF (h = 48) THEN ' 0\n        CALL Ground\n    END IF\n\n    _KEYCLEAR\nEND SUB\n\nSUB UpdateState\n    DIM AS INTEGER j, k, a, b, c\n    DIM AS _UNSIGNED LONG g\n\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        IF (Component(k).Species <> \"\") THEN\n\n            IF INSTR(\"AND NOR OR XOR\", Component(k).Species) > 0 THEN\n                a = Component(k).A.Value\n                b = Component(k).B.Value\n                ' Update self\n                SELECT CASE Component(k).Species\n                    CASE \"AND\"\n                        Component(k).C.Value = BinaryAND(a, b)\n                    CASE \"NOR\"\n                        Component(k).C.Value = BinaryNOR(a, b)\n                    CASE \"OR\"\n                        Component(k).C.Value = BinaryOR(a, b)\n                    CASE \"XOR\"\n                        Component(k).C.Value = BinaryXOR(a, b)\n                END SELECT\n                ' Update downstream\n                j = Component(k).C.Pointer\n                IF (j <> -1) THEN\n                    g = Component(k).C.Identity\n                    c = Component(k).C.Value\n                    IF (Component(j).A.Identity = g) THEN\n                        Component(j).A.Value = c\n                    ELSEIF (Component(j).B.Identity = g) THEN\n                        Component(j).B.Value = c\n                    END IF\n                END IF\n\n            ELSEIF INSTR(\"INV SPL\", Component(k).Species) > 0 THEN\n                SELECT CASE Component(k).Species\n                    CASE \"INV\"\n                        a = Component(k).A.Value\n                        ' Update self\n                        Component(k).B.Value = BinaryINV(a)\n                        ' Update downstream\n                        j = Component(k).B.Pointer\n                        IF (j <> -1) THEN\n                            g = Component(k).B.Identity\n                            b = Component(k).B.Value\n                            IF (Component(j).A.Identity = g) THEN\n                                Component(j).A.Value = b\n                            ELSEIF (Component(j).B.Identity = g) THEN\n                                Component(j).B.Value = b\n                            END IF\n                        END IF\n\n                    CASE \"SPL\"\n                        a = Component(k).A.Value\n                        ' Update self\n                        Component(k).B.Value = a\n                        Component(k).C.Value = a\n                        ' Update downstream\n                        j = Component(k).B.Pointer\n                        IF (j <> -1) THEN\n                            g = Component(k).B.Identity\n                            b = Component(k).B.Value\n                            IF (Component(j).A.Identity = g) THEN\n                                Component(j).A.Value = b\n                            ELSEIF (Component(j).B.Identity = g) THEN\n                                Component(j).B.Value = b\n                            END IF\n                        END IF\n                        j = Component(k).C.Pointer\n                        IF (j <> -1) THEN\n                            g = Component(k).C.Identity\n                            c = Component(k).C.Value\n                            IF (Component(j).A.Identity = g) THEN\n                                Component(j).A.Value = c\n                            ELSEIF (Component(j).B.Identity = g) THEN\n                                Component(j).B.Value = c\n                            END IF\n                        END IF\n                END SELECT\n            END IF\n        END IF\n    NEXT\nEND SUB\n\nFUNCTION BinaryAND (a AS INTEGER, b AS INTEGER)\n    DIM TheReturn AS INTEGER\n    IF ((a = 0) AND (b = 0)) THEN TheReturn = 0\n    IF ((a = 0) AND (b = 1)) THEN TheReturn = 0\n    IF ((a = 1) AND (b = 0)) THEN TheReturn = 0\n    IF ((a = 1) AND (b = 1)) THEN TheReturn = 1\n    BinaryAND = TheReturn\nEND FUNCTION\n\nFUNCTION BinaryINV (a AS INTEGER)\n    DIM TheReturn AS INTEGER\n    IF (a = 0) THEN TheReturn = 1\n    IF (a = 1) THEN TheReturn = 0\n    BinaryINV = TheReturn\nEND FUNCTION\n\nFUNCTION BinaryNAND (a AS INTEGER, b AS INTEGER)\n    DIM TheReturn AS INTEGER\n    IF ((a = 0) AND (b = 0)) THEN TheReturn = 1\n    IF ((a = 0) AND (b = 1)) THEN TheReturn = 1\n    IF ((a = 1) AND (b = 0)) THEN TheReturn = 1\n    IF ((a = 1) AND (b = 1)) THEN TheReturn = 0\n    BinaryNAND = TheReturn\nEND FUNCTION\n\nFUNCTION BinaryNOR (a AS INTEGER, b AS INTEGER)\n    DIM TheReturn AS INTEGER\n    IF ((a = 0) AND (b = 0)) THEN TheReturn = 1\n    IF ((a = 0) AND (b = 1)) THEN TheReturn = 0\n    IF ((a = 1) AND (b = 0)) THEN TheReturn = 0\n    IF ((a = 1) AND (b = 1)) THEN TheReturn = 0\n    BinaryNOR = TheReturn\nEND FUNCTION\n\nFUNCTION BinaryOR (a AS INTEGER, b AS INTEGER)\n    DIM TheReturn AS INTEGER\n    IF ((a = 0) AND (b = 0)) THEN TheReturn = 0\n    IF ((a = 0) AND (b = 1)) THEN TheReturn = 1\n    IF ((a = 1) AND (b = 0)) THEN TheReturn = 1\n    IF ((a = 1) AND (b = 1)) THEN TheReturn = 1\n    BinaryOR = TheReturn\nEND FUNCTION\n\nFUNCTION BinaryXOR (a AS INTEGER, b AS INTEGER)\n    DIM TheReturn AS INTEGER\n    IF ((a = 0) AND (b = 0)) THEN TheReturn = 0\n    IF ((a = 0) AND (b = 1)) THEN TheReturn = 1\n    IF ((a = 1) AND (b = 0)) THEN TheReturn = 1\n    IF ((a = 1) AND (b = 1)) THEN TheReturn = 0\n    BinaryXOR = TheReturn\nEND FUNCTION\n\nSUB PrintCircuit\n    DIM k, n AS INTEGER\n    PRINT \"Example \" + _TRIM$(STR$(ExampleCircuitNumber)) + \": \"; ExampleCircuitName\n    PRINT\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        IF (Component(k).Species <> \"\") THEN\n            n = n + 1\n            PRINT \"[\"; _TRIM$(STR$(k)); \"] \"; Component(k).Species; Component(k).A.Identity; Component(k).B.Identity; Component(k).C.Identity; Component(k).B.Pointer; Component(k).C.Pointer\n        END IF\n        IF (n = 20) THEN\n            PRINT \"...\"\n            EXIT FOR\n        END IF\n    NEXT\n    IF (n < 20) THEN\n        FOR k = n TO 20\n            PRINT\n        NEXT\n    END IF\n    PRINT\nEND SUB\n\nSUB PrintInput\n    DIM k AS INTEGER\n    DIM AS STRING InputRep\n    InputRep = \"\"\n    PRINT \"Input: \"\n    FOR k = LBOUND(Button) TO UBOUND(Button)\n        IF (Button(k).Species <> \"\") THEN\n            IF (Button(k).Identity = Component(Button(k).Pointer).A.Identity) THEN\n                IF Button(k).Species = \"PSH\" THEN\n                    InputRep = InputRep + \"(\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \")\" + _TRIM$(STR$(Component(Button(k).Pointer).A.Value)) + \" \"\n                ELSEIF Button(k).Species = \"TOG\" THEN\n                    InputRep = InputRep + \"[\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \"]\" + _TRIM$(STR$(Component(Button(k).Pointer).B.Value)) + \" \"\n                ELSEIF Button(k).Species = \"PLS\" THEN\n                    InputRep = InputRep + \"{\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \"}\" + _TRIM$(STR$(Component(Button(k).Pointer).C.Value)) + \" \"\n                END IF\n            ELSEIF (Button(k).Identity = Component(Button(k).Pointer).B.Identity) THEN\n                IF Button(k).Species = \"PSH\" THEN\n                    InputRep = InputRep + \"(\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \")\" + _TRIM$(STR$(Component(Button(k).Pointer).A.Value)) + \" \"\n                ELSEIF Button(k).Species = \"TOG\" THEN\n                    InputRep = InputRep + \"[\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \"]\" + _TRIM$(STR$(Component(Button(k).Pointer).B.Value)) + \" \"\n                ELSEIF Button(k).Species = \"PLS\" THEN\n                    InputRep = InputRep + \"{\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \"}\" + _TRIM$(STR$(Component(Button(k).Pointer).C.Value)) + \" \"\n                END IF\n            ELSEIF (Button(k).Identity = Component(Button(k).Pointer).C.Identity) THEN\n                IF Button(k).Species = \"PSH\" THEN\n                    InputRep = InputRep + \"(\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \")\" + _TRIM$(STR$(Component(Button(k).Pointer).A.Value)) + \" \"\n                ELSEIF Button(k).Species = \"TOG\" THEN\n                    InputRep = InputRep + \"[\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \"]\" + _TRIM$(STR$(Component(Button(k).Pointer).B.Value)) + \" \"\n                ELSEIF Button(k).Species = \"PLS\" THEN\n                    InputRep = InputRep + \"{\" + _TRIM$(STR$(Button(k).Pointer)) + \":\" + _TRIM$(STR$(Button(k).Identity)) + \"}\" + _TRIM$(STR$(Component(Button(k).Pointer).C.Value)) + \" \"\n                END IF\n            END IF\n        END IF\n    NEXT\n    IF (InputRep <> \"\") THEN\n        IF (LEN(InputRep) >= (1 * _WIDTH) / 8 - 3) THEN\n            InputRep = LEFT$(InputRep, (1 * _WIDTH) / 8 - 3) + \"...\"\n        END IF\n        PRINT InputRep;\n    END IF\n    PRINT: PRINT\nEND SUB\n\nSUB PrintStateHistory\n    DIM k AS INTEGER\n    DIM StateRep AS STRING\n    StateRep = \"\"\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        IF (Component(k).Species <> \"\") THEN\n            StateRep = StateRep + \"[\" + _TRIM$(STR$(k)) + \"]\" + _TRIM$(STR$(Component(k).A.Value)) + _TRIM$(STR$(Component(k).B.Value)) + _TRIM$(STR$(Component(k).C.Value))\n        END IF\n    NEXT\n    IF (StateHistory(1) <> StateRep) THEN\n        FOR k = UBOUND(StateHistory) TO 2 STEP -1\n            StateHistory(k) = StateHistory(k - 1)\n        NEXT\n        StateHistory(1) = StateRep\n    END IF\n    PRINT \"State:\"\n    FOR k = LBOUND(StateHistory) TO UBOUND(StateHistory)\n        StateRep = StateHistory(k)\n        IF (LEN(StateRep) >= (1 * _WIDTH) / 8 - 3) THEN\n            StateRep = LEFT$(StateHistory(k), (1 * _WIDTH) / 8 - 3) + \"...\"\n        END IF\n        PRINT StateRep\n    NEXT\nEND SUB\n\nSUB PrintOutput\n    DIM k AS INTEGER\n    DIM AS STRING OutputRep\n    OutputRep = \"\"\n    PRINT \"Output: \"\n    FOR k = LBOUND(Light) TO UBOUND(Light)\n        IF (Light(k).Species <> \"\") THEN\n            IF (Light(k).Identity = Component(Light(k).Pointer).A.Identity) THEN\n                OutputRep = OutputRep + \"(\" + _TRIM$(STR$(Light(k).Pointer)) + \":\" + _TRIM$(STR$(Light(k).Identity)) + \")\" + _TRIM$(STR$(Component(Light(k).Pointer).A.Value)) + \" \"\n            END IF\n            IF (Light(k).Identity = Component(Light(k).Pointer).B.Identity) THEN\n                OutputRep = OutputRep + \"(\" + _TRIM$(STR$(Light(k).Pointer)) + \":\" + _TRIM$(STR$(Light(k).Identity)) + \")\" + _TRIM$(STR$(Component(Light(k).Pointer).B.Value)) + \" \"\n            END IF\n            IF (Light(k).Identity = Component(Light(k).Pointer).C.Identity) THEN\n                OutputRep = OutputRep + \"(\" + _TRIM$(STR$(Light(k).Pointer)) + \":\" + _TRIM$(STR$(Light(k).Identity)) + \")\" + _TRIM$(STR$(Component(Light(k).Pointer).C.Value)) + \" \"\n            END IF\n        END IF\n    NEXT\n    IF (OutputRep <> \"\") THEN\n        IF (LEN(OutputRep) >= (1 * _WIDTH) / 8 - 3) THEN\n            OutputRep = LEFT$(OutputRep, (1 * _WIDTH) / 8 - 3) + \"...\"\n        END IF\n        PRINT OutputRep;\n    END IF\n    PRINT: PRINT\nEND SUB\n\nSUB DrawGlyph\n    TYPE Vector\n        x AS DOUBLE\n        y AS DOUBLE\n    END TYPE\n    DIM AS INTEGER n, m, k, j\n    DIM AS _UNSIGNED LONG g, ActiveColor\n    DIM Position(UBOUND(Component)) AS Vector\n    n = 0\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        IF (Component(k).Species <> \"\") THEN n = n + 1\n    NEXT\n    m = 0\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        IF (Component(k).Species <> \"\") THEN\n            m = m + 1\n            Position(k).x = _WIDTH / 4 + 120 * COS(1 * 2 * 3.14 * (m / n))\n            Position(k).y = _HEIGHT / 4 + 120 * SIN(3 * 2 * 3.14 * (m / n))\n        END IF\n    NEXT\n    CALL CPrintstring(\"Glyph:\", _WIDTH / 4 - 8 * (6) / 2, _HEIGHT / 4 + 150, _RGB32(0, 0, 0, 255))\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        IF (Component(k).Species <> \"\") THEN\n            g = Component(k).B.Identity\n            j = Component(k).B.Pointer\n            IF (j <> -1) THEN\n                IF (g = Component(j).A.Identity) THEN\n                    IF (Component(j).A.Value = 1) THEN\n                        ActiveColor = _RGB32(255, 0, 0)\n                    ELSE\n                        ActiveColor = _RGB32(0, 0, 255)\n                    END IF\n                ELSEIF (g = Component(j).B.Identity) THEN\n                    IF (Component(j).B.Value = 1) THEN\n                        ActiveColor = _RGB32(255, 0, 0)\n                    ELSE\n                        ActiveColor = _RGB32(0, 0, 255)\n                    END IF\n                ELSEIF (g = Component(j).C.Identity) THEN\n                    IF (Component(j).C.Value = 1) THEN\n                        ActiveColor = _RGB32(255, 0, 0)\n                    ELSE\n                        ActiveColor = _RGB32(0, 0, 255)\n                    END IF\n                END IF\n                CALL CLine(Position(k).x, Position(k).y, Position(j).x, Position(j).y, ActiveColor)\n                'CALL LineSmooth(Position(k).x, Position(k).y, Position(j).x, Position(j).y, ActiveColor)\n            END IF\n            g = Component(k).C.Identity\n            j = Component(k).C.Pointer\n            IF (j <> -1) THEN\n                IF (g = Component(j).A.Identity) THEN\n                    IF (Component(j).A.Value = 1) THEN\n                        ActiveColor = _RGB32(255, 0, 0)\n                    ELSE\n                        ActiveColor = _RGB32(0, 0, 255)\n                    END IF\n                ELSEIF (g = Component(j).B.Identity) THEN\n                    IF (Component(j).B.Value = 1) THEN\n                        ActiveColor = _RGB32(255, 0, 0)\n                    ELSE\n                        ActiveColor = _RGB32(0, 0, 255)\n                    END IF\n                ELSEIF (g = Component(j).C.Identity) THEN\n                    IF (Component(j).C.Value = 1) THEN\n                        ActiveColor = _RGB32(255, 0, 0)\n                    ELSE\n                        ActiveColor = _RGB32(0, 0, 255)\n                    END IF\n                END IF\n                CALL CLine(Position(k).x, Position(k).y, Position(j).x, Position(j).y, ActiveColor)\n                'CALL LineSmooth(Position(k).x, Position(k).y, Position(j).x, Position(j).y, ActiveColor)\n            END IF\n        END IF\n    NEXT\n    FOR k = LBOUND(Button) TO UBOUND(Button)\n        IF (Button(k).Species <> \"\") THEN\n            j = Button(k).Pointer\n            IF (Button(k).Identity = Component(j).A.Identity) THEN\n                n = Component(j).A.Value\n            ELSEIF (Button(k).Identity = Component(j).B.Identity) THEN\n                n = Component(j).B.Value\n            ELSEIF (Button(k).Identity = Component(j).C.Identity) THEN\n                n = Component(j).C.Value\n            END IF\n            SELECT CASE Button(k).Species\n                CASE \"PSH\"\n                    CALL CCircle(Position(j).x, Position(j).y, 18, Greenish)\n                    IF (n = 1) THEN CALL CCircle(Position(j).x, Position(j).y, 16, Greenish)\n                CASE \"TOG\"\n                    CALL CLineB(Position(j).x - 16, Position(j).y - 16, Position(j).x + 16, Position(j).y + 16, Greenish)\n                    IF (n = 1) THEN CALL CLineB(Position(j).x - 14, Position(j).y - 14, Position(j).x + 14, Position(j).y + 14, Greenish)\n                CASE \"PLS\"\n                    CALL CLine(Position(j).x - 20 + 4, Position(j).y - 20 + 5, Position(j).x + 20 + 4, Position(j).y - 20 + 5, Greenish)\n                    CALL CLine(Position(j).x - 22 + 4, Position(j).y - 20 + 5, Position(j).x + 0 + 4, Position(j).y + 22 + 5, Greenish)\n                    CALL CLine(Position(j).x + 22 + 4, Position(j).y - 20 + 5, Position(j).x + 0 + 4, Position(j).y + 22 + 5, Greenish)\n                    IF (n = 1) THEN\n                        CALL CLine(Position(j).x - 18 + 4, Position(j).y - 18 + 5, Position(j).x + 18 + 4, Position(j).y - 18 + 5, Greenish)\n                        CALL CLine(Position(j).x - 18 + 4, Position(j).y - 18 + 5, Position(j).x + 0 + 4, Position(j).y + 18 + 5, Greenish)\n                        CALL CLine(Position(j).x + 18 + 4, Position(j).y - 18 + 5, Position(j).x + 0 + 4, Position(j).y + 18 + 5, Greenish)\n                    END IF\n            END SELECT\n        END IF\n    NEXT\n    FOR k = LBOUND(Light) TO UBOUND(Light)\n        IF (Light(k).Species <> \"\") THEN\n            j = Light(k).Pointer\n            IF (Light(k).Identity = Component(j).A.Identity) THEN\n                n = Component(j).A.Value\n            ELSEIF (Light(k).Identity = Component(j).B.Identity) THEN\n                n = Component(j).B.Value\n            ELSEIF (Light(k).Identity = Component(j).C.Identity) THEN\n                n = Component(j).C.Value\n            END IF\n            CALL CLineB(Position(j).x - 16, Position(j).y - 16, Position(j).x + 16, Position(j).y + 16, Yellowish)\n            IF (n = 1) THEN\n                CALL CLineB(Position(j).x - 14, Position(j).y - 14, Position(j).x + 14, Position(j).y + 14, Yellowish)\n            END IF\n        END IF\n    NEXT\n    FOR k = LBOUND(Component) TO UBOUND(Component)\n        IF (Component(k).Species <> \"\") THEN\n            CALL CPrintstring(_TRIM$(STR$(k)), Position(k).x - 2, Position(k).y + 6, _RGB32(0, 0, 0, 255))\n        END IF\n    NEXT\nEND SUB\n\nSUB DrawControls\n    DIM AS INTEGER n, k, j\n    DIM AS DOUBLE x0, y0\n    CALL CPrintstring(\"Button:\", _WIDTH / 4 - 8 * (7) / 2, 0, _RGB32(0, 0, 0, 255))\n    FOR k = LBOUND(Button) TO UBOUND(Button)\n        x0 = _WIDTH / 4 - 120 + k * 25\n        y0 = -25\n        n = 0\n        j = Button(k).Pointer\n        IF (j > 0) THEN\n            IF (Button(k).Identity = Component(j).A.Identity) THEN\n                n = Component(j).A.Value\n            ELSEIF (Button(k).Identity = Component(j).B.Identity) THEN\n                n = Component(j).B.Value\n            ELSEIF (Button(k).Identity = Component(j).C.Identity) THEN\n                n = Component(j).C.Value\n            END IF\n        END IF\n        SELECT CASE Button(k).Species\n            CASE \"PSH\"\n                CALL CCircle(x0, y0, 10, Greenish)\n                IF (n = 1) THEN CALL CPaint(x0, y0, Greenish)\n            CASE \"TOG\"\n                CALL CLineB(x0 - 10, y0 - 10, x0 + 10, y0 + 10, Greenish)\n                IF (n = 1) THEN CALL CLineBF(x0 - 10, y0 - 10, x0 + 10, y0 + 10, Greenish)\n            CASE \"PLS\"\n                CALL CLine(x0 - 10, y0 - 10, x0 + 10, y0 - 10, Greenish)\n                CALL CLine(x0 - 10, y0 - 10, x0 + 0, y0 + 10, Greenish)\n                CALL CLine(x0 + 10, y0 - 10, x0 + 0, y0 + 10, Greenish)\n                IF (n = 1) THEN CALL CPaint(x0, y0, Greenish)\n            CASE ELSE\n                CALL CCircle(x0, y0, 5, Greenish)\n        END SELECT\n    NEXT\n    CALL CPrintstring(\"Light:\", _WIDTH / 4 - 8 * (6) / 2, -50, _RGB32(0, 0, 0, 255))\n    FOR k = LBOUND(Light) TO UBOUND(Light)\n        x0 = _WIDTH / 4 - 120 + k * 25\n        y0 = -75\n        IF (Light(k).Species <> \"\") THEN\n            CALL CLineB(x0 - 10, y0 - 10, x0 + 10, y0 + 10, Yellowish)\n        ELSE\n            CALL CLineB(x0 - 5, y0 - 5, x0 + 5, y0 + 5, Yellowish)\n        END IF\n        n = 0\n        j = Light(k).Pointer\n        IF (j > 0) THEN\n            IF (Light(k).Identity = Component(j).A.Identity) THEN\n                n = Component(j).A.Value\n            ELSEIF (Light(k).Identity = Component(j).B.Identity) THEN\n                n = Component(j).B.Value\n            ELSEIF (Light(k).Identity = Component(j).C.Identity) THEN\n                n = Component(j).C.Value\n            END IF\n            IF (n = 1) THEN CALL CPaint(x0, y0, Yellowish)\n        END IF\n    NEXT\nEND SUB\n\nSUB CCircle (x0 AS DOUBLE, y0 AS DOUBLE, rad AS DOUBLE, shade AS _UNSIGNED LONG)\n    CIRCLE (_WIDTH / 2 + x0, -y0 + _HEIGHT / 2), rad, shade\nEND SUB\n\nSUB CPaint (x0 AS DOUBLE, y0 AS DOUBLE, shade AS _UNSIGNED LONG)\n    PAINT (_WIDTH / 2 + x0, -y0 + _HEIGHT / 2), shade\nEND SUB\n\nSUB CPrintstring (TheString AS STRING, x0 AS DOUBLE, y0 AS DOUBLE, shade AS _UNSIGNED LONG)\n    COLOR shade\n    _PRINTSTRING (_WIDTH / 2 + x0, -y0 + _HEIGHT / 2), TheString\nEND SUB\n\nSUB CLine (x0 AS DOUBLE, y0 AS DOUBLE, x1 AS DOUBLE, y1 AS DOUBLE, shade AS _UNSIGNED LONG)\n    LINE (_WIDTH / 2 + x0, -y0 + _HEIGHT / 2)-(_WIDTH / 2 + x1, -y1 + _HEIGHT / 2), shade\nEND SUB\n\nSUB CLineB (x0 AS DOUBLE, y0 AS DOUBLE, x1 AS DOUBLE, y1 AS DOUBLE, shade AS _UNSIGNED LONG)\n    LINE (_WIDTH / 2 + x0, -y0 + _HEIGHT / 2)-(_WIDTH / 2 + x1, -y1 + _HEIGHT / 2), shade, B\nEND SUB\n\nSUB CLineBF (x0 AS DOUBLE, y0 AS DOUBLE, x1 AS DOUBLE, y1 AS DOUBLE, shade AS _UNSIGNED LONG)\n    LINE (_WIDTH / 2 + x0, -y0 + _HEIGHT / 2)-(_WIDTH / 2 + x1, -y1 + _HEIGHT / 2), shade, BF\nEND SUB\n"
  },
  {
    "input": "Texting Fish",
    "output": "Dim Shared sw, sh, LHead$, LBody$, LTail$, RHead$, RBody$, RTail$\nsw = 1024: sh = 700\nLHead$ = \"<*\": LBody$ = \")\": LTail$ = \">{\"\nRHead$ = \"*>\": RBody$ = \"(\": RTail$ = \"}<\"\nType fish\n    LFish As Integer\n    X As Integer\n    Y As Integer\n    DX As Integer\n    fish As String\n    Colr As _Unsigned Long\nEnd Type\n\nScreen _NewImage(sw, sh, 32)\n\nColor _RGB32(220), _RGB32(0, 0, 60)\nCls\n'_PrintMode _KeepBackground\nDim As Integer i, nFish\nDim k$\nnFish = 40\n\n'restart:\nReDim Shared school(1 To nFish) As fish\nReDim Shared kelp(sw, sh) As _Unsigned Long\ngrowKelp\nFor i = 1 To nFish\n    NewFish i, -1\nNext\n\nDo\n    Cls\n    k$ = InKey$\n    'If k$ = \"m\" Then ' more fish\n    '    nFish = nFish * 2\n    '    If nFish > 300 Then Beep: nFish = 300\n    '    'GoTo restart\n    'End If\n    'If k$ = \"l\" Then ' less fish\n    '    nFish = nFish / 2\n    '    If nFish < 4 Then Beep: nFish = 4\n    '    'GoTo restart\n    'End If\n    For i = 1 To nFish ' draw fish behind kelp\n        If _Red32(school(i).Colr) < 160 Then\n            Color school(i).Colr\n            _PrintString (school(i).X, school(i).Y), school(i).fish 'draw fish\n            school(i).X = school(i).X + school(i).DX\n            If school(i).LFish Then\n                If school(i).X + Len(school(i).fish) * 8 < 0 Then NewFish i, 0\n            Else\n                If school(i).X - Len(school(i).fish) * 8 > _Width Then NewFish i, 0\n            End If\n        End If\n    Next\n    showKelp\n    For i = 1 To nFish ' draw fish in from of kelp\n        If _Red32(school(i).Colr) >= 160 Then\n            Color school(i).Colr\n            _PrintString (school(i).X, school(i).Y), school(i).fish 'draw fish\n            school(i).X = school(i).X + school(i).DX\n            If school(i).LFish Then\n                If school(i).X + Len(school(i).fish) * 8 < 0 Then NewFish i, 0\n            Else\n                If school(i).X - Len(school(i).fish) * 8 > _Width Then NewFish i, 0\n            End If\n        End If\n    Next\n\n    _Display\n    _Limit 10\nLoop Until _KeyDown(27)\n\nSub NewFish (i, initTF)\n    Dim gray\n    gray = Rnd * 200 + 55\n    school(i).Colr = _RGB32(gray) ' color\n    If Rnd > .5 Then\n        school(i).LFish = -1\n        school(i).fish = LHead$ + String$(Int(Rnd * 5) + -2 * (gray > 160) + 1, LBody$) + LTail$\n    Else\n        school(i).LFish = 0\n        school(i).fish = RTail$ + String$(Int(Rnd * 5) + -2 * (gray > 160) + 1, RBody$) + RHead$\n    End If\n    If initTF Then\n        school(i).X = _Width * Rnd\n    Else\n        If school(i).LFish Then school(i).X = _Width + Rnd * 35 Else school(i).X = -35 * Rnd - Len(school(i).fish) * 8\n    End If\n    If gray > 160 Then\n        If school(i).LFish Then school(i).DX = -18 * Rnd - 3 Else school(i).DX = 18 * Rnd + 3\n    Else\n        If school(i).LFish Then school(i).DX = -6 * Rnd - 1 Else school(i).DX = 6 * Rnd + 1\n    End If\n    school(i).Y = _Height * Rnd\nEnd Sub\n\nSub growKelp\n    Dim kelps, x, y, r\n    ReDim kelp(sw, sh) As _Unsigned Long\n    kelps = Int(Rnd * 20) + 20\n    For x = 1 To kelps\n        kelp(Fix(Int(Rnd * sw / 8)), Fix((sh - 16) / 16)) = _RGB32(0, Rnd * 128, 0)\n    Next\n    For y = Fix(sh / 16) To 0 Step -1\n        For x = 0 To Fix(sw / 8)\n            If kelp(x, y + 1) Then\n                r = Fix(Int(Rnd * 23) + 1)\n                Select Case r\n                    Case 1, 2, 3, 18 '1 branch node\n                        If x - 1 >= 0 Then kelp(x - 1, y) = kelp(x, y + 1)\n                    Case 4, 5, 6, 7, 8, 9, 21 '1 branch node\n                        kelp(x, y) = kelp(x, y + 1)\n                    Case 10, 11, 12, 20 '1 branch node\n                        If x + 1 <= sw Then kelp(x + 1, y) = kelp(x, y + 1)\n                    Case 13, 14, 15, 16, 17, 19 '2 branch node\n                        If x - 1 >= 0 Then kelp(x - 1, y) = kelp(x, y + 1)\n                        If x + 1 <= sw Then kelp(x + 1, y) = kelp(x, y + 1)\n                End Select\n            End If\n        Next\n    Next\nEnd Sub\n\nSub showKelp\n    Dim y, x\n    For y = 0 To Fix(sh / 16)\n        For x = 0 To Fix(sw / 8)\n            If kelp(x, y) Then\n                Color kelp(x, y)\n                'Color 2\n                _PrintString (x * 8, y * 16), Mid$(\"kelp\", Int(Rnd * 4) + 1, 1)\n            End If\n        Next\n    Next\nEnd Sub\n\n"
  },
  {
    "input": "Inside Out Torus",
    "output": "dim shared pi, p, q, a, b, x, y, z, t\n\nzoom = 150\n\nsw = 1024\nsh = 768\n\nscreen _newimage(sw, sh, 32)\n\npi = 4*atn(1)\n\ndu = 2*pi/10\ndv = 2*pi/20\n\na = pi/4\nb = pi/4\n\nou = 0\nov = 0\n\ntt = 0\ndo\n    tt = tt + 0.01\n    t = 0.5 + 0.5*sin(tt)\n    a = t\n    'for t = 0 to 1 step 0.01\n    do\n        mx = _mousex\n        my = _mousey\n        mb = _mousebutton(1)\n        zoom = zoom - 10*_mousewheel\n    loop while _mouseinput\n\n    cls\n\n    xu = 0\n    xv = 0\n\n    for u=0 to 2*pi step du\n        xu = xu xor 1\n        for v=0 to 2*pi step dv\n            xu = xu xor 1\n\n            nx = sin(v)\n            ny = -cos(v)\n            nz = u\n\n            roty a\n            rotx b\n\n            'parallel\n            sx = -1\n            sy = -sx/0.707\n            sz = -0.707*sy\n\n            'perspective\n            sx = 0  \n            sy = -1 \n            sz = 0  \n\n            'if (nx*sx + ny*sy + nz*sz) < 0 then\n                f u, v\n                proj \n                x1 = sw/2 + zoom*p\n                y1 = sh/2 - zoom*q\n                preset (x1, y1)\n\n                f u + du, v\n                proj\n                x2 = sw/2 + zoom*p\n                y2 = sh/2 - zoom*q\n                line -(x2, y2)\n\n                f u + du, v + dv\n                proj\n                x3 = sw/2 + zoom*p\n                y3 = sh/2 - zoom*q\n                'line -(x3, y3)\n\n                f u, v + dv\n                proj\n                x4 = sw/2 + zoom*p\n                y4 = sh/2 - zoom*q\n                'line -(x4, y4)\n\n                'line -(x1, y1)\n\n                'if xu then\n                '    c = 255\n                '    FillTriangle x1,y1, x2,y2, x3,y3, _rgb(c,c,c)\n                '    FillTriangle x3,y3, x4,y4, x1,y1, _rgb(c,c,c)\n                'else\n                '    FillTriangle x1,y1, x2,y2, x3,y3, _rgb(0,0,0)\n                '    FillTriangle x3,y3, x4,y4, x1,y1, _rgb(0,0,0)\n                'end if\n            'end if\n        next\n    next\n\n    'next\n\n    _display\n    _limit 100\nloop until _keyhit = 27\nsleep\nsystem\n\n\nsub f(u, v)\n    'x = u*cos(v)\n    'y = u*sin(v)\n    'z = v\n\n    'x = (1 + 0.5*v*cos(0.5*(u - t)))*cos(u - t)\n    'y = (1 + 0.5*v*cos(0.5*(u - t)))*sin(u - t)\n    'z = 0.5*v*sin(0.5*(u - t))\n\n    rr = 2.0\n    r = 0.5 \n\n    x1 = (rr + r*cos(v))*cos(u)\n    y1 = (rr + r*cos(v))*sin(u)\n    z1 = r*sin(v)\n\n    z2 = (rr + r*cos(u))*cos(v)\n    y2 = (rr + r*cos(u))*sin(v)\n    x2 = r*sin(u)\n\n    x = (1 - t)*x1 + t*x2\n    y = (1 - t)*y1 + t*y2\n    z = (1 - t)*z1 + t*z2\n\nend sub\n\nsub proj\n    'parallel\n    'p = x + 0.707*y\n    'q = z + 0.707*y\n\n    roty a\n    rotx b\n\n    d = 10\n    p = x*d/(10 + y)\n    q = z*d/(10 + y)\nend sub\n\nsub rotx(u)\n    xx = x\n    yy = y*cos(u) - z*sin(u)\n    zz = y*sin(u) + z*cos(u)\n\n    x = xx\n    y = yy\n    z = zz\nend sub\n\nsub roty(u)\n    xx = x*cos(u) + z*sin(u)\n    yy = y\n    zz =-x*sin(u) + z*cos(u)\n\n    x = xx\n    y = yy\n    z = zz\nend sub\n\nsub rotz(u)\n    xx = x*cos(u) - y*sin(u)\n    yy = x*sin(u) + y*cos(u)\n    zz = z\n\n    x = xx\n    y = yy\n    z = zz\nend sub\n"
  },
  {
    "input": "Source: QB64 wiki example",
    "output": "DIM SHARED grid(16, 16), grid2(16, 16), cur\nCONST maxx = 512\nCONST maxy = 512\nDIM SHARED lastMouseEvent\nSCREEN _NEWIMAGE(maxx, maxy, 32)\n_TITLE \"MusicGrid\"\ncleargrid\nDIM t#, inp$, cur, oldcur\nDO\n    IF TIMER - t# > 1 / 8 THEN cur = (cur + 1) AND 15: t# = TIMER\n    IF cur <> oldcur THEN\n        figuregrid\n        drawgrid\n        playgrid\n        oldcur = cur\n    END IF\n    domousestuff\n    inp$ = INKEY$\n    IF inp$ = \"C\" OR inp$ = \"c\" THEN cleargrid\n    _LIMIT 60\nLOOP UNTIL inp$ = CHR$(27)\n\nSUB drawgrid\n    DIM scale, scale2, c&\n    scale = maxx / 16\n    scale2 = FIX(maxx \\ 16 - 2)\n    FOR y = 0 TO 15\n        y1 = y * scale!\n        FOR x = 0 TO 15\n            x1 = x * scale\n            c& = _RGB32(grid2(x, y) * 64 + 64, 0, 0)\n            LINE (x1, y1)-(x1 + scale2, y1 + scale2), c&, BF\n        NEXT x\n    NEXT y\nEND SUB\n\nSUB figuregrid\n    DIM x, y\n    FOR y = 0 TO 15\n        FOR x = 0 TO 15\n            grid2(x, y) = grid(x, y)\n        NEXT x\n    NEXT y\n    FOR y = 1 TO 14\n        FOR x = 1 TO 14\n            IF grid(x, y) = 1 AND cur = x THEN\n                grid2(x, y) = 2\n                IF grid(x - 1, y) = 0 THEN grid2(x - 1, y) = 1\n                IF grid(x + 1, y) = 0 THEN grid2(x + 1, y) = 1\n                IF grid(x, y - 1) = 0 THEN grid2(x, y - 1) = 1\n                IF grid(x, y + 1) = 0 THEN grid2(x, y + 1) = 1\n            END IF\n        NEXT x\n    NEXT y\nEND SUB\n\nSUB domousestuff\n    DIM x, y\n    WHILE _MOUSEINPUT: WEND\n    IF _MOUSEBUTTON(1) AND ABS(TIMER - lastMouseEvent) > .25 THEN\n        x = FIX(_MOUSEX \\ FIX(maxx \\ 16))\n        y = FIX(_MOUSEY \\ FIX(maxy \\ 16))\n        grid(x, y) = 1 - grid(x, y)\n        lastMouseEvent = TIMER\n    END IF\nEND SUB\n\nSUB playgrid\n    DIM n$, note$, x, y, scale$\n    n$ = \"L16 \"\n    scale$ = \"o1fo1go1ao2co2do2fo2go2ao3co3do3fo3go3ao4co4do4fo\"\n    FOR y = 15 TO 0 STEP -1\n        IF grid(cur, y) = 1 THEN\n            note$ = MID$(scale$, 1 + (15 - y) * 3, 3)\n            n$ = n$ + note$ + \",\" 'comma plays 2 or more column notes simultaneously\n        END IF\n    NEXT y\n    n$ = LEFT$(n$, LEN(n$) - 1)\n    PLAY n$\nEND SUB\n\nSUB cleargrid\n    DIM x, y\n    FOR y = 0 TO 15\n        FOR x = 0 TO 15\n            grid(x, y) = 0\n        NEXT x\n    NEXT y\nEND SUB"
  },
  {
    "input": "Source: QB64 wiki example",
    "output": "SCREEN _NEWIMAGE(472, 448, 32)\nDIM x$\nPRINT\nx$ = x$ + \"   o3    l4         t         0120c    ml<f1   ,a      1,  \"\nx$ = x$ + \"   >c    1,        mnf        .e  8f   am  l<   e1    ,g   \"\nx$ = x$ + \"   1,    >c       1, mn       g.   f8  ga   8g   8m  l<    \"\nx$ = x$ + \"   f2.,a2.,      >c   2.      ,m  nf   .f  8a     ml<f     \"\nx$ = x$ + \"   ,a,>c,mn     >cd2.,<f2     .,d2     .,<b        -2      \"\nx$ = x$ + \"   .m    lb    -,>d,f,mn>d    ml       <c          1,      \"\nx$ = x$ + \"   <a    1,   f1         ,m   n>       >c          .<      \"\nx$ = x$ + \"   a8    af  ml           c1  ,<       e1          ,g      \"\nx$ = x$ + \"                                                           \"\nx$ = x$ + \"      1,m      n>  g.f8ga8g8m  l<                   f1     \"\nx$ = x$ + \"      ,d1,     <b  -1           ,m                 n>      \"\nx$ = x$ + \"      >f .d    8d  c<            f2               .,       \"\nx$ = x$ + \"      a2  .,   c2  .,>f2.         ml      <      b-        \"\nx$ = x$ + \"      ,>   d,  f,  mn>dml          <c    1,<    a1         \"\nx$ = x$ + \"      ,f    1, mn  >>               c.  <a 8a  fm          \"\nx$ = x$ + \"      lc     2.,<  e2                .,g2   .,mn           \"\nx$ = x$ + \"      >g      .f8  gml<b-,>d,         f,     mn            \"\nx$ = x$ + \"                                                           \"\nx$ = x$ + \">d      ml  <<f2.,a2.,         >         c2.,m       n>  c.\"\nx$ = x$ + \" <a    8a   ml                <e,        g,  >c      ,m  n>\"\nx$ = x$ + \"  cm  l<    <b               -2 .,       >d   2.     ,f  2.\"\nx$ = x$ + \"   ,mn>     d2.ml<          <b   -,      >d  ,f      ,m  n>\"\nx$ = x$ + \"    dm      l<<f1,         a1,>c1,mn     >c.<a       8a  fm\"\nx$ = x$ + \"    lc      1,            <e1,g1,mn>g    .f  8g      a8  g8\"\nx$ = x$ + \"    ml      <<           b-         1,   >d   1,           \"\nx$ = x$ + \"    f1      ,mn>f.d8dc  l1           ml  f,    c,    <a  ,f\"\nPRINT x$;\nPLAY x$"
  },
  {
    "input": "Source: QB64 wiki example",
    "output": "CLS: PRINT \"Frosty the Snow Man\"\nFOR X = 1 TO 2\n    PRINT\n    IF X = 1 THEN PRINT \"Fros-ty the Snow man was a jolly happy soul,\"\n    IF X = 2 THEN PRINT \"Fros-ty the Snow man knew the sun was hot that day\"\n    PLAY \"w3q1t140o2p4g2e4.f8g4o3c2o2b8o3c8d4c4o2b4a8g2.\" 'MB removed to print song one line at a time\n    IF X = 1 THEN PRINT \"with a corn cob pipe and a button nose and two eyes made out of coal.\"\n    IF X = 2 THEN PRINT \"so he said Let's run and we'll have some fun now before I melt away.\"\n    PLAY \"o2b8o3c8d4c4o2b4a8a8g8o3c4o2e8e4g8a8g4f4e4f4g2.\"\n    IF X = 1 THEN PRINT \"Fros-ty the Snow Man is a fair-y tale, they say,\"\n    IF X = 2 THEN PRINT \"Down to the vil-lage, with a broom-stick in his hand,\"\n    PLAY \"g2e4.f8g4o3c2o2b8o3c8d4c4o2b4a8g2.\"\n    IF X = 1 THEN PRINT \"He was made of snow but the chil-dren knew how he come to life one day.\"\n    IF X = 2 THEN PRINT \"run-ning here and there all a-round the square, say-in' catch me if you can.\"\n    PLAY \"o2b8o3c8d4c4o2b4a8a8g8o3c4o2e8e4g8a8g4f4e4d4c2.\"\n    IF X = 1 THEN PRINT \"There must have been some magic in that old silk hat they found.\"\n    IF X = 2 THEN PRINT \"He led them down the streets of town right to the traffic cop.\"\n    PLAY \"c4a4a4o3c4c4o2b4a4g4e4f4a4g4f4e2.\"\n    IF X = 1 THEN PRINT \"For when they placed it on his head he be-gan to dance a round.\"\n    IF X = 2 THEN PRINT \"And he on-ly paused a moment when he heard him hol-ler Stop!\"\n    PLAY \"e8e8d4d4g4g4b4b4o3d4d8o2b8o3d4c4o2b4a4g4p4\"\n    IF X = 1 THEN PRINT \"Oh, Fros-ty the Snow Man was a-live as he could be,\"\n    IF X = 2 THEN PRINT \"For, Fros-ty the Snow Man had to hur-ry on his way\"\n    PLAY \"g2g2e4.f8g4o3c2o2b8o3c8d4c4o2b4a8g8g2.\"\n    IF X = 1 THEN PRINT \"and the chil-dren say he could laugh and play just the same as you and me.\"\n    IF X = 2 THEN PRINT \"but he waved good-bye say-in' Don't you cry, I'll be back a-gain some day.\"\n    PLAY \"o2b8o3c8d4c4o2b4a8a8g8o3c4o2e8e4g8a8g4f4e4d4c2.p4\"\nNEXT X\nPRINT: PRINT \"Thump-et-y thump thump, thump-et-y thump thump, look at Fros-ty go.\"\nPLAY \"t180g8g8g4g4g4a8g8g4g4g4a4g4e4g4d1\"\nPRINT \"Thump-et-y thump thump, thump-et-y thump thump, ov-er the hills of snow.\"\nPLAY \"t180g8g8g4g4g4a8g8g4g4g4g8g8g4a4b4o3c2c4p1\"\nEND"
  },
  {
    "input": "Chaotic Scattering",
    "output": "'Option _Explicit\n'DefLng A-Z\n\nDim sw, sh, r, rr0, sx, sy, mw, mx, my, mb, rr, valid, old_mx, old_my, old_mw\n\nsw = 640\nsh = 480\n\nDim Shared pi As Double\npi = 4 * Atn(1)\n\nDim As Double t, a, b, a1, a2\nDim As Double x, y, x0, y0, x1, y1, dx, dy\n\nr = 210\nrr0 = 140\n\nsx = 0\nsy = sh / 2\n\nScreen _NewImage(sw, sh, 32)\n'_ScreenMove 0.5 * (1920 - sw), 0.5 * (1080 - sh)\n\n\nDo\n    'Do While _MouseInput\n        mw = mw + _MouseWheel\n    'Loop\n\n    If _KeyDown(87) or _KeyDown(119) then 'W\n        mw = mw - 1\n    ElseIf _KeyDown(83) or _KeyDown(115) then 'S\n        mw = mw + 1\n    End If\n\n    mx = _MouseX\n    my = _MouseY\n    mb = _MouseButton(1)\n\n    rr = rr0 - mw\n\n    If mb Then\n        Do While mb\n            Do While _MouseInput\n            Loop\n            mb = _MouseButton(1)\n        Loop\n\n        valid = -1\n        For b = 0 To 2 * pi Step 2 * pi / 3\n            x1 = r * Cos(b) + sw / 2\n            y1 = r * Sin(b) + sh / 2\n\n            dx = mx - x1\n            dy = my - y1\n            If dx * dx + dy * dy < rr * rr Then\n                valid = 0\n                Exit For\n            End If\n        Next\n\n        If valid Then\n            sx = mx\n            sy = my\n        End If\n    End If\n\n    'if mx<>old_mx or my<>old_my or mw<>old_mw then\n    'fading light\n    If 1 Then\n\n\n\n        'line (0,0)-(sw,sh), _rgb(0,0,0), bf\n        Line (0, 0)-(sw, sh), _RGBA32(0, 0, 0, 30), BF\n\n        'locate 1,1\n        '? mx, my, mw, mb\n        \n        For b = 0 To 2 * pi Step 2 * pi / 3\n            Circle (r * Cos(b) + sw / 2, r * Sin(b) + sh / 2), rr\n        Next\n        \n        a = _Atan2(my - sy, mx - sx)\n        \n        x0 = sx\n        y0 = sy\n        \n        For t = 0 To 1000\n            x = t * Cos(a) + x0\n            y = t * Sin(a) + y0\n            \n            For b = 0 To 2 * pi Step 2 * pi / 3\n                If x >= 0 And x < sw And y >= 0 And y < sh Then\n                    x1 = r * Cos(b) + sw / 2\n                    y1 = r * Sin(b) + sh / 2\n                    \n                    dx = x - x1\n                    dy = y - y1\n                    If dx * dx + dy * dy < rr * rr Then\n                        a1 = _Atan2(dy, dx)\n                        a2 = 2 * a1 - a - pi\n                        \n                        Line (x0, y0)-(x, y), _RGB(233, 205, 89)\n                        \n                        x0 = x\n                        y0 = y\n                        a = a2\n                        t = 0\n                        Exit For\n                    End If\n                End If\n            Next\n        Next\n        \n        Line (x0, y0)-(x, y), _RGB(233, 205, 89)\n        \n    End If\n\n    old_mx = mx\n    old_my = my\n    old_mw = mw\n\n    _Display\n    _Limit 50\nLoop Until _KeyHit = 27\nSystem\n"
  },
  {
    "input": "Voxels",
    "output": "\n\nType newVoxel\n    x As Single\n    y As Single\n    r As _Unsigned _Byte\n    g As _Unsigned _Byte\n    b As _Unsigned _Byte\n    image As Long\nEnd Type\n\nDim Shared voxelSize As Single\nDim Shared totalVoxels As Long, i As Long\nDim canvas&, mouseDown As _Byte\n\nvoxelSize = 100\ntotalVoxels = 0\n\ncanvas& = _NewImage(600, 600, 32)\nScreen canvas&\n\n_MouseHide\n\nDim voxel(1000) As newVoxel\nDim wireFrameVoxel As newVoxel\n\nwireFrameVoxel.r = 255\nwireFrameVoxel.g = 255\nwireFrameVoxel.b = 255\n\nRandomize Timer\n\nConst div = 3.4\nConst divx = 4\nDo\n    Cls\n\n    While _MouseInput: Wend\n    If _MouseButton(1) Then\n        If Not mouseDown Then\n            mouseDown = true\n            totalVoxels = totalVoxels + 1\n            If totalVoxels <= UBound(voxel) Then\n                voxel(totalVoxels).x = Int(_MouseX / (voxelSize / divx)) * (voxelSize / divx)\n                voxel(totalVoxels).y = Int(_MouseY / (voxelSize / div)) * (voxelSize / div)\n                voxel(totalVoxels).r = Rnd * 255\n                voxel(totalVoxels).g = Rnd * 255\n                voxel(totalVoxels).b = Rnd * 255\n            End If\n        End If\n    Else\n        mouseDown = false\n    End If\n\n    For i = 1 To totalVoxels\n        drawVoxel voxel(i), true\n    Next\n\n    wireFrameVoxel.x = Int(_MouseX / (voxelSize / divx)) * (voxelSize / divx)\n    wireFrameVoxel.y = Int(_MouseY / (voxelSize / div)) * (voxelSize / div)\n    drawVoxel wireFrameVoxel, false\n\n    Print Int(_MouseX / (voxelSize / 2))\n    Print Int(_MouseY / (voxelSize / 2))\n\n    Dim k As Long, b$\n    k = _KeyHit\n    If k = 27 Then totalVoxels = 0\n    If k = 8 Then totalVoxels = totalVoxels + (totalVoxels > 0)\n    If (k = 67 Or k = 99) And (_KeyDown(100306) Or _KeyDown(100305)) Then\n        b$ = \"\"\n        For i = 1 To totalVoxels\n            b$ = b$ + \"DATA \" + Str$(voxel(i).x) + \",\" + Str$(voxel(i).y) + Chr$(10)\n        Next\n        _Clipboard$ = b$\n    End If\n\n    _Display\n    _Limit 30\nLoop\n\nSub drawVoxel (that As newVoxel, fill As _Byte)\n    Dim x As Single, y As Single\n    Dim top As Single, leftSide As Single\n\n    If that.image = 0 Then\n        Dim tempImage&, previousDest&\n        tempImage& = _NewImage(voxelSize + 1, voxelSize * 1.15, 32)\n        previousDest& = _Dest\n        _Dest tempImage&\n\n        x = _Width / 2\n        y = 0\n\n        Color _RGB32(that.r, that.g, that.b)\n        Line (x, y)-Step(-(voxelSize / 2), voxelSize / 4)\n        Line Step(0, 0)-Step((voxelSize / 2), voxelSize / 4)\n        Line Step(0, 0)-Step((voxelSize / 2), -(voxelSize / 4))\n        Line Step(0, 0)-Step(-(voxelSize / 2), -(voxelSize / 4))\n        Line (x - (voxelSize / 2), y + (voxelSize / 4))-Step(0, (voxelSize * 0.625))\n        Line Step(0, 0)-Step((voxelSize / 2), (voxelSize / 4))\n        Line (x, y + (voxelSize / 2))-Step(0, (voxelSize * 0.625))\n        Line (x + (voxelSize / 2), y + (voxelSize / 4))-Step(0, (voxelSize * 0.625))\n        Line Step(0, 0)-Step(-(voxelSize / 2), (voxelSize / 4))\n\n        If fill Then\n            top = .8\n            Paint (x, y + (voxelSize / 4)), _RGB32(that.r * top, that.g * top, that.b * top), _RGB32(that.r, that.g, that.b)\n\n            leftSide = .4\n            Paint (x - (voxelSize / 4), y + (voxelSize * 0.7)), _RGB32(that.r * leftSide, that.g * leftSide, that.b * leftSide), _RGB32(that.r, that.g, that.b)\n\n            Paint (x + (voxelSize / 4), y + (voxelSize * 0.7)), _RGB32(that.r, that.g, that.b), _RGB32(that.r, that.g, that.b)\n        End If\n\n        that.image = tempImage&\n\n        _Dest previousDest&\n    End If\n    _PutImage (that.x, that.y), that.image\nEnd Sub\n"
  },
  {
    "input": "Pulse Plasma Blend",
    "output": "_Title \"Dav 'Pulse' Plasma Blend: press 'a' to change angle style, any other key for random, esc to quit\"\n' 2024-10-02 Dav      Hey, bplus, I thought you may like like this little proggie since you have shared some really great plasmas here.  I wondered what it would look like to show more than one plasma effect using a pulse factor to blend them.  Here's a little example of that.\n' 2024-10-02 b+       thank you Dav for nice blended plasma effect, now I play with it :D\n' 2024-10-03 Dav      Hey, bplus, I really like your mod.   Played around with the angles today, to come up with a few variations,  Replace the original angle (a) line with one of these to see the different effects achieved manipulating the angle.\n' 2024-10-03 Dav      Here's a few more, that's about all I think.\n' 2024-10-07 madscijr added press A to cycle through formulas\n\nConst FALSE = 0\nConst TRUE = Not FALSE\nDim bFinished As Integer\nDim bRestart As Integer\nDim bChange As Integer\nDim iLastKey As Integer\nDim iAngleFn As Integer\nDim iMaxAngleFn As Integer\nDim cx As Integer\nDim cy As Integer\nDim m1 As Integer\nDim m2 As Integer\nDim m3 As Integer\n\nScreen _NewImage(800, 600, 32)\n_ScreenMove 250, 60\n\nbFinished = FALSE\nbRestart = TRUE\niAngleFn = 0\niMaxAngleFn = 11\n\nDo\n    If bRestart = TRUE Then\n        ' Init values\n        cx = _Width / 2\n        cy = _Height / 2\n        m1 = 9\n        m2 = 27\n        m3 = 3\n\n        ' Choose a new formula\n        'iAngleFn = RandomNumber%(1, iMaxAngleFn)\n        iAngleFn = iAngleFn + 1: If iAngleFn > iMaxAngleFn Then iAngleFn = 1\n\n        '' Display in title bar\n        '_Title \"Dav 'Pulse' Plasma Blend: angle style \" + _Trim$(Str$(iAngleFn)) + \" (press a to change, any other key for random, esc to quit)\"\n\n        ' Don't run again until user presses \"a\" again\n        bRestart = FALSE\n    ElseIf bChange = TRUE Then\n        ' Randomize values\n        m3 = Int(Rnd * 12)\n        m = Int(Rnd * 3) + 2\n        m1 = m * m3\n        m2 = m * m1\n\n        ' Don't run again until user presses \"b\"\n        bChange = FALSE\n    End If\n\n    T = T + .01 ' mod\n    pulse = Sin(T) * .8 'pulse factor\n\n    For y = 0 To _Height Step 3\n        For x = 0 To _Width Step 3\n\n            ' --------------------------------------------------------------------------------\n            ' case 1\n            ' bplus\n            ' 10-02-2024, 04:45 PM (This post was last modified: 10-02-2024, 04:47 PM by bplus.)\n            ' #207 OK here is a mod Smile\n            ' --------------------------------------------------------------------------------\n            ' Case 2-7\n            ' Dav\n            ' 10-03-2024, 03:31 PM\n            ' #210: Hey, bplus, I really like your mod.\n            ' Played around with the angles today, to come up with a few variations,\n            ' Replace the original angle (a) line with one of these\n            ' to see the different effects achieved manipulating the angle.\n            ' --------------------------------------------------------------------------------\n            ' case 8-11\n            ' Dav\n            ' 10-03-2024, 07:04 PM\n            ' #212 Here's a few more, that's about all I think.\n            ' --------------------------------------------------------------------------------\n\n            Select Case iAngleFn\n                Case 1:\n                    a = _Atan2(y - cy, x - cx) + T 'original\n                Case 2:\n                    a = _Atan2(y - cy, x - cx) + Sin(rad * 2 + T) 'spiral twist\n                Case 3:\n                    a = _Atan2(y - cy, x - cx) + Sin(T) * 4 'churning using sin\n                Case 4:\n                    a = _Atan2(y - cy, x - cx) + Cos(T) * 4 'churning using cos\n                Case 5:\n                    a = _Atan2(y - cy, x - cx) + Sin(T) * rad 'spiral (radius)\n                Case 6:\n                    a = _Atan2(y - cy, x - cx) + Sin(T * 4 + (x / _Width)) * .5 'edge wave\n                Case 7:\n                    a = _Atan2(y - cy, x - cx) + (x / _Width) * Sin(T) * 5 'distort\n                Case 8:\n                    a = _Atan2(y - cy, x - cx) + Cos(T) * 3 + Sin(x / _Width + T * 3) 'better wave\n                Case 9:\n                    a = _Atan2(y - cy, x - cx) + Sin(T * 2) * Cos(rad * 2) 'double twist!\n                Case 10:\n                    a = _Atan2(y - cy, x - cx) + Sin(rad * 1.5 + T * 4) 'inward spiral\n                Case 11:\n                    a = _Atan2(y - cy, x - cx) + Sin(x * .01 + T) * Cos(y * .01 + T) 'mumps!\n            End Select\n\n            rad = Sqr((x - cx) ^ 2 + (y - cy) ^ 2) / 100\n\n            '1st plasma colors\n            r1 = (Sin(rad * m3 + T) + Sin(a * m1 + T)) * 127 '+ 128\n            g1 = (Sin(rad * m3 + T + 1) + Sin(a * m1 + T + 1)) * 127 '+ 128\n            b1 = (Sin(rad * m3 + T + 2) + Sin(a * m1 + T + 2)) * 127 ' + 128\n\n            '2nd plasma colors\n            r2 = (Sin(rad * 3 + T) + Sin(a * 3 + T + 1)) * 127 + 128\n            g2 = (Sin(rad * 3 + T + 2) + Sin(a * m2 + T + 3)) * 127 + 128\n            b2 = (Sin(rad * 3 + T + 4) + Sin(a * m2 + T + 4)) * 127 + 128\n\n            'Blend plasma colors using pulse factor\n            r = r1 * (1 - pulse) + r2 * pulse\n            g = g1 * (1 - pulse) + g2 * pulse\n            b = b1 * (1 - pulse) + b2 * pulse\n\n            Line (x, y)-Step(2, 2), _RGB(r, g, b), BF\n\n        Next x\n    Next y\n\n    Locate 1, 1: Print _Trim$(Str$(iAngleFn))\n\n    _Display\n    _Limit 30\n\n    If _KeyDown(27) Then\n        bFinished = TRUE\n    ElseIf _KeyDown(Asc(\"a\")) Then\n        If iLastKey <> Asc(\"a\") Then ' don't let user hold down \"a\" key\n            bRestart = TRUE\n            iLastKey = Asc(\"a\")\n        End If\n    Else\n        iLastKey = 0\n        If InKey$ <> \"\" Then\n            bChange = TRUE\n        End If\n    End If\nLoop Until bFinished = TRUE ' _KeyDown(27)\n\nEnd\n\n' /////////////////////////////////////////////////////////////////////////////\n' Generate random value between Min and Max inclusive.\n\nFunction RandomNumber% (Min%, Max%)\n    Dim NumSpread%\n\n    ' SET RANDOM SEED\n    'Randomize ' Initialize random-number generator.\n    Randomize Timer\n\n    ' GET RANDOM # Min%-Max%\n    'RandomNumber = Int((Max * Rnd) + Min) ' generate number\n\n    NumSpread% = (Max% - Min%) + 1\n\n    RandomNumber% = Int(Rnd * NumSpread%) + Min% ' GET RANDOM # BETWEEN Max% AND Min%\nEnd Function ' RandomNumber%"
  },
  {
    "input": "Flipping Hex Maze",
    "output": "_Title \"Flipping Hex Maze\" ' b+ 2024-11-01\nScreen _NewImage(801, 590, 32): _ScreenMove 240, 60\nType BoardType\n    As Single x, y, flipped, flipping, a\nEnd Type\nDim Shared ubX, ubY\nubX = 18: ubY = 16\nDim Shared b(ubX, ubY) As BoardType\nDim Shared cellR, xspacing!, yspacing!\ncellR = 25\nxspacing! = 2 * cellR * Cos(_D2R(30)): yspacing! = cellR * (1 + Sin(_D2R(30)))\nDim xoffset!\nColor &HFF000000, &HFFAAAAFF\nDo\n    m = (m + 1) Mod ubX\n    Cls\n    For y = 0 To ubY\n        If y Mod 2 = 0 Then xoffset! = .5 * xspacing! Else xoffset! = 0\n        For x = 0 To ubX\n            b(x, y).x = x * xspacing! + xoffset! + .5 * xspacing! - 20\n            b(x, y).y = y * yspacing! + .5 * yspacing! - 20\n            If Rnd < .002 Then b(x, y).flipping = 1\n            showCell x, y\n        Next\n    Next\n    _Display\n    _Limit 60\nLoop\n\nSub showCell (c, r)\n    If b(c, r).flipping Then b(c, r).a = b(c, r).a + _Pi(1 / 90)\n    If b(c, r).a >= _Pi(1 / 3) Then\n        b(c, r).flipping = 0: b(c, r).a = 0\n        If b(c, r).flipped Then b(c, r).flipped = 0 Else b(c, r).flipped = 1\n    End If\n    If b(c, r).flipped Then\n        For a = _Pi(1 / 6) To _Pi(2) Step _Pi(2 / 3)\n            Line (b(c, r).x, b(c, r).y)-Step(cellR * Cos(a + b(c, r).a), cellR * Sin(a + b(c, r).a))\n        Next\n    Else\n        For a = _Pi(.5) To _Pi(2) Step _Pi(2 / 3)\n            Line (b(c, r).x, b(c, r).y)-Step(cellR * Cos(a + b(c, r).a), cellR * Sin(a + b(c, r).a))\n        Next\n    End If\nEnd Sub"
  },
  {
    "input": "Guts",
    "output": "_Title \"Guts\" 'passed down through ages, I first encountered it through Richard Russel author BBC 4 Windows\n' 2019-04-05 B+ translation to QB64 from: Guts.bas SmallBASIC 0.12.0 2015-11-17 MGA/B+\n'modified  > GUTS  Original ARM BBC BASIC version by Jan Vibe, 800x600 ?\n\nRandomize Timer\nConst xmax = 800\nConst ymax = 600\nScreen _NewImage(xmax, ymax, 32)\n_ScreenMove 200, 60\n\nDim bX(15), bY(15), bZ(15), COLR(15) As _Unsigned Long\nbX(1) = -100: A = 0\nFor N = 1 To 15\n    COLR(16 - N) = _RGB32(7 * N + 150, 14 * N + 45, 14 * N + 45)\nNext\n\nX1 = Rnd * xmax: Y1 = Rnd * ymax: DX1 = (Rnd * 16 + 1) * (Rnd - .5): DY1 = (Rnd * 16 + 1) * (Rnd - .5)\nX2 = Rnd * xmax: Y2 = Rnd * ymax: DX2 = (Rnd * 16 + 1) * (Rnd - .5): DY2 = (Rnd * 16 + 1) * (Rnd - .5)\nWhile _KeyDown(27) = 0\n    H = X1 + DX1: If H < 0 Or H > xmax Then DX1 = (Rnd * 16 + 1) * -Sgn(DX1)\n    H = Y1 + DY1: If H < 0 Or H > ymax Then DY1 = (Rnd * 16 + 1) * -Sgn(DY1)\n    X1 = X1 + DX1: Y1 = Y1 + DY1\n    If X2 < X1 And DX2 < 24 Then DX2 = DX2 + 1\n    If X2 > X1 And DX2 > -24 Then DX2 = DX2 - 1\n    If Y2 < Y1 And DY2 < 24 Then DY2 = DY2 + 1\n    If Y2 > Y1 And DY2 > -24 Then DY2 = DY2 - 1\n    X2 = X2 + DX2: Y2 = Y2 + DY2: A = (A + 10) Mod 360: Z = (Sin(_D2R(A) + 1)) + 2\n    For N = 2 To 15\n        bX(N - 1) = bX(N): bY(N - 1) = bY(N): bZ(N - 1) = bZ(N)\n    Next\n    bX(15) = X2: bY(15) = Y2: bZ(15) = Z\n    For N = 1 To 15: fcirc bX(N), bY(N), N * bZ(N) + 5, COLR(N): Next\n    _Display\n    _Limit 60\nWend\nSleep\n\n'from Steve Gold standard\nSub fcirc (CX As Integer, CY As Integer, R As Integer, C As _Unsigned Long)\n    Dim Radius As Integer, RadiusError As Integer\n    Dim X As Integer, Y As Integer\n\n    Radius = Abs(R)\n    RadiusError = -Radius\n    X = Radius\n    Y = 0\n\n    If Radius = 0 Then PSet (CX, CY), C: Exit Sub\n\n    ' Draw the middle span here so we don't draw it twice in the main loop,\n    ' which would be a problem with blending turned on.\n    Line (CX - X, CY)-(CX + X, CY), C, BF\n\n    While X > Y\n        RadiusError = RadiusError + Y * 2 + 1\n        If RadiusError >= 0 Then\n            If X <> Y + 1 Then\n                Line (CX - Y, CY - X)-(CX + Y, CY - X), C, BF\n                Line (CX - Y, CY + X)-(CX + Y, CY + X), C, BF\n            End If\n            X = X - 1\n            RadiusError = RadiusError - X * 2\n        End If\n        Y = Y + 1\n        Line (CX - X, CY - Y)-(CX + X, CY - Y), C, BF\n        Line (CX - X, CY + Y)-(CX + X, CY + Y), C, BF\n    Wend\nEnd Sub"
  },
  {
    "input": "Sin Waves",
    "output": " \nDim w, h\nw = 640\nh = 640\nScreen _NewImage(w, h, 32)\n_ScreenMove 340, 60\nDim i, t, x, y\nDo\n    t = t + 0.01\n    Line (0, 0)-(w, h), _RGBA(0, 0, 0, 25), BF\n    For i = 1 To 8\n        Color _RGBA(i * 32, i * 32 * .7, 0, i * 32)\n        For x = 0 To w\n            y = 100 * Sin(_Pi * x / w) * Sin(1 * _Pi * x / w + t + i * t * _Pi * 0.1)\n            Circle (x, h / 2 + y), i\n            Circle (w / 2 + y, x), i\n        Next\n    Next\n    _Display\n    _Limit 30\nLoop\n"
  },
  {
    "input": "Fake Voronoi Plasma",
    "output": "'fake-voronoi-plasma.bas\n'Dav, OCT/2023\nScreen _NewImage(800, 600, 32)\nDo\n    For x = 0 To _Width Step 2\n        For y = 0 To _Height Step 2\n            d = Sqr(((x - y) ^ 2) + t + ((y - x) ^ 2) + t)\n            Line (x, y)-Step(2, 2), _RGBA((d + x + t) Mod 255, (d + y + t) Mod 255, (d + t) Mod 255, 10), BF\n        Next\n    Next\n    t = t + 1\n    _Limit 30\nLoop Until InKey$ = Chr$(27)\n"
  },
  {
    "input": "Diffusion",
    "output": "OPTION _EXPLICIT\nRANDOMIZE TIMER\n\nSCREEN _NEWIMAGE(800, 800, 32)\n\nTYPE Vector2D\n    x AS DOUBLE\n    y AS DOUBLE\nEND TYPE\n\nTYPE Vector2I\n    x AS INTEGER\n    y AS INTEGER\nEND TYPE\n\nTYPE Cell\n    Center AS Vector2D\n    Species AS INTEGER\n    ' -1 = Source\n    '  0 = Clear\n    '  1 = Opaque\n    Intensity AS DOUBLE\n    Translucence AS DOUBLE\nEND TYPE\n\nDIM AS DOUBLE CellWidth\nDIM AS DOUBLE CellHeight\nDIM AS INTEGER CellCountX\nDIM AS INTEGER CellCountY\n\nIF (0 = 1) THEN ' Specify cell dimensions, calculate total number.\n    CellWidth = 10\n    CellHeight = 10\n    CellCountX = INT(_WIDTH / CellWidth)\n    CellCountY = INT(_HEIGHT / CellHeight)\nELSE '          ' Specify cell number, calculate dimensions.\n    CellCountX = 50\n    CellCountY = 50\n    CellWidth = _WIDTH / CellCountX\n    CellHeight = _HEIGHT / CellCountY\nEND IF\n\nDIM AS Cell World(CellCountX, CellCountY)\nDIM AS Cell WorldAux(CellCountX, CellCountY)\n\nDIM AS INTEGER i\nDIM AS INTEGER j\nDIM AS INTEGER jj\nDIM AS INTEGER j0\nDIM AS INTEGER k\nDIM AS INTEGER kk\nDIM AS INTEGER k0\nDIM AS DOUBLE x0\nDIM AS DOUBLE y0\nDIM AS DOUBLE Accumulator\nDIM AS DOUBLE Normalizer\nDIM AS DOUBLE Factor\n\n' Create diffusion kernel.\nDIM AS DOUBLE ImgKernel(-1 TO 1, -1 TO 1)\nImgKernel(1, -1) = 7 '  1 / Sqr(2)\nImgKernel(0, -1) = 10 ' 1\nImgKernel(-1, -1) = 7 ' 1 / Sqr(2)\nImgKernel(1, 0) = 10 '  1\nImgKernel(0, 0) = 0 '   0\nImgKernel(-1, 0) = 10 ' 1\nImgKernel(1, 1) = 7 '   1 / Sqr(2)\nImgKernel(0, 1) = 10 '  1\nImgKernel(-1, 1) = 7 '  1 / Sqr(2)\n\n' Initialize world (just once)\nFOR j = 1 TO CellCountX\n    FOR k = 1 TO CellCountY\n        World(j, k).Center.x = (j - 1 / 2) * CellWidth\n        World(j, k).Center.y = (k - 1 / 2) * CellHeight\n    NEXT\nNEXT\n\nDIM Player AS Vector2I\nPlayer.x = 12\nPlayer.y = 15\n\nDIM AS Vector2I LightSourcePositions(20)\nFOR i = 1 TO UBOUND(LightSourcePositions)\n    LightSourcePositions(i).x = 1 + INT(RND * CellCountX)\n    LightSourcePositions(i).y = 1 + INT(RND * CellCountY)\nNEXT\n\nDO\n\n    ' Re-initialize world with every refresh, or perhaps with only significant state updates\n    FOR j = 1 TO CellCountX\n        FOR k = 1 TO CellCountY\n            World(j, k).Species = 0\n            World(j, k).Translucence = 1\n            World(j, k).Intensity = 0\n        NEXT\n    NEXT\n\n    ' Opaque things\n    FOR i = 1 TO 5\n        j0 = 4 * i\n        k0 = 4 * i\n        FOR j = j0 TO 2 * j0 + 1\n            World(j, j0).Species = 1\n            World(j, 2 * k0 + 1).Species = 1\n            World(j, j0).Translucence = 0\n            World(j, 2 * k0 + 1).Translucence = 0\n        NEXT\n        FOR k = k0 + 1 TO 2 * k0\n            World(j0, k).Species = 1\n            World(2 * j0 + 1, k).Species = 1\n            World(j0, k).Translucence = 0\n            World(2 * j0 + 1, k).Translucence = 0\n        NEXT\n\n        FOR j = j0 TO 2 * j0 + 1\n            World(7 + j, 7 + j0).Species = 1\n            World(7 + j, 7 + 2 * k0 + 1).Species = 1\n            World(7 + j, 7 + j0).Translucence = .15\n            World(7 + j, 7 + 2 * k0 + 1).Translucence = .15\n        NEXT\n        FOR k = k0 + 1 TO 2 * k0\n            World(7 + j0, 7 + k).Species = 1\n            World(7 + 2 * j0 + 1, 7 + k).Species = 1\n            World(7 + j0, 7 + k).Translucence = .15\n            World(7 + 2 * j0 + 1, 7 + k).Translucence = .15\n        NEXT\n    NEXT\n\n    ' Light sources\n    FOR i = 1 TO UBOUND(LightSourcePositions)\n        j = LightSourcePositions(i).x\n        k = LightSourcePositions(i).y\n        World(j, k).Species = -1\n        World(j, k).Intensity = 1\n    NEXT\n\n    WHILE _MOUSEINPUT: WEND\n\n    ' Player\n    Player.x = INT(_MOUSEX + CellWidth / 2) / CellWidth\n    Player.y = INT(_MOUSEY + CellHeight / 2) / CellHeight\n    j = INT(Player.x)\n    k = INT(Player.y)\n    World(j, k).Species = -1\n    World(j, k).Intensity = 1\n\n    FOR i = 1 TO 20\n        FOR j = 1 TO CellCountX\n            FOR k = 1 TO CellCountY\n                IF (World(j, k).Species <> -1) THEN\n                    Accumulator = 0\n                    Normalizer = 0\n                    FOR jj = -1 TO 1\n                        FOR kk = -1 TO 1\n                            j0 = j + jj\n                            k0 = k + kk\n                            IF (j0 < 1) THEN j0 = 1\n                            IF (k0 < 1) THEN k0 = 1\n                            IF (j0 > CellCountX) THEN j0 = CellCountX\n                            IF (k0 > CellCountY) THEN k0 = CellCountY\n                            Accumulator = Accumulator + World(j0, k0).Intensity * World(j, k).Translucence * ImgKernel(jj, kk)\n                            Normalizer = Normalizer + ImgKernel(jj, kk)\n                        NEXT\n                    NEXT\n                    WorldAux(j, k).Intensity = Accumulator / Normalizer\n                END IF\n            NEXT\n        NEXT\n        FOR j = 1 TO CellCountX\n            FOR k = 1 TO CellCountY\n                IF (World(j, k).Species <> -1) THEN\n                    World(j, k).Intensity = WorldAux(j, k).Intensity\n                END IF\n            NEXT\n        NEXT\n    NEXT\n\n    CLS\n    FOR j = 1 TO CellCountX\n        FOR k = 1 TO CellCountY\n            x0 = World(j, k).Center.x\n            y0 = World(j, k).Center.y\n            Factor = ((World(j, k).Intensity)) ^ .3\n            IF (World(j, k).Species = -1) THEN\n                LINE (x0 - CellWidth / 2, y0 - CellHeight / 2)-(x0 + CellWidth / 2, y0 + CellHeight / 2), _RGB32(255 * Factor, 255 * Factor, 0, 255), BF\n            ELSEIF (World(j, k).Species = 0) THEN\n                LINE (x0 - CellWidth / 2, y0 - CellHeight / 2)-(x0 + CellWidth / 2, y0 + CellHeight / 2), _RGB32(255 * Factor, 0, 0, 255), BF\n            ELSEIF (World(j, k).Species = 1) THEN\n                LINE (x0 - CellWidth / 2, y0 - CellHeight / 2)-(x0 + CellWidth / 2, y0 + CellHeight / 2), _RGB32(0, 255 * World(j, k).Translucence, 200, 255), BF\n            END IF\n            LINE (x0 - CellWidth / 2, y0 - CellHeight / 2)-(x0 + CellWidth / 2, y0 + CellHeight / 2), _RGB32(128, 128, 128, 255), B\n        NEXT\n    NEXT\n\n    _DISPLAY\n    _LIMIT 120\nLOOP\n\n"
  },
  {
    "input": "Scalar Field",
    "output": "OPTION _EXPLICIT\n\nDO UNTIL _SCREENEXISTS: LOOP\n_TITLE \"Scalar Field\"\n\nSCREEN _NEWIMAGE(800, 600, 32)\nRANDOMIZE TIMER\n\nTYPE Vector\n    x AS DOUBLE\n    y AS DOUBLE\nEND TYPE\n\nDIM SHARED Position(10) AS Vector\nDIM SHARED Velocity(10) AS Vector\nDIM AS INTEGER j, k\nDIM AS DOUBLE f, f1, f3, f7, f9, g\n\nFOR j = 1 TO UBOUND(Position)\n    Position(j).x = _WIDTH * (RND - .5)\n    Position(j).y = _HEIGHT * (RND - .5)\n    Velocity(j).x = 5 * (RND - .5)\n    Velocity(j).y = 5 * (RND - .5)\nNEXT\n\nDO\n    CLS\n\n    FOR j = 1 TO UBOUND(Position)\n        Position(j).x = Position(j).x + Velocity(j).x\n        Position(j).y = Position(j).y + Velocity(j).y\n        IF (Position(j).x < -_WIDTH / 2) THEN Velocity(j).x = -Velocity(j).x\n        IF (Position(j).x > _WIDTH / 2) THEN Velocity(j).x = -Velocity(j).x\n        IF (Position(j).y < -_HEIGHT / 2) THEN Velocity(j).y = -Velocity(j).y\n        IF (Position(j).y > _HEIGHT / 2) THEN Velocity(j).y = -Velocity(j).y\n    NEXT\n\n    FOR j = -_WIDTH / 2 TO _WIDTH / 2 STEP 10\n        FOR k = -_HEIGHT / 2 TO _HEIGHT / 2 STEP 10\n            f = 15 * CalcPotential#(j, k)\n            CALL CCircle(j, k, 4, _RGB(255 * f, 255 * f / 2, 255 * f / 4))\n            'NEXT\n            'NEXT\n\n            'FOR j = -_WIDTH / 2 TO _WIDTH / 2 STEP 10\n            'FOR k = -_HEIGHT / 2 TO _HEIGHT / 2 STEP 10\n            f1 = 10 * CalcPotential#(j - 5, k - 5)\n            f3 = 10 * CalcPotential#(j + 5, k - 5)\n            f7 = 10 * CalcPotential#(j - 5, k + 5)\n            f9 = 10 * CalcPotential#(j + 5, k + 5)\n            FOR g = .15 TO .65 STEP .1\n                f = .5\n                IF (f1 > g) AND (f3 > g) AND (f7 > g) AND (f9 > g) THEN f = 1\n                IF (f1 < g) AND (f3 < g) AND (f7 < g) AND (f9 < g) THEN f = 0\n                IF (f = .5) THEN\n                    IF (f1 < g) AND (f3 < g) AND (f7 > g) AND (f9 > g) THEN CALL CLine(j - 5, k, j + 5, k, _RGB(255, 255, 255 / 2))\n                    IF (f1 > g) AND (f3 > g) AND (f7 < g) AND (f9 < g) THEN CALL CLine(j - 5, k, j + 5, k, _RGB(255, 255, 255 / 2))\n                    IF (f1 > g) AND (f3 < g) AND (f7 > g) AND (f9 < g) THEN CALL CLine(j, k - 5, j, k + 5, _RGB(255, 255, 255 / 2))\n                    IF (f1 < g) AND (f3 > g) AND (f7 < g) AND (f9 > g) THEN CALL CLine(j, k - 5, j, k + 5, _RGB(255, 255, 255 / 2))\n                    IF (f1 > g) AND (f3 < g) AND (f7 < g) AND (f9 < g) THEN CALL CLine(j - 5, k, j, k - 5, _RGB(255, 255, 255 / 2))\n                    IF (f1 < g) AND (f3 > g) AND (f7 < g) AND (f9 < g) THEN CALL CLine(j, k - 5, j + 5, k, _RGB(255, 255, 255 / 2))\n                    IF (f1 < g) AND (f3 < g) AND (f7 > g) AND (f9 < g) THEN CALL CLine(j - 5, k, j, k + 5, _RGB(255, 255, 255 / 2))\n                    IF (f1 < g) AND (f3 < g) AND (f7 < g) AND (f9 > g) THEN CALL CLine(j, k + 5, j + 5, k, _RGB(255, 255, 255 / 2))\n                END IF\n            NEXT\n        NEXT\n    NEXT\n\n    _DISPLAY\n    _LIMIT 60\nLOOP\n\nEND\n\nFUNCTION CalcPotential# (x0 AS DOUBLE, y0 AS DOUBLE)\n    DIM TheReturn AS DOUBLE\n    DIM AS INTEGER j\n    DIM AS DOUBLE dx, dy, r\n    TheReturn = 0\n    FOR j = 1 TO UBOUND(Position)\n        dx = x0 - Position(j).x\n        dy = y0 - Position(j).y\n        r = SQR(dx * dx + dy * dy)\n        TheReturn = TheReturn + 1 / r\n    NEXT\n    CalcPotential# = TheReturn\nEND FUNCTION\n\nSUB CCircle (x0 AS DOUBLE, y0 AS DOUBLE, rad AS DOUBLE, shade AS _UNSIGNED LONG)\n    CIRCLE (_WIDTH / 2 + x0, -y0 + _HEIGHT / 2), rad, shade\nEND SUB\n\nSUB CLine (x0 AS DOUBLE, y0 AS DOUBLE, x1 AS DOUBLE, y1 AS DOUBLE, shade AS _UNSIGNED LONG)\n    LINE (_WIDTH / 2 + x0, -y0 + _HEIGHT / 2)-(_WIDTH / 2 + x1, -y1 + _HEIGHT / 2), shade\nEND SUB\n\n"
  },
  {
    "input": "Vector Field",
    "output": "OPTION _EXPLICIT\n\nDO UNTIL _SCREENEXISTS: LOOP\n_TITLE \"Vector Field\"\n\n' Meta\nRANDOMIZE TIMER\n\nCONST Aquamarine = _RGB32(127, 255, 212)\nCONST Lime = _RGB32(0, 255, 0)\n\nDIM SHARED XSize\nDIM SHARED YSize\nDIM SHARED XCells\nDIM SHARED YCells\nDIM SHARED NPC\nXSize = 30\nYSize = 30\nXCells = 30\nYCells = 30\nNPC = .1 * SQR(XCells * YCells)\nSCREEN _NEWIMAGE(XSize * XCells, YSize * YCells, 32)\n\n\nTYPE Vector\n    x AS DOUBLE\n    y AS DOUBLE\nEND TYPE\n\nTYPE FieldLine\n    Center AS Vector\n    Tangent AS Vector\nEND TYPE\n\nTYPE Particle\n    Displacement AS Vector\n    Velocity AS Vector\n    Shade AS _UNSIGNED LONG\nEND TYPE\n\nTYPE Charge\n    Center AS Vector\n    Radial AS Vector\n    Angular AS Vector\nEND TYPE\n\nDIM SHARED VectorField(XCells, YCells) AS FieldLine\nDIM SHARED Particles(XCells, YCells, NPC) AS Particle\nDIM SHARED Charges(100) AS Charge\nDIM SHARED ChargeCount\n\nChargeCount = 1\nCharges(ChargeCount).Center.x = 0\nCharges(ChargeCount).Center.y = 0\nCharges(ChargeCount).Radial.x = .05\nCharges(ChargeCount).Radial.y = .05\nCharges(ChargeCount).Angular.x = 0\nCharges(ChargeCount).Angular.y = 0\n\nDIM i AS INTEGER\nDIM j AS INTEGER\nDIM k AS INTEGER\n\nFOR i = 1 TO XCells\n    FOR j = 1 TO YCells\n        VectorField(i, j).Center.x = (1 / 2) * XSize * (2 * i - XCells) - XSize / 2\n        VectorField(i, j).Center.y = (1 / 2) * YSize * (2 * j - YCells) - YSize / 2\n        FOR k = 1 TO NPC\n            Particles(i, j, k).Shade = Lime\n            Particles(i, j, k).Displacement.x = XSize * (RND - .5)\n            Particles(i, j, k).Displacement.y = YSize * (RND - .5)\n        NEXT\n    NEXT\nNEXT\n\nCALL CalculateField\n\nDIM x AS DOUBLE\nDIM y AS DOUBLE\n\nDO\n    DO WHILE _MOUSEINPUT\n        x = _MOUSEX\n        y = _MOUSEY\n        IF ((x > 0) AND (x < _WIDTH) AND (y > 0) AND (y < _HEIGHT)) THEN\n            Charges(ChargeCount).Center.x = (x - _WIDTH / 2)\n            Charges(ChargeCount).Center.y = (-y + _HEIGHT / 2)\n            CALL CalculateField\n        END IF\n    LOOP\n\n    k = _KEYHIT\n    SELECT CASE k\n        CASE 49\n            Charges(ChargeCount).Radial.x = .05\n            Charges(ChargeCount).Radial.y = .05\n            Charges(ChargeCount).Angular.x = 0\n            Charges(ChargeCount).Angular.y = 0\n        CASE 50\n            Charges(ChargeCount).Radial.x = -.05\n            Charges(ChargeCount).Radial.y = -.05\n            Charges(ChargeCount).Angular.x = 0\n            Charges(ChargeCount).Angular.y = 0\n        CASE 51\n            Charges(ChargeCount).Radial.x = .05\n            Charges(ChargeCount).Radial.y = -.05\n            Charges(ChargeCount).Angular.x = 0\n            Charges(ChargeCount).Angular.y = 0\n        CASE 52\n            Charges(ChargeCount).Radial.x = -.05\n            Charges(ChargeCount).Radial.y = .05\n            Charges(ChargeCount).Angular.x = 0\n            Charges(ChargeCount).Angular.y = 0\n        CASE 53\n            Charges(ChargeCount).Radial.x = 0\n            Charges(ChargeCount).Radial.y = 0\n            Charges(ChargeCount).Angular.x = .05\n            Charges(ChargeCount).Angular.y = -.05\n        CASE 54\n            Charges(ChargeCount).Radial.x = 0\n            Charges(ChargeCount).Radial.y = 0\n            Charges(ChargeCount).Angular.x = -.05\n            Charges(ChargeCount).Angular.y = .05\n        CASE 48\n            ChargeCount = 1\n        CASE 32\n            ChargeCount = ChargeCount + 1\n            Charges(ChargeCount).Center.x = Charges(ChargeCount - 1).Center.x\n            Charges(ChargeCount).Center.y = Charges(ChargeCount - 1).Center.y\n            Charges(ChargeCount).Radial.x = Charges(ChargeCount - 1).Radial.x\n            Charges(ChargeCount).Radial.y = Charges(ChargeCount - 1).Radial.y\n            Charges(ChargeCount).Angular.x = Charges(ChargeCount - 1).Angular.x\n            Charges(ChargeCount).Angular.y = Charges(ChargeCount - 1).Angular.y\n    END SELECT\n    IF (k <> 0) THEN\n        CALL CalculateField\n    END IF\n    _KEYCLEAR\n\n    LINE (0, 0)-(_WIDTH, _HEIGHT), _RGBA(0, 0, 0, 20), BF\n\n    DIM xc AS DOUBLE\n    DIM yc AS DOUBLE\n    DIM xd AS DOUBLE\n    DIM yd AS DOUBLE\n    DIM xx AS DOUBLE\n    DIM yy AS DOUBLE\n\n    LOCATE 1, 1: PRINT \"Press 1-6 to change charge type. Press space to fix charge, 0 to clear.\"\n    FOR i = 1 TO XCells\n        FOR j = 1 TO YCells\n            xc = VectorField(i, j).Center.x\n            yc = VectorField(i, j).Center.y\n            FOR k = 1 TO NPC\n                xd = 0\n                yd = 0\n                xx = Particles(i, j, k).Displacement.x + .1 * Particles(i, j, k).Velocity.x\n                yy = Particles(i, j, k).Displacement.y + .1 * Particles(i, j, k).Velocity.y\n                IF (xx < -XSize / 2) THEN\n                    xd = -xx + XSize / 2\n                END IF\n                IF (xx > XSize / 2) THEN\n                    xd = -xx - XSize / 2\n                END IF\n                IF (yy < -YSize / 2) THEN\n                    yd = -yy + YSize / 2\n                END IF\n                IF (yy > YSize / 2) THEN\n                    yd = -yy + -YSize / 2\n                END IF\n                Particles(i, j, k).Displacement.x = xx + xd\n                Particles(i, j, k).Displacement.y = yy + yd\n                CALL cpset(xc + Particles(i, j, k).Displacement.x, yc + Particles(i, j, k).Displacement.y, Particles(i, j, k).Shade)\n            NEXT\n        NEXT\n    NEXT\n    _LIMIT 60\n    _DISPLAY\nLOOP\n\nEND\n\nSUB CalculateField\n    DIM i AS INTEGER\n    DIM j AS INTEGER\n    DIM k AS INTEGER\n    DIM dx AS DOUBLE\n    DIM dy AS DOUBLE\n    DIM d2 AS DOUBLE\n    DIM xx AS DOUBLE\n    DIM yy AS DOUBLE\n    FOR i = 1 TO XCells\n        FOR j = 1 TO YCells\n            xx = 0\n            yy = 0\n            FOR k = 1 TO ChargeCount\n                dx = VectorField(i, j).Center.x - Charges(k).Center.x\n                dy = VectorField(i, j).Center.y - Charges(k).Center.y\n                d2 = 5000 / (dx * dx + dy * dy)\n                xx = xx + (Charges(k).Radial.x * dx * d2) + (Charges(k).Angular.x * dy * d2)\n                yy = yy + (Charges(k).Radial.y * dy * d2) + (Charges(k).Angular.y * dx * d2)\n            NEXT\n            VectorField(i, j).Tangent.x = xx\n            VectorField(i, j).Tangent.y = yy\n            FOR k = 1 TO NPC\n                Particles(i, j, k).Velocity.x = VectorField(i, j).Tangent.x\n                Particles(i, j, k).Velocity.y = VectorField(i, j).Tangent.y\n            NEXT\n        NEXT\n    NEXT\nEND SUB\n\nSUB cpset (x1, y1, col AS _UNSIGNED LONG)\n    PSET (_WIDTH / 2 + x1, -y1 + _HEIGHT / 2), col\nEND SUB\n\n\n"
  }
]
